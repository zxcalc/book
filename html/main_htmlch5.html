<!DOCTYPE html> 
<html lang='en-US' xml:lang='en-US'> 
<head><title>5 Clifford circuits and diagrams</title> 
<meta charset='utf-8' /> 
<meta content='TeX4ht (https://tug.org/tex4ht/)' name='generator' /> 
<meta content='width=device-width,initial-scale=1' name='viewport' /> 
<link href='main_html.css' rel='stylesheet' type='text/css' /> 
<meta content='main_html.tex' name='src' /> 
 <script async='async' id='MathJax-script' src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-chtml.js' type='text/javascript'></script>  
</head><body>
   <!-- l. 11 --><div class='crosslinks'><p class='noindent'>[<a href='main_htmlch6.html'>next</a>] [<a href='main_htmlch4.html'>prev</a>] [<a href='main_htmlch4.html#tailmain_htmlch4.html'>prev-tail</a>] [<a href='#tailmain_htmlch5.html'>tail</a>] [<a href='main_html.html#main_htmlch5.html'>up</a>] </p></div>
   <h2 class='chapterHead' id='clifford-circuits-and-diagrams'><span class='titlemark'>Chapter 5</span><br /><a id='x7-1070005'></a>Clifford circuits and diagrams</h2>
<!-- l. 13 --><p class='noindent'>In the previous chapter we saw that there were already a lot of interesting things
to say about phase-free ZX-diagrams. However, interesting as they are,
because there are no phases, these diagrams don’t allow us to do many cool
quantum computing things. In this chapter we will remedy this problem and
introduce some phases back into the picture. Instead of immediately
allowing all possible phases, we will expand our scope to the <span class='cmbx-10x-x-109'>Clifford
ZX-diagrams</span>. These are ZX-diagrams whose angles are all integer multiples of
<!-- l. 15 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></math>. At first,
this might seem somewhat artificial, but we’ll see that in this special setting,
even huge diagrams can always be simplified all the way down to a compact
canonical form, called <span class='cmbx-10x-x-109'>GSLC form</span>. It turns out this reduced diagram only has
<!-- l. 15 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> spiders in it
and <!-- l. 15 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> wires,
where <!-- l. 15 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> is
the number of qubits. A couple of magical things happen as a consequence. In
particular, virtually everything we would want to do with such a diagram is
efficient, from computing single matrix elements to comparing two such diagrams
for equality. Related to this: any circuit which can be translated into a Clifford
ZX-diagram can be efficiently classically simulated. We call such circuits <span class='cmbx-10x-x-109'>Clifford
circuits</span>, and this is (a version of) the famous <span class='cmbx-10x-x-109'>Gottesman-Knill theorem</span>.
Just because we can efficiently reason about Clifford diagrams does not mean
they are not useful, far from it! We will see that Clifford diagrams form the
backbone in measurement-based quantum computing (Chapter <a href='main_htmlch8.html#measurementbased-quantum-computation'>8<!-- tex4ht:ref: ch:mbqc  --></a>) and quantum
error correction (Chapter <a href='main_htmlch11.html#quantum-error-correction'>11<!-- tex4ht:ref: ch:qec  --></a>). In a standard textbook on quantum computing,
Clifford circuits and the technique for efficiently classically simulating them
would be introduced in the context of <span class='cmti-10x-x-109'>stabiliser theory</span>, a powerful collection
of tools based on group-theoretic properties of the Pauli group. These
techniques are important and ubiquitous in the quantum information
literature, and we’ll go through them in detail in Chapter <a href='main_htmlch6.html#stabiliser-theory'>6<!-- tex4ht:ref: ch:stabiliser  --></a>. However, it is
interesting to note that we also have a purely graphical bag of tricks
based on the ZX-calculus that are extremely useful for working with
Clifford circuits, and in fact already suffice to prove the Gottesman-Knill
theorem. Thus, in this chapter, we’ll deal with Clifford circuits using just the
ZX-calculus.
</p>
   <h3 class='sectionHead' id='clifford-circuits-and-clifford-zxdiagrams'><span class='titlemark'>5.1   </span> <a id='x7-1080005.1'></a>Clifford circuits and Clifford ZX-diagrams</h3>
<!-- l. 20 --><p class='noindent'>In the previous chapter, we established a close correspondence between
CNOT circuits and phase-free ZX-diagrams (see Section <a href='main_htmlch4.html#the-phasefree-zx-calculus'>4.2<!-- tex4ht:ref: sec:phase-free-zx  --></a>). Namely, we
saw that any CNOT circuit translates into a phase-free ZX-diagram,
                                                                     

                                                                     
and conversely any unitary phase-free ZX-diagram is equal to a CNOT
circuit (Theorem <a href='main_htmlch4.html#x6-94006r13'>4.2.13<!-- tex4ht:ref: thm:phase-free-is-CNOT  --></a>). In this chapter we will see that a similar
relationship exists if we generalise from only allowing the phase
<!-- l. 21 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math> to allowing phases
from the set <!-- l. 21 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo> <mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-punc' stretchy='false'>,</mo><mi>π</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>.
On one side of this correspondence, we have the following family of ZX-diagrams.
</p>
   <div class='newtheorem'>
<!-- l. 22 --><p class='noindent'><span class='head'>
<a id='x7-108001r1'></a>
<span class='cmbx-10x-x-109'>Definition 5.1.1.</span>  </span> A <span class='cmbx-10x-x-109'>Clifford ZX-diagram </span>is a ZX-diagram
where all the phases on the spiders are integer multiples of
<!-- l. 23 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>.
</p><table class='equation-star'><tr><td>
<!-- l. 24 --><object data="svgs/z-clifford-spider.svg" alt="diagram of z-clifford-spider" class="svg-diagram"></object></td></tr></table>
   </div>
<!-- l. 27 --><p class='indent'>    On the other side, we have a certain family of circuits, which generalises
CNOT circuits.
</p>
   <div class='newtheorem'>
<!-- l. 29 --><p class='noindent'><span class='head'>
<a id='x7-108002r2'></a>
<span class='cmbx-10x-x-109'>Definition 5.1.2.</span>  </span> A <span class='cmbx-10x-x-109'>Clifford circuit </span>is a circuit constructed from the
following gates: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 31 --><object data="svgs/CNOT-ZX-3.svg" alt="diagram of CNOT-ZX-3" class="svg-diagram"></object></td></tr></table>
<!-- l. 34 --><p class='indent'>   We will also refer to unitaries that can be built by composing these gates
as <span class='cmbx-10x-x-109'>Clifford unitaries</span>.
</p>
   </div>
<!-- l. 35 --><p class='indent'>    It immediately follows that any Clifford circuit yields a Clifford
ZX-diagram (as the Hadamard can be decomposed into a series of
<!-- l. 36 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
rotations, see Eq. (<a href='main_htmlch3.html#x5-67001r81'>3.81<!-- tex4ht:ref: eq:had-euler1  --></a>)). That any <span class='cmti-10x-x-109'>unitary </span>Clifford ZX-diagram can be realised
by a Clifford circuit is less obvious, and proving this will in fact be one of the
primary goals of this chapter.
</p>
   <div class='newtheorem'>
<!-- l. 37 --><p class='noindent'><span class='head'>
<a id='x7-108003r1'></a>
<span class='cmbx-10x-x-109'>Exercise 5.1.</span>
</span> A single-qubit Clifford circuit is constructed out of just Hadamard and
<!-- l. 38 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
gates. Show that any single-qubit Clifford circuit can be rewritten to the
form
</p>
<div class='center'>
<!-- l. 40 --><p class='noindent'>
</p><!-- l. 41 --><p class='noindent'><object data="svgs/1-qubit-Clifford-nf.svg" alt="diagram of 1-qubit-Clifford-nf" class="svg-diagram"></object> </p></div>
<!-- l. 44 --><p class='indent'>   for some integers <!-- l. 44 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>a</mi></math>,
<!-- l. 44 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi></math> and
<!-- l. 44 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>c</mi></math>. <span class='cmti-10x-x-109'>Hint: We know
that a single </span><!-- l. 45 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
<span class='cmti-10x-x-109'>or Hadamard can be brought to this form. So you just need to
                                                                     

                                                                     
show that when you compose this normal form with an additional</span>
<!-- l. 45 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> <span class='cmti-10x-x-109'>or
Hadamard gate that the resulting circuit also be brought to this normal
form. You probably will want to make a case distinction on the value of</span>
<!-- l. 45 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi></math><span class='cmti-10x-x-109'>.</span>
</p>
   </div>
<!-- l. 46 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 50 --><p class='noindent'><span class='head'>
<a id='x7-108004r3'></a>
<span class='cmbx-10x-x-109'>Definition 5.1.3.</span>  </span>A <span class='cmbx-10x-x-109'>Clifford state </span>is a state which can be realised as
<!-- l. 51 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
for some Clifford unitary <!-- l. 51 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>.
</p>
   </div>
<!-- l. 52 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 53 --><p class='noindent'><span class='head'>
<a id='x7-108005r2'></a>
<span class='cmbx-10x-x-109'>Exercise 5.2.</span>  </span>Show that the following states are Clifford states. I.e. construct a Clifford
circuit <!-- l. 54 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math> that
when applied to <!-- l. 54 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
gives the desired state.
   </p><dl class='enumerate'><dt class='enumerate'>
a) </dt><dd class='enumerate'>
   <!-- l. 56 --><p class='noindent'><!-- l. 56 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
   </p></dd><dt class='enumerate'>
b) </dt><dd class='enumerate'>
   <!-- l. 57 --><p class='noindent'><!-- l. 57 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext class='MathClass-rel' stretchy='false'>|+⟩</mtext></mrow></math>.
   </p></dd><dt class='enumerate'>
c) </dt><dd class='enumerate'>
   <!-- l. 58 --><p class='noindent'><!-- l. 58 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>00</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>11</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
                                                                     

                                                                     
   </p></dd><dt class='enumerate'>
d) </dt><dd class='enumerate'>
   <!-- l. 59 --><p class='noindent'><!-- l. 59 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>01</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>10</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
   </p></dd><dt class='enumerate'>
e) </dt><dd class='enumerate'>
   <!-- l. 60 --><p class='noindent'><!-- l. 60 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>000</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>111</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
   </p></dd></dl>
   </div>
<!-- l. 62 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='graphlike-diagrams'><span class='titlemark'>5.1.1   </span> <a id='x7-1090005.1.1'></a>Graph-like diagrams</h4>
<!-- l. 64 --><p class='noindent'>When dealing with phase-free diagrams it turned out to be useful to simplify our
diagrams somewhat in order to work more easily with them: we fused all the
spiders and got rid of self-loops and double edges to get diagrams that we called
<span class='cmti-10x-x-109'>two-coloured </span>(Definition <a href='main_htmlch4.html#x6-93001r3'>4.2.3<!-- tex4ht:ref: def:two-coloured  --></a>). In this chapter it will be useful to introduce a
variation on this that allows us to more easily work with Hadamards.
This type of diagram only contains Z-spiders. This can be achieved by
changing the colour of every X-spider using the Hadamard colour-change rule
<!-- l. 66 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>cc</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
We can then cancel all double Hadamards that appear by the
<!-- l. 66 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>hh</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> rule and fuse all
connected Z-spiders using <!-- l. 66 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>sp</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
In the resulting diagram all connections of spiders will then go via a
Hadamard. It will be useful to have a special name and notation for
this.
</p>
   <div class='newtheorem'>
<!-- l. 67 --><p class='noindent'><span class='head'>
<a id='x7-109001r4'></a>
<span class='cmbx-10x-x-109'>Definition 5.1.4.</span>  </span>When two spiders in a ZX-diagram are connected via a
Hadamard, we can denote this using a blue dotted line: </p><table class='equation'><tr><td>
<!-- l. 69 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 69 --><object id='x7-109002r1' data="svgs/eq-def-had-edge.svg" alt="diagram of eq:def-had-edge" class="svg-diagram"></object></td><td class='eq-no'>(5.1)</td></tr></table>
<!-- l. 72 --><p class='indent'>   We call such a connection a <span class='cmbx-10x-x-109'>Hadamard edge</span>.
</p>
   </div>
<!-- l. 73 --><p class='indent'>    Hadamard edges have a couple of useful properties. First, we only have to
deal with at most a single Hadamard edge between a pair of spiders, since any
parallel pair of Hadamard edges cancels.
</p>
   <div class='newtheorem'>
<!-- l. 76 --><p class='noindent'><span class='head'>
<a id='x7-109003r5'></a>
<span class='cmbx-10x-x-109'>Lemma 5.1.5.</span>  </span> </p><table class='equation-star'><tr><td>
<!-- l. 77 --><object data="svgs/par-edge-rem.svg" alt="diagram of par-edge-rem" class="svg-diagram"></object></td></tr></table>
   <div class='proof'>
<!-- l. 81 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span></p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 81 --><object data="svgs/double-had-edge.svg" alt="diagram of double-had-edge" class="svg-diagram"></object></td></tr></table>
                                                                   □
   </div>
   </div>
<!-- l. 85 --><p class='indent'>    Second, we can always remove a “Hadamard edge self-loop.”
</p>
   <div class='newtheorem'>
<!-- l. 87 --><p class='noindent'><span class='head'>
<a id='x7-109004r6'></a>
<span class='cmbx-10x-x-109'>Lemma 5.1.6.</span>  </span> </p><table class='equation-star'><tr><td>
<!-- l. 88 --><object data="svgs/had-edge-self-loop.svg" alt="diagram of had-edge-self-loop" class="svg-diagram"></object></td></tr></table>
   </div>
<!-- l. 91 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 93 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>This is just Eq. (<a href='main_htmlch3.html#x5-67007r83'>3.83<!-- tex4ht:ref: eq:had-self-loop-removal  --></a>).                                                         □
                                                                     

                                                                     
</p>
   </div>
<!-- l. 95 --><p class='indent'>   Now let’s give the definition of this special class of diagrams we are interested
in.
</p>
   <div class='newtheorem'>
<!-- l. 96 --><p class='noindent'><span class='head'>
<a id='x7-109005r7'></a>
<span class='cmbx-10x-x-109'>Definition 5.1.7.</span>  </span> We say a ZX-diagram is <span class='cmbx-10x-x-109'>graph-like </span>when </p>
     <ul class='itemize1'>
     <li class='itemize'>Every spider is a Z-spider.
     </li>
     <li class='itemize'>Spiders are only connected via Hadamard edges.
     </li>
     <li class='itemize'>There are no self-loops or parallel edges.
     </li>
     <li class='itemize'>Every Z-spider is connected to at most one input and at most one
     output.
     </li>
     <li class='itemize'>Every input and output wire is connected to a Z-spider. </li></ul>
   </div>
<!-- l. 105 --><p class='indent'>    Every ZX-diagram can be efficiently reduced to an equivalent graph-like
diagram.
</p>
   <div class='newtheorem'>
<!-- l. 107 --><p class='noindent'><span class='head'>
<a id='x7-109006r8'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Proposition 5.1.8.</span>  </span> Let <!-- l. 108 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math>
be an arbitrary ZX-diagram. Then the following sequence of steps reduces
<!-- l. 108 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math>
efficiently to an equivalent graph-like diagram.
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 110 --><p class='noindent'>Convert all X-spiders to Z-spiders using the <!-- l. 110 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>cc</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
     rule.
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 111 --><p class='noindent'>Cancel all pairs of adjacent Hadamards using the <!-- l. 111 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>hh</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
     rule.
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 112 --><p class='noindent'>Fuse all spiders by applying the <!-- l. 112 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>sp</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
     rule until it can no longer be applied.
     </p></dd><dt class='enumerate'>
  4.. </dt><dd class='enumerate'>
     <!-- l. 113 --><p class='noindent'>Remove parallel Hadamard edges using Lemma <a href='#x7-109003r5'>5.1.5<!-- tex4ht:ref: lem:hopf-law-h  --></a>.
     </p></dd><dt class='enumerate'>
  5.. </dt><dd class='enumerate'>
     <!-- l. 114 --><p class='noindent'>Remove self-loops using Eq. (<a href='main_htmlch3.html#x5-59006r39'>3.39<!-- tex4ht:ref: eq:self-loop-removal  --></a>), and remove Hadamard self-loops
     using Lemma <a href='#x7-109004r6'>5.1.6<!-- tex4ht:ref: lem:self-loop-H  --></a>.
     </p></dd><dt class='enumerate'>
  6.. </dt><dd class='enumerate'>
     <!-- l. 115 --><p class='noindent'>Introduce Z-spiders and Hadamards using <!-- l. 115 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>id</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
     and <!-- l. 115 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>hh</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
     in reverse, in order to ensure every input and output is directly connected
     to a Z-spider and no Z-spiders are connected to multiple inputs/outputs.
     </p></dd></dl>
   </div>
<!-- l. 117 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 119 --><p class='indent'>   <span class='head'>
                                                                     

                                                                     
<span class='cmti-10x-x-109'>Proof.</span> </span>It is clear that after this procedure there are only Z-spiders, as all
X-spiders have been converted. Every connection between spiders must be via a
Hadamard edge, since if it were a regular connection, then the spiders would have
been fused in step 3, and if there were multiple Hadamards on the connection,
then pairs of them would be cancelled in step 2. There is at most one Hadamard
edge between each pair of spiders because of step 4, and there are no
self-loops because of step 5. It could now still be that we have input/output
wires that are connected via a Hadamard to a Z-spider, or wires that are
not connected to a spider at all. We take care of these cases as follows:
</p><table class='equation-star'><tr><td>
<!-- l. 120 --><object data="svgs/ident-graph-form-2.svg" alt="diagram of ident-graph-form-2" class="svg-diagram"></object></td></tr></table>
<!-- l. 123 --><p class='indent'>   Similarly, if a Z-spider is connected to multiple inputs or outputs, we
can introduce an extra Z spider and a pair of Hadamards to fix it up:
</p><table class='equation-star'><tr><td>
<!-- l. 124 --><object data="svgs/graph-like-multi-io.svg" alt="diagram of graph-like-multi-io" class="svg-diagram"></object></td></tr></table>
<!-- l. 127 --><p class='indent'>   Each of the steps of this algorithm touches each vertex or edge at most
once, and hence this is all efficient in the size of the diagram.                 □
</p>
   </div>
   <div class='newtheorem'>
                                                                     

                                                                     
<!-- l. 129 --><p class='noindent'><span class='head'>
<a id='x7-109013r9'></a>
<span class='cmbx-10x-x-109'>Example 5.1.9.</span>  </span>  We   demonstrate   how   an   example   ZX-diagram   is
transformed into a graph-like diagram below. In the last step we write down
its underlying graph.
</p>
<div class='center'>
<!-- l. 132 --><p class='noindent'>
</p><!-- l. 133 --><p class='noindent'><object data="svgs/graph-like-ex-nolabel.svg" alt="diagram of graph-like-ex-nolabel" class="svg-diagram"></object> </p></div>
   </div>
<!-- l. 136 --><p class='indent'>    The reason we call these diagrams graph-like is because they are
neatly described by a structure that we call an <span class='cmti-10x-x-109'>open graph</span>, a graph with a
specified list of inputs and outputs. We will have more to say about open
graphs in Chapter <a href='main_htmlch8.html#measurementbased-quantum-computation'>8<!-- tex4ht:ref: ch:mbqc  --></a>. For now, let’s just note that we can view each
spider in a graph-like diagram as a vertex, and every Hadamard as an
edge.
</p>
   <div class='newtheorem'>
<!-- l. 138 --><p class='noindent'><span class='head'>
<a id='x7-109014r3'></a>
<span class='cmbx-10x-x-109'>Exercise 5.3.</span>  </span> 
   </p><dl class='enumerate'><dt class='enumerate'>
a) </dt><dd class='enumerate'>
   <!-- l. 140 --><p class='noindent'>Show that every two-coloured diagram (see Definition <a href='main_htmlch4.html#x6-93001r3'>4.2.3<!-- tex4ht:ref: def:two-coloured  --></a>) is transformed
   into a graph-like diagram by changing all the X-spiders into Z-spiders
   using <!-- l. 140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>cc</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
   and then potentially introducing some more identities with <!-- l. 140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>id</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
   and <!-- l. 140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>hh</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
   to the input and output wires.
   </p></dd><dt class='enumerate'>
b) </dt><dd class='enumerate'>
   <!-- l. 141 --><p class='noindent'>Show that the converse is not true: find a graph-like ZX-diagram where
   it is not possible to rewrite it back into a two-coloured diagram using just
   <!-- l. 141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>cc</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
                                                                     

                                                                     
   </p></dd><dt class='enumerate'>
c) </dt><dd class='enumerate'>
   <!-- l. 142 --><p class='noindent'>Find a systematic way in which a graph-like diagram can be transformed
   into a two-coloured diagram. </p></dd></dl>
   </div>
<!-- l. 144 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='graph-states'><span class='titlemark'>5.1.2   </span> <a id='x7-1100005.1.2'></a>Graph states</h4>
<!-- l. 146 --><p class='noindent'>A particularly useful subset of graph-like diagrams are the <span class='cmti-10x-x-109'>graph states</span>. We can
either describe these diagrammatically as a restricted set of graph-like
diagrams, or directly as a type of quantum state. We will give the
description as a quantum state first. For each simple undirected graph
<!-- l. 147 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>G</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>V</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>E</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>, where
<!-- l. 147 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math> denotes the set of
vertices of the graph, and <!-- l. 147 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>
the set of edges, we can define its corresponding graph state
<!-- l. 147 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>G</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
as
<!-- tex4ht:inline --></p><!-- l. 148 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                    <mo class='MathClass-rel' stretchy='false'>|</mo><mi>G</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo><munder class='msub'><mrow><mo> ∏</mo>
  </mrow><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>v</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>w</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>∈</mo><mi>E</mi></mrow></munder><msub><mrow><mstyle class='text'><mtext>CZ</mtext></mstyle></mrow><mrow><mi>v</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>w</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>+</mo><msup><mrow><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow><mrow><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>V</mi> <mo class='MathClass-rel' stretchy='false'>|</mo></mrow></msup><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math>
<!-- l. 148 --><p class='nopar'> I.e. we prepare the <!-- l. 149 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext class='MathClass-rel' stretchy='false'>|+⋯+⟩</mtext></mrow></math>
state, where the number of qubits is equal to the number of vertices in the graph, and then
for every edge in <!-- l. 149 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>
we apply a CZ gate between the corresponding qubits (recall the CZ from Exercise <a href='main_htmlch2.html#x4-27001r13'>2.13<!-- tex4ht:ref: exer:CZ-as-CNOT  --></a>).
A <!-- l. 150 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext class='MathClass-rel' stretchy='false'>|+⟩</mtext></mrow></math>
state as a ZX-diagram is just a phase-free Z-spider with a single output. A CZ
gate is a pair of Z-spiders connected via a Hadamard gate:
</p>
                                                                     

                                                                     
<div class='center'>
<!-- l. 152 --><p class='noindent'>
</p><!-- l. 153 --><p class='noindent'><object data="svgs/CZ.svg" alt="diagram of CZ" class="svg-diagram"></object> </p></div>
<!-- l. 156 --><p class='indent'>   To go from a graph to a graph state represented as a ZX-diagram is then
straightforward: </p><table class='equation'><tr><td>
<!-- l. 157 --><p class='indent'>
</p><!-- l. 157 --><object id='x7-110001r2' data="svgs/eq-graph-state-ex.svg" alt="diagram of eq:graph-state-ex" class="svg-diagram"></object></td><td class='eq-no'>(5.2)</td></tr></table>
<!-- l. 160 --><p class='indent'>   Here we get the diagram on the right by simply fusing all the spiders
together. To go from a graph to the graph state represented as a ZX-diagram we
see then that every vertex becomes a phase-free Z-spider with an output attached
to it and each edge in the graph becomes a Hadamard edge between the
corresponding spiders. With this description in hand we can also define a graph
state as a particular type of graph-like diagram (spend some time convincing
yourself that this definition is indeed equivalent to the description given
above):
</p>
   <div class='newtheorem'>
<!-- l. 163 --><p class='noindent'><span class='head'>
<a id='x7-110002r10'></a>
<span class='cmbx-10x-x-109'>Definition 5.1.10.</span>  </span>A graph-like diagram is a <span class='cmbx-10x-x-109'>graph state </span>when </p>
     <ul class='itemize1'>
     <li class='itemize'>it has no inputs,
     </li>
     <li class='itemize'>every spider is connected to an output,
                                                                     

                                                                     
     </li>
     <li class='itemize'>and all phases are zero. </li></ul>
   </div>
<!-- l. 170 --><p class='indent'>    Some useful quantum states are not exactly graph states, but are instead
merely <span class='cmti-10x-x-109'>very close </span>to being a graph state. For instance, the GHZ-state
(cf. (<a href='main_htmlch3.html#x5-59008r40'>3.40<!-- tex4ht:ref: eq:ghz-circuit-zx  --></a>)), is not a graph state, but we can construct it by starting with a graph
state and then applying some Hadamard gates on a couple of the qubits:
</p><table class='equation'><tr><td>
<!-- l. 173 --><p class='indent'>
</p><!-- l. 173 --><object id='x7-110003r3' data="svgs/eq-ghz-to-graph-state.svg" alt="diagram of eq:ghz-to-graph-state" class="svg-diagram"></object></td><td class='eq-no'>(5.3)</td></tr></table>
<!-- l. 176 --><p class='indent'>   In the context of graph states, we refer to the application of single-qubit
unitaries on some of its outputs as <span class='cmbx-10x-x-109'>local </span>unitaries. Imagine for instance some
quantum protocol where we start with a bunch of qubits in one spot, which are
then entangled to make a graph state. We then give each of the qubits of this
graph state to a different person, who are then allowed to take their qubit very
far away from the others. While each of these people can’t change the
graph state by applying some operation on multiple qubits at once, they
can still modify the qubit they have access to by applying a unitary on
just that qubit. Hence why we refer to single-qubit operations as ‘local’.
Note furthermore that the operation we had to apply in the case of the
GHZ state was not just any unitary but specifically a Clifford unitary.
This leads us to our next definition of a useful subclass of states and
ZX-diagrams.
</p>
   <div class='newtheorem'>
<!-- l. 182 --><p class='noindent'><span class='head'>
<a id='x7-110004r11'></a>
<span class='cmbx-10x-x-109'>Definition 5.1.11.</span>  </span> A <span class='cmbx-10x-x-109'>graph state with local Cliffords </span>(GSLC) is a
graph state to which some single-qubit Clifford unitaries have been applied
on its outputs.
                                                                     

                                                                     
</p>
   </div>
<!-- l. 184 --><p class='indent'>    We will often say a ZX-diagram is in <span class='cmbx-10x-x-109'>GSLC form </span>or (at the risk of sounding
like the kind of people that say “ATM machine”) that a quantum state is
a <span class='cmbx-10x-x-109'>GSLC state</span>. Every single-qubit Clifford unitary can be written as
a composition of three phase gates where the phases are multiples of
<!-- l. 186 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math> (cf. Exercise <a href='#x7-108003r1'>5.1<!-- tex4ht:ref: exer:1-qubit-Clifford-nf  --></a>).
So an example of a GSLC state would be a composition of the graph state of (<a href='#x7-110001r2'>5.2<!-- tex4ht:ref: eq:graph-state-ex  --></a>)
with any <!-- l. 187 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
or <!-- l. 187 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi><mo class='MathClass-open' stretchy='false'>(</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
phase gates:
</p>
<div class='center'>
<!-- l. 189 --><p class='noindent'>
</p><!-- l. 190 --><p class='noindent'><object data="svgs/graph-state-local-clifford.svg" alt="diagram of graph-state-local-clifford" class="svg-diagram"></object> </p></div>
<!-- l. 193 --><p class='indent'>   Where here the Hadamard gate on the top qubit is a number of
<!-- l. 193 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math> phase
gates in disguise.
</p>
   <div class='newtheorem'>
<!-- l. 194 --><p class='noindent'><span class='head'>
<a id='x7-110005r4'></a>
<span class='cmbx-10x-x-109'>Exercise 5.4.</span>  </span>Show that the graph state (<a href='#x7-110001r2'>5.2<!-- tex4ht:ref: eq:graph-state-ex  --></a>) is a Clifford state by finding
a Clifford circuit that builds it when applied to <!-- l. 195 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
</p>
   </div>
<!-- l. 196 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 197 --><p class='noindent'><span class='head'>
<a id='x7-110006r5'></a>
<span class='cmbx-10x-x-109'>Exercise 5.5.</span>  </span>  A  graph  state  has  no  internal  spiders,  but  a  general
graph-like diagram does. Show that any graph-like diagram with no inputs
(i.e. a state) can be written as a graph-state where each internal spider
becomes a post-selection by adapting the arguments from Section <a href='main_htmlch3.html#zxdiagrams-to-circuits-with-postselection'>3.4.1<!-- tex4ht:ref: sec:circ-to-zx-postselect  --></a>.
                                                                     

                                                                     
</p>
   </div>
<!-- l. 199 --><p class='indent'>
</p>
   <h3 class='sectionHead' id='simplifying-clifford-diagrams'><span class='titlemark'>5.2   </span> <a id='x7-1110005.2'></a>Simplifying Clifford diagrams</h3>
<!-- l. 201 --><p class='noindent'>Now that we have all the tools we need, we will see how we can systematically
simplify Clifford diagrams. Instead of rewriting arbitrary diagrams, we will work
with graph-like diagrams. Thanks to Proposition <a href='#x7-109006r8'>5.1.8<!-- tex4ht:ref: prop:to-graph-like  --></a>, we can translate any
ZX-diagram into a graph-like one, so we can do this without loss of generality.
Because graph-like ZX-diagrams are pretty much just graphs with a bit of extra
stuff, we can use some techniques from graph theory to simplify them. Before we
do this in the general case, it pays to first look at the special case of GSLC
states.
</p>
   <h4 class='subsectionHead' id='transforming-graph-states-using-local-complementation'><span class='titlemark'>5.2.1   </span> <a id='x7-1120005.2.1'></a>Transforming graph states using local complementation</h4>
<!-- l. 205 --><p class='noindent'>When looking at a graph state it might seem at first glance that the presence or
absence of an edge between two qubits determines whether those qubits are
entangled. Considering again the scenario where we have prepared a graph state
and sent each of the qubits far away from each other. This might then seem to
mean that there is no way in which we can get any more entanglement between
these qubits. However, the structure of entanglement in a graph state can be
deceiving. It turns out that just applying local Cliffords can greatly affect the
connectivity of the underlying graph. For instance, in Eq. (<a href='#x7-110003r3'>5.3<!-- tex4ht:ref: eq:ghz-to-graph-state  --></a>) we saw
that we can represent a GHZ state as a graph state with some local
Cliffords. Because the GHZ is of course symmetric in all three qubits, that
means we can do this in three equivalent ways, and hence the following
graph states are all equal up to the application of some local Cliffords:
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 209 --><object data="svgs/GHZ-graph-forms.svg" alt="diagram of GHZ-graph-forms" class="svg-diagram"></object></td></tr></table>
<!-- l. 212 --><p class='indent'>   A natural question is then how we can find out when two graph states can be
transformed into each other just using local Clifford operations. One important
graph transformation we can do just by using local operations is the <span class='cmti-10x-x-109'>local
complementation</span>.
</p>
   <div class='newtheorem'>
<!-- l. 214 --><p class='noindent'><span class='head'>
<a id='x7-112001r1'></a>
<span class='cmbx-10x-x-109'>Definition 5.2.1.</span>  </span>Let <!-- l. 215 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>
be a graph, and <!-- l. 215 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math>
a vertex in <!-- l. 215 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>.
The <span class='cmbx-10x-x-109'>local complementation of </span><!-- l. 215 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>
<span class='cmbx-10x-x-109'>about </span><!-- l. 215 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math>,
which we write as <!-- l. 215 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>G</mi> <mo class='MathClass-bin' stretchy='false'>⋆</mo> <mi>u</mi></mrow></math>,
is the graph which has the same vertices and edges as <!-- l. 215 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>,
except that the neighbourhood of <!-- l. 215 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math>
is complemented. In other words, two neighbours <!-- l. 215 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math>
and <!-- l. 215 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>w</mi></math>
of <!-- l. 215 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math>
are connected in <!-- l. 215 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>G</mi> <mo class='MathClass-bin' stretchy='false'>⋆</mo> <mi>u</mi></mrow></math>
if and only if they are <span class='cmti-10x-x-109'>not </span>connected in <!-- l. 215 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>.
</p>
   </div>
<!-- l. 216 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 217 --><p class='noindent'><span class='head'>
<a id='x7-112002r2'></a>
<span class='cmbx-10x-x-109'>Example 5.2.2.</span>  </span> Consider the graph
<!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math> below with
vertices <!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>b</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>c</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>d</mi></mrow></math>. In
<!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>G</mi> <mo class='MathClass-bin' stretchy='false'>⋆</mo> <mi>a</mi></mrow></math> we see that the
neighbourhood of <!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>a</mi></math>,
                                                                     

                                                                     
consisting of the vertices <!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>b</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>c</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>d</mi></mrow></math> is
complemented. So because <!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi></math>
and <!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>c</mi></math> are not
connected in <!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>, they
are connected in <!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>G</mi> <mo class='MathClass-bin' stretchy='false'>⋆</mo> <mi>a</mi></mrow></math>,
and because <!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi></math> and
<!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math> <span class='cmti-10x-x-109'>are </span>connected
in <!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>, they are
not in <!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>G</mi> <mo class='MathClass-bin' stretchy='false'>⋆</mo> <mi>a</mi></mrow></math>. In
<!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>G</mi> <mo class='MathClass-bin' stretchy='false'>⋆</mo> <mi>a</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>⋆</mo> <mi>b</mi></mrow></math> we see that the
connection between <!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>c</mi></math>
and <!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math> is not
affected, as <!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math> is not
a neighbour of <!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi></math>.
</p><table class='equation-star'><tr><td>
<!-- l. 219 --><object data="svgs/graph1-lab.svg" alt="diagram of graph1-lab" class="svg-diagram"></object></td></tr></table>
   </div>
<!-- l. 222 --><p class='indent'>    To transform a graph state so that its underlying
graph is locally complemented about a vertex (i.e. qubit)
<!-- l. 223 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math>, we only need
to apply a <!-- l. 223 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
gate on <!-- l. 223 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math>,
and a <!-- l. 223 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
gate on each of its neighbours: </p><table class='equation'><tr><td>
<!-- l. 224 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 224 --><object id='x7-112003r4' data="svgs/eq-local-comp-zx.svg" alt="diagram of eq:local-comp-zx" class="svg-diagram"></object></td><td class='eq-no'>(5.4)</td></tr></table>
<!-- l. 227 --><p class='indent'>   Here <!-- l. 227 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>N</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> denotes the
neighbourhood of <!-- l. 227 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math>.
In the remainder of this section we will prove that (<a href='#x7-112003r4'>5.4<!-- tex4ht:ref: eq:local-comp-zx  --></a>) indeed holds.
To do this it will be helpful to introduce the family of fully connected
ZX-diagrams.
</p>
   <div class='newtheorem'>
<!-- l. 230 --><p class='noindent'><span class='head'>
<a id='x7-112004r3'></a>
<span class='cmbx-10x-x-109'>Definition 5.2.3.</span>  </span>We define <!-- l. 231 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>K</mi></mrow><mrow><mi>n</mi></mrow></msub></math>
to be the <span class='cmbx-10x-x-109'>fully connected ZX-diagram </span>on
<!-- l. 231 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
qubits, defined recursively as: </p><table class='equation'><tr><td>
<!-- l. 232 --><p class='indent'>
</p><!-- l. 232 --><object id='x7-112005r5' data="svgs/eq-fully-connected-def.svg" alt="diagram of eq:fully-connected-def" class="svg-diagram"></object></td><td class='eq-no'>(5.5)</td></tr></table>
   </div>
<!-- l. 235 --><p class='indent'>    When we fuse all the spiders in <!-- l. 236 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>K</mi></mrow><mrow><mi>n</mi></mrow></msub></math>
we see that they indeed give totally-connected graphs of Hadamard edges:
</p>
<div class='center'>
<!-- l. 238 --><p class='noindent'>
</p><!-- l. 239 --><p class='noindent'><object data="svgs/fully-connected-ex.svg" alt="diagram of fully-connected-ex" class="svg-diagram"></object> </p></div>
                                                                     

                                                                     
<!-- l. 242 --><p class='indent'>   Using this definition of <!-- l. 242 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>K</mi></mrow><mrow><mi>n</mi></mrow></msub></math>
we can state the equality that will allow us to do local complementations:
</p>
   <div class='newtheorem'>
<!-- l. 243 --><p class='noindent'><span class='head'>
<a id='x7-112006r4'></a>
<span class='cmbx-10x-x-109'>Lemma 5.2.4.</span>  </span> The following holds in the ZX-calculus for all
<!-- l. 244 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℕ</mi></mrow></math>:
</p><table class='equation'><tr><td>
<!-- l. 245 --><p class='indent'>
</p><!-- l. 245 --><object id='x7-112007r6' data="svgs/eq-lc-zx.svg" alt="diagram of eq:lc-zx" class="svg-diagram"></object></td><td class='eq-no'>(5.6)</td></tr></table>
   </div>
<!-- l. 248 --><p class='indent'>    Before we prove this, see Example <a href='#x7-112008r5'>5.2.5<!-- tex4ht:ref: ex:local-complementation-zx  --></a> for a demonstration of how this is
related to doing local complementations. The crucial point is that the
introduction of a fully connected graph by Eq. (<a href='#x7-112007r6'>5.6<!-- tex4ht:ref: eq:lc-zx  --></a>) makes a parallel Hadamard
edge if there was already a Hadamard edge present, which is then subsequently
removed by Lemma <a href='#x7-109003r5'>5.1.5<!-- tex4ht:ref: lem:hopf-law-h  --></a>.
</p>
   <div class='newtheorem'>
<!-- l. 250 --><p class='noindent'><span class='head'>
<a id='x7-112008r5'></a>
<span class='cmbx-10x-x-109'>Example 5.2.5.</span>  </span> Let us take the graph <!-- l. 251 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>
from Example <a href='#x7-112002r2'>5.2.2<!-- tex4ht:ref: ex:local-complementation  --></a>, but now seen as the graph state <!-- l. 251 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>G</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
</p>
<div class='center'>
<!-- l. 253 --><p class='noindent'>
</p><!-- l. 254 --><p class='noindent'><object data="svgs/graph1-lab-zx.svg" alt="diagram of graph1-lab-zx" class="svg-diagram"></object> </p></div>
                                                                     

                                                                     
<!-- l. 257 --><p class='indent'>   We indeed end up with <!-- l. 257 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>G</mi> <mo class='MathClass-bin' stretchy='false'>⋆</mo> <mi>a</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
(up to local Cliffords).
</p>
   </div>
<!-- l. 258 --><p class='indent'>    For the proof of Lemma <a href='#x7-112006r4'>5.2.4<!-- tex4ht:ref: lem:loc-comp-zx  --></a> we will need the following base case.
</p>
   <div class='newtheorem'>
<!-- l. 260 --><p class='noindent'><span class='head'>
<a id='x7-112009r6'></a>
<span class='cmbx-10x-x-109'>Exercise 5.6.</span>  </span> Prove the following using the ZX-calculus. </p><table class='equation'><tr><td>
<!-- l. 262 --><p class='indent'>
</p><!-- l. 262 --><object id='x7-112010r7' data="svgs/eq-local-comp2.svg" alt="diagram of eq:local-comp2" class="svg-diagram"></object></td><td class='eq-no'>(5.7)</td></tr></table>
<!-- l. 265 --><p class='noindent'><span class='cmti-10x-x-109'>Hint: Push the rightmost Hadamards to the right and decompose the middle
Hadamard using one of the versions of the Euler decomposition from
Exercise </span><a href='main_htmlch3.html#x5-67003r12'><span class='cmti-10x-x-109'>3.12</span><!-- tex4ht:ref: exer:had-euler  --></a> <span class='cmti-10x-x-109'>to reveal a place where you can apply strong complementarity.</span>
</p>
   </div>
<!-- l. 266 --><p class='indent'>     And now we can prove the general case.
</p>
   <div class='proof'>
<!-- l. 278 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof of Lemma </span><a href='#x7-112006r4'><span class='cmti-10x-x-109'>5.2.4</span><!-- tex4ht:ref: lem:loc-comp-zx  --></a><span class='cmti-10x-x-109'>.</span> </span>                Note                 that                 for
<!-- l. 279 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>
and
<!-- l. 279 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
this equation becomes:
</p>
                                                                     

                                                                     
<div class='center'>
<!-- l. 281 --><p class='noindent'>
</p><!-- l. 282 --><p class='noindent'><object data="svgs/LC-zx-pf0.svg" alt="diagram of LC-zx-pf0" class="svg-diagram"></object> </p></div>
<!-- l. 285 --><p class='indent'>   Exercise <a href='#x7-112009r6'>5.6<!-- tex4ht:ref: exer:local-comp-base  --></a> shows <!-- l. 285 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>2</mn></mrow></math>.
We prove the other cases by induction. For our induction hypothesis, assume (<a href='#x7-112007r6'>5.6<!-- tex4ht:ref: eq:lc-zx  --></a>) holds for some
fixed <!-- l. 287 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>2</mn></mrow></math>, which we indicate
as (ih) below. Then, for <!-- l. 287 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn></mrow></math>
we calculate: </p><table class='equation-star'><tr><td>
<!-- l. 288 --><object data="svgs/LC-zx-pf1.svg" alt="diagram of LC-zx-pf1" class="svg-diagram"></object></td></tr></table>
   <table class='equation-star'><tr><td>
<!-- l. 291 --><object data="svgs/LC-zx-pf2.svg" alt="diagram of LC-zx-pf2" class="svg-diagram"></object></td></tr></table>
   <table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 294 --><object data="svgs/LC-zx-pf3.svg" alt="diagram of LC-zx-pf3" class="svg-diagram"></object></td></tr></table>
   <table class='equation-star'><tr><td>
<!-- l. 297 --><object data="svgs/LC-zx-pf4.svg" alt="diagram of LC-zx-pf4" class="svg-diagram"></object></td></tr></table>
                                                                   □
   </div>
   <div class='newtheorem'>
<!-- l. 301 --><p class='noindent'><span class='head'>
<a id='x7-112011r7'></a>
<span class='cmbx-10x-x-109'>Exercise 5.7.</span>  </span>We say two <!-- l. 302 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
quantum states <!-- l. 302 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ψ</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
and <!-- l. 302 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ψ</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
are <span class='cmbx-10x-x-109'>equivalent under local operations </span>when
<!-- l. 302 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ψ</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ψ</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> for a local
quantum circuit <!-- l. 302 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>U</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <msub><mrow><mi>U</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <msub><mrow><mi>U</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></math>
consisting of just single-qubit gates. Show that the following two graph states are
equivalent under local operations. </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 304 --><object data="svgs/graph-state-star.svg" alt="diagram of graph-state-star" class="svg-diagram"></object></td></tr></table>
<!-- l. 307 --><p class='noindent'><span class='cmti-10x-x-109'>Hint: Use the fact that a local complementation can be done using just local
unitaries.</span>
</p>
   </div>
<!-- l. 308 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='pivoting'><span class='titlemark'>5.2.2   </span> <a id='x7-1130005.2.2'></a>Pivoting</h4>
<!-- l. 310 --><p class='noindent'>It turns out that it is often useful to not just do a single local complementation,
but to do a particular sequence on a pair of connected vertices.
</p>
   <div class='newtheorem'>
<!-- l. 311 --><p class='noindent'><span class='head'>
<a id='x7-113001r6'></a>
<span class='cmbx-10x-x-109'>Definition 5.2.6.</span>  </span>Let <!-- l. 312 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>
be a graph and let <!-- l. 312 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math>
and <!-- l. 312 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math>
be a pair of connected vertices in <!-- l. 312 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>.
We define the <span class='cmbx-10x-x-109'>pivot of </span><!-- l. 312 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>
<span class='cmbx-10x-x-109'>along </span><!-- l. 312 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>uv</mi></mrow></math>,
written as <!-- l. 312 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>G</mi> <mo class='MathClass-bin' stretchy='false'>∧</mo> <mi mathvariant='italic'>uv</mi></mrow></math>,
as the graph <!-- l. 312 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>G</mi> <mo class='MathClass-bin' stretchy='false'>⋆</mo> <mi>u</mi> <mo class='MathClass-bin' stretchy='false'>⋆</mo> <mi>v</mi> <mo class='MathClass-bin' stretchy='false'>⋆</mo> <mi>u</mi></mrow></math>.
</p>
   </div>
<!-- l. 313 --><p class='indent'>    Note that in this definition, the ordering of
<!-- l. 314 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math> and
<!-- l. 314 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math> does
not matter.
</p>
   <div class='newtheorem'>
<!-- l. 315 --><p class='noindent'><span class='head'>
<a id='x7-113002r8'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Exercise 5.8.</span>  </span>Show that for any graph <!-- l. 316 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>
and connected pair of vertices <!-- l. 316 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math>
and <!-- l. 316 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math>
in <!-- l. 316 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>
we have <!-- l. 316 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>G</mi> <mo class='MathClass-bin' stretchy='false'>⋆</mo> <mi>u</mi> <mo class='MathClass-bin' stretchy='false'>⋆</mo> <mi>v</mi> <mo class='MathClass-bin' stretchy='false'>⋆</mo> <mi>u</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>G</mi> <mo class='MathClass-bin' stretchy='false'>⋆</mo> <mi>v</mi> <mo class='MathClass-bin' stretchy='false'>⋆</mo> <mi>u</mi> <mo class='MathClass-bin' stretchy='false'>⋆</mo> <mi>v</mi></mrow></math>.
</p>
   </div>
<!-- l. 317 --><p class='indent'>    On a graph, pivoting consists in exchanging
<!-- l. 318 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math> and
<!-- l. 318 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math>, and
complementing the edges between three particular subsets of the vertices: the common
neighbourhood of <!-- l. 319 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math>
and <!-- l. 319 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math>
(i.e. <!-- l. 319 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>N</mi></mrow><mrow><mi>G</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>∩</mo> <msub><mrow><mi>N</mi></mrow><mrow><mi>G</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>v</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>), the exclusive
neighbourhood of <!-- l. 319 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math>
(i.e. <!-- l. 319 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>N</mi></mrow><mrow><mi>G</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>∖</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>N</mi></mrow><mrow><mi>G</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>v</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>∪</mo><mo class='MathClass-open' stretchy='false'>{</mo><mi>v</mi><mo class='MathClass-close' stretchy='false'>}</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>), and exclusive
neighbourhood of <!-- l. 319 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math>
(i.e. <!-- l. 319 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>N</mi></mrow><mrow><mi>G</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>v</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>∖</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>N</mi></mrow><mrow><mi>G</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>∪</mo><mo class='MathClass-open' stretchy='false'>{</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>}</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>).
Schematically: </p><table class='equation-star'><tr><td>
<!-- l. 320 --><object data="svgs/pivot-L.svg" alt="diagram of pivot-L" class="svg-diagram"></object></td></tr></table>
<!-- l. 323 --><p class='indent'>   As a pivot is just a series of local complementations, it can also be performed
on a graph state by the application of a particular set of local Cliffords. Indeed,
in terms of ZX-diagrams, we have: </p><table class='equation'><tr><td>
<!-- l. 324 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 324 --><object id='x7-113003r8' data="svgs/eq-pivot-zx.svg" alt="diagram of eq:pivot-zx" class="svg-diagram"></object></td><td class='eq-no'>(5.8)</td></tr></table>
<!-- l. 327 --><p class='indent'>   I.e. we can perform a pivot on the graph state by applying a Hadamard to
the vertices we pivot along, and applying a Z gate to the vertices in their
common neighbourhood.
</p>
   <div class='newtheorem'>
<!-- l. 328 --><p class='noindent'><span class='head'>
<a id='x7-113004r9'></a>
<span class='cmbx-10x-x-109'>Exercise 5.9.</span>  </span>Prove  Eq. (<a href='#x7-113003r8'>5.8<!-- tex4ht:ref: eq:pivot-zx  --></a>)  by  decomposing  the  Hadamards  into
sequences                                                                                    of
<!-- l. 329 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
phase gates and then applying a sequence of local complementations using
Eq. (<a href='#x7-112003r4'>5.4<!-- tex4ht:ref: eq:local-comp-zx  --></a>).
</p>
   </div>
<!-- l. 330 --><p class='indent'>    It turns out we can prove (<a href='#x7-113003r8'>5.8<!-- tex4ht:ref: eq:pivot-zx  --></a>) more directly by using strong
complementarity.
</p>
   <div class='newtheorem'>
<!-- l. 332 --><p class='noindent'><span class='head'>
<a id='x7-113005r7'></a>
<span class='cmbx-10x-x-109'>Lemma 5.2.7.</span>  </span> Eq. (<a href='#x7-113003r8'>5.8<!-- tex4ht:ref: eq:pivot-zx  --></a>) holds in the ZX-calculus.
</p>
   </div>
<!-- l. 334 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 336 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>For clarity, let us first assume that the set of vertices connected to both
<!-- l. 336 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math> and
<!-- l. 336 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math> is
empty. </p><table class='equation'><tr><td>
                                                                     

                                                                     
<!-- l. 337 --><p class='indent'>
</p><!-- l. 337 --><object id='x7-113006r9' data="svgs/eq-pivot-desc-pf1.svg" alt="diagram of eq:pivot-desc-pf1" class="svg-diagram"></object></td><td class='eq-no'>(5.9)</td></tr></table>
   <table class='equation-star'><tr><td>
<!-- l. 340 --><object data="svgs/pivot-desc-pf2.svg" alt="diagram of pivot-desc-pf2" class="svg-diagram"></object></td></tr></table>
<!-- l. 343 --><p class='indent'>   We see that <!-- l. 343 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math> ends up
connected to whatever <!-- l. 343 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math>
was connected to and vice versa, and that the neighbourhoods of
<!-- l. 343 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math> and
<!-- l. 343 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math> are now
fully connected, so that if there were connections they will get complemented in the
same way as described in Example <a href='#x7-112008r5'>5.2.5<!-- tex4ht:ref: ex:local-complementation-zx  --></a>. Now, if there are spiders that are connected
to both <!-- l. 344 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math>
and <!-- l. 344 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math>,
then we can unfuse spiders in a clever way to reduce it to the previous
case:
</p>
<div class='center'>
<!-- l. 346 --><p class='noindent'>
</p><!-- l. 347 --><p class='noindent'><object data="svgs/pivot-desc-pf1-prime.svg" alt="diagram of pivot-desc-pf1-prime" class="svg-diagram"></object> </p></div>
                                                                     

                                                                     
<div class='center'>
<!-- l. 351 --><p class='noindent'>
</p><!-- l. 352 --><p class='noindent'><object data="svgs/pivot-desc-pf2-prime.svg" alt="diagram of pivot-desc-pf2-prime" class="svg-diagram"></object> </p></div>
<!-- l. 355 --><p class='indent'>   For clarity we have only drawn the Hadamard edges that stay within the joint
neighbourhood of <!-- l. 355 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math>
and <!-- l. 355 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math> in
the bottom two diagrams. We see that we end up with parallel Hadamard edges
that can be removed using Lemma <a href='#x7-109003r5'>5.1.5<!-- tex4ht:ref: lem:hopf-law-h  --></a>. The Hadamard self-loops are simplified
to <!-- l. 355 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>π</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
phases using Lemma <a href='#x7-109004r6'>5.1.6<!-- tex4ht:ref: lem:self-loop-H  --></a>, which indeed gives the expected result.         □
</p>
   </div>
<!-- l. 357 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='removing-spiders-in-clifford-diagrams'><span class='titlemark'>5.2.3   </span> <a id='x7-1140005.2.3'></a>Removing spiders in Clifford diagrams</h4>
<!-- l. 358 --><p class='noindent'>In Sections <a href='#transforming-graph-states-using-local-complementation'>5.2.1<!-- tex4ht:ref: sec:lcomp  --></a> and <a href='#pivoting'>5.2.2<!-- tex4ht:ref: sec:pivoting  --></a> we saw that we can apply the graph operations of
local complementation and pivoting on graph states by introducing some
local Cliffords. It turns out that we can use some variations on these
rules to greatly simplify graph-like diagrams. As this chapter deals with
Clifford diagrams, we will focus here on the variations that are useful to
simplify these diagrams, but later on we will introduce some additional
variations that can also simplify generic graph-like diagrams. The rules we
introduce in this section all serve to remove one or more spiders from a
Clifford diagram. By repeatedly applying these rules we then get smaller
and smaller diagrams until there are no longer any spiders to remove
using these rules. For these rewrite rules it will be useful to introduce a
distinction between two classes of spiders in graph-like diagrams (see also
Definition <a href='main_htmlch4.html#x6-93007r5'>4.2.5<!-- tex4ht:ref: def:input-output-spider  --></a>).
</p>
   <div class='newtheorem'>
<!-- l. 362 --><p class='noindent'><span class='head'>
<a id='x7-114001r8'></a>
<span class='cmbx-10x-x-109'>Definition 5.2.8.</span>  </span>Let
<!-- l. 363 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math>
be      a      graph-like      diagram.      We      say      a      spider      in
<!-- l. 363 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math>
is <span class='cmbx-10x-x-109'>internal </span>if it is not an input or output spider (i.e. it is not connected
to any input or output wire). Conversely, we say a spider is a <span class='cmbx-10x-x-109'>boundary</span>
                                                                     

                                                                     
spider when it <span class='cmti-10x-x-109'>is </span>connected to at least one input or output wire.
</p>
   </div>
<!-- l. 364 --><p class='indent'>    Our first simplification rule is based on the local complementation
rule (<a href='#x7-112007r6'>5.6<!-- tex4ht:ref: eq:lc-zx  --></a>).
</p>
   <div class='newtheorem'>
<!-- l. 366 --><p class='noindent'><span class='head'>
<a id='x7-114002r9'></a>
<span class='cmbx-10x-x-109'>Lemma 5.2.9.</span>  </span> The following local complementation simplification hold:
</p><table class='equation'><tr><td>
<!-- l. 368 --><p class='indent'>
</p><!-- l. 368 --><object id='x7-114003r10' data="svgs/lc-simp.svg" alt="diagram of lc-simp" class="svg-diagram"></object></td><td class='eq-no'>(5.10)</td></tr></table>
   </div>
<!-- l. 371 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 373 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>We pull out all of the phases via <!-- l. 373 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>sp</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
then apply the local complementation rule (<a href='#x7-112007r6'>5.6<!-- tex4ht:ref: eq:lc-zx  --></a>) (from right to left) on the
vertex marked by <!-- l. 373 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext class='MathClass-open' stretchy='false'>(∗)</mtext></mrow></math>:
</p>
<div class='center'>
<!-- l. 375 --><p class='noindent'>
</p><!-- l. 376 --><p class='noindent'><object data="svgs/lc-simp-proof.svg" alt="diagram of lc-simp-proof" class="svg-diagram"></object> </p></div>
                                                                     

                                                                     
<!-- l. 379 --><p class='indent'>   Using Eq. (<a href='main_htmlch3.html#x5-67009r84'>3.84<!-- tex4ht:ref: eq:S-state-equality  --></a>), the topmost spider in the right-hand side above becomes an X-spider,
with phase <!-- l. 379 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>∓</mo> <mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></math>,
which combines with the phase below it into an
<!-- l. 379 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>aπ</mi></mrow></math> phase, where
<!-- l. 379 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math> if we started
with <!-- l. 379 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></math> and
<!-- l. 379 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math> if we had
started with <!-- l. 379 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></math>.
The resulting X-spider copies and fuses with the neighbours:
</p>
<div class='center'>
<!-- l. 381 --><p class='noindent'>
</p><!-- l. 382 --><p class='noindent'><object data="svgs/lc-simp-proof-2.svg" alt="diagram of lc-simp-proof-2" class="svg-diagram"></object> </p></div>
                                                                   □
   </div>
<!-- l. 386 --><p class='indent'>   In words we can describe this rule as follows: if we have a spider (here marked on the
left-hand side by a <!-- l. 386 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mo class='MathClass-bin' stretchy='false'>∗</mo></math>)
with a <!-- l. 386 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
phase in a graph-like diagram that is internal, i.e. that is not connected to inputs
or outputs but only to other spiders, then we can remove it from the diagram by
complementing the connectivity on its neighbourhood and changing some phases.
The reason we complement the neighbourhood, is because in Lemma <a href='#x7-114002r9'>5.2.9<!-- tex4ht:ref: lem:lc-simp  --></a> we get
a fully connected graph on the right-hand side, but if there were already edges
present between some of the spiders, then the resulting double edges would be
removed by Lemma <a href='#x7-109003r5'>5.1.5<!-- tex4ht:ref: lem:hopf-law-h  --></a>, so that we indeed complement the edges in the
neighbourhood. For the remainder of this chapter, when we say we ‘apply’
Lemma <a href='#x7-114002r9'>5.2.9<!-- tex4ht:ref: lem:lc-simp  --></a> we mean that we apply it from left to right on some chosen vertex,
and that we immediately follow it by Lemma <a href='#x7-109003r5'>5.1.5<!-- tex4ht:ref: lem:hopf-law-h  --></a> in order to cancel
the introduced parallel edges, so that we are still left with a graph-like
diagram.
</p>
   <div class='newtheorem'>
<!-- l. 389 --><p class='noindent'><span class='head'>
<a id='x7-114004r10'></a>
<span class='cmbx-10x-x-109'>Remark* 5.2.10.</span>  </span> In  this  rule  we  ignored  non-zero  scalar  factors  (like
we always do). However, when we applied Eq. (<a href='main_htmlch3.html#x5-67009r84'>3.84<!-- tex4ht:ref: eq:S-state-equality  --></a>), the actual equation
with  the  correct  scalar,  Lemma <a href='main_htmlch3.html#x5-79011r8'>3.6.8<!-- tex4ht:ref: lem:S-state-eq-with-scalars  --></a>,  introduces  an  additional  scalar
<!-- l. 390 --><img src="svgs/fracpi2.svg" alt="diagram of fracpi2" class="inline-diagram" />
                                                                     

                                                                     
spider.  So  in  this  sense,  Lemma <a href='#x7-114002r9'>5.2.9<!-- tex4ht:ref: lem:lc-simp  --></a>  is  not  really  removing  the
<!-- l. 392 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
spider,       as       it       is       just       interchanging       it       for       a
<!-- l. 392 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
spider that is not connected to any other spider, and hence is just a simple
scalar. This is important for when we discuss completeness in Section <a href='#completeness-of-clifford-zxdiagrams'>5.5<!-- tex4ht:ref: sec:completeness-Clifford  --></a>.
</p>
   </div>
<!-- l. 393 --><p class='indent'>    In a Clifford diagram each spider has a phase
<!-- l. 394 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math> for some
<!-- l. 394 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi></mrow></math>. Using the
rule above repeatedly on a graph-like Clifford diagram we can remove <span class='cmti-10x-x-109'>all </span>internal spiders
with a <!-- l. 394 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
phase. Hence, the only internal spiders that remain are those that have a
<!-- l. 394 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math> or
<!-- l. 394 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
phase. Most of these internal spiders can also be removed, by using a variation on
the pivot rule (<a href='#x7-113003r8'>5.8<!-- tex4ht:ref: eq:pivot-zx  --></a>).
</p>
   <div class='newtheorem'>
<!-- l. 396 --><p class='noindent'><span class='head'>
<a id='x7-114005r11'></a>
<span class='cmbx-10x-x-109'>Lemma 5.2.11.</span>  </span> The following pivot simplification holds: </p><table class='equation-star'><tr><td>
<!-- l. 398 --><object data="svgs/pivot-simp.svg" alt="diagram of pivot-simp" class="svg-diagram"></object></td></tr></table>
   </div>
<!-- l. 401 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 403 --><p class='indent'>   <span class='head'>
                                                                     

                                                                     
<span class='cmti-10x-x-109'>Proof.</span> </span>We        pull        out        all        of        the        phases        via
<!-- l. 403 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>sp</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
and apply the pivot rule Lemma <a href='#x7-113005r7'>5.2.7<!-- tex4ht:ref: lem:pivot-zx  --></a>:
</p>
<div class='center'>
<!-- l. 405 --><p class='noindent'>
</p><!-- l. 406 --><p class='noindent'><object data="svgs/pivot-simp-proof.svg" alt="diagram of pivot-simp-proof" class="svg-diagram"></object> </p></div>
<!-- l. 409 --><p class='indent'>   We then apply the colour-change rule to turn the Z-spiders with phases
<!-- l. 409 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>jπ</mi></mrow></math> and
<!-- l. 409 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>kπ</mi></mrow></math> into
X-spiders. They can then be copied, colour-changed again and fused with their
neighbours: </p><table class='equation-star'><tr><td>
<!-- l. 410 --><object data="svgs/pivot-simp-proof-2.svg" alt="diagram of pivot-simp-proof-2" class="svg-diagram"></object></td></tr></table>
<!-- l. 413 --><p class='indent'>   Note that the dangling scalar diagram appears because we copy twice
and the vertices are connected. We simply ignore this non-zero scalar.
                                                                   □
</p>
   </div>
<!-- l. 415 --><p class='indent'>   Here, the marked spiders on the left-hand side are internal connected spiders
with a <!-- l. 415 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
or <!-- l. 415 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
phase. On the right-hand side, these spiders are removed, at the cost of
complementing their neighbourhood in the manner described by the pivot rule,
and introducing some phases (again, the complementation happens because fully
connected bipartite connectivity is introduced, and parallel edges are then
removed using Lemma <a href='#x7-109003r5'>5.1.5<!-- tex4ht:ref: lem:hopf-law-h  --></a>).
</p>
   <div class='newtheorem'>
                                                                     

                                                                     
<!-- l. 416 --><p class='noindent'><span class='head'>
<a id='x7-114006r10'></a>
<span class='cmbx-10x-x-109'>Exercise 5.10.</span>
</span>Simplify the following circuit to a diagram that has no internal spiders with a
<!-- l. 417 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
phase        or        pairs        of        internal        spiders        with        a
<!-- l. 417 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
or
<!-- l. 417 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
phase.
</p>
<div class='center'>
<!-- l. 419 --><p class='noindent'>
</p><!-- l. 420 --><p class='noindent'><object data="svgs/exer-circuit-lcomp-pivot-reduce.svg" alt="diagram of exer-circuit-lcomp-pivot-reduce" class="svg-diagram"></object> </p></div>
   </div>
<!-- l. 423 --><p class='indent'>
</p>
   <h3 class='sectionHead' id='clifford-normal-forms'><span class='titlemark'>5.3   </span> <a id='x7-1150005.3'></a>Clifford normal forms</h3>
<!-- l. 438 --><p class='noindent'>These simplification lemmas allow us to remove many of the spiders in a Clifford
diagram. In fact, so many that the resulting types of diagrams deserve to be
called <span class='cmti-10x-x-109'>normal forms </span>for Clifford diagrams. In this section we will see two types of
normal forms. The first is what you get if you just keep applying the
local complementation and pivoting simplifications. The second requires
an additional type of pivot operation that removes the final internal
spiders.
</p>
   <h4 class='subsectionHead' id='the-affine-with-phases-normal-form'><span class='titlemark'>5.3.1   </span> <a id='x7-1160005.3.1'></a>The affine with phases normal form</h4>
<!-- l. 442 --><p class='noindent'>Lemma <a href='#x7-114002r9'>5.2.9<!-- tex4ht:ref: lem:lc-simp  --></a> removes those internal spiders with a phase of
<!-- l. 442 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math> so
that if we started with a Clifford diagram, the only phases left on internal spiders
are <!-- l. 442 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
are <!-- l. 442 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>.
Then Lemma <a href='#x7-114005r11'>5.2.11<!-- tex4ht:ref: lem:pivot-simp  --></a> can apply to any remaining internal spider that
                                                                     

                                                                     
is connected to at least one other internal spider. Hence, once we
are done applying Lemmas <a href='#x7-114002r9'>5.2.9<!-- tex4ht:ref: lem:lc-simp  --></a> and <a href='#x7-114005r11'>5.2.11<!-- tex4ht:ref: lem:pivot-simp  --></a> on a Clifford diagram
the only remaining internal spiders are then those that carry a
<!-- l. 442 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math> or
<!-- l. 442 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math> phase
and are connected only to boundary spiders. These diagrams turn out to be
rather useful, so let’s give them a name.
</p>
   <div class='newtheorem'>
<!-- l. 444 --><p class='noindent'><span class='head'>
<a id='x7-116001r1'></a>
<span class='cmbx-10x-x-109'>Definition 5.3.1.</span>  </span> We say a graph-like Clifford diagram is in <span class='cmbx-10x-x-109'>affine with
phases </span>form (AP form) when:
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 447 --><p class='noindent'>every boundary spider is connected to exactly one input or output,
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 448 --><p class='noindent'>every internal spider has a phase of <!-- l. 448 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
     or <!-- l. 448 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>,
     and
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 449 --><p class='noindent'>no two internal spiders are connected to each other. </p></dd></dl>
   </div>
<!-- l. 451 --><p class='indent'>    Our previous summary of the simplification procedure can then be
summarised as follows.
</p>
   <div class='newtheorem'>
<!-- l. 453 --><p class='noindent'><span class='head'>
<a id='x7-116005r2'></a>
<span class='cmbx-10x-x-109'>Proposition 5.3.2.</span>  </span> We can efficiently rewrite any Clifford diagram into
an equivalent AP form.
</p>
   </div>
                                                                     

                                                                     
<!-- l. 455 --><p class='indent'>    In an AP form we have two groups of spiders. We have the boundary spiders
and we have the internal spiders. The boundary spiders can be connected to any
other spider (via a Hadamard edge) and carry any phase, but the internal spiders
are <span class='cmti-10x-x-109'>only </span>connected to the boundary spiders and can only have a phase of
<!-- l. 456 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math> or
<!-- l. 456 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>.
</p>
   <div class='newtheorem'>
<!-- l. 457 --><p class='noindent'><span class='head'>
<a id='x7-116006r3'></a>
<span class='cmbx-10x-x-109'>Example 5.3.3.</span>  </span> An example AP form:
</p>
<div class='center'>
<!-- l. 460 --><p class='noindent'>
</p><!-- l. 461 --><p class='noindent'><object data="svgs/AP-form-example.svg" alt="diagram of AP-form-example" class="svg-diagram"></object> </p></div>
<!-- l. 464 --><p class='indent'>   for <!-- l. 464 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>b</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
and <!-- l. 464 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>k</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>3</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>.
</p>
   </div>
<!-- l. 465 --><p class='indent'>    Thanks to condition 1 of Definition <a href='#x7-116001r1'>5.3.1<!-- tex4ht:ref: def:ap-form  --></a>, AP forms don’t treat inputs and
outputs differently. Thus, from hence forth we will primarily study <span class='cmti-10x-x-109'>states </span>in
AP form. Here, we implicitly use the fact that we can treat arbitrary
AP form maps as states by ‘bending wires’ to turn inputs into outputs.
For example, the map from Example <a href='#x7-116006r3'>5.3.3<!-- tex4ht:ref: ex:ap-map  --></a> can be treated as a state as
follows:
</p>
<div class='center'>
<!-- l. 468 --><p class='noindent'>
</p><!-- l. 469 --><p class='noindent'><object data="svgs/ap-form-bend.svg" alt="diagram of ap-form-bend" class="svg-diagram"></object> </p></div>
<!-- l. 472 --><p class='indent'>   Why do we call these diagrams ‘affine with phases’? To answer this we need
to look at what types of states they encode. There are a couple of different things
going on here, so for simplicity we’ll start with just the ‘affine’ part of AP forms
then build up to the general case. Recall from Section <a href='main_htmlch4.html#xz-normal-forms-and-orthogonal-subspaces'>4.3.2<!-- tex4ht:ref: sec:xz-ortho  --></a> that a phase-free X-Z
normal forms give us a state defined by a system of linear equations:
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 474 --><object data="svgs/X-Z-nf-ex-state.svg" alt="diagram of X-Z-nf-ex-state" class="svg-diagram"></object></td></tr></table>
<!-- l. 477 --><p class='indent'>   Importantly, <!-- l. 477 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
is always defined by a <span class='cmti-10x-x-109'>homogeneous </span>system of linear equations, meaning the
right-hand side of every equation is 0. Equivalently, it is the set of bit vectors
<!-- l. 477 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math> satisfying
<!-- l. 477 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>M</mi><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math> for some
<!-- l. 477 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>-matrix
<!-- l. 477 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>. We
can generalise this form by additionally allowing the X spiders to carry
<!-- l. 477 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math> or
<!-- l. 477 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
phases. This gives us almost the same thing, except now
<!-- l. 477 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> can
be defined by an <span class='cmti-10x-x-109'>inhomogeneous </span>system of linear equations. Each X spider with a
<!-- l. 477 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math> phase gives us an
equation with a <!-- l. 477 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
on the right-hand side, whereas an X spider with a
<!-- l. 477 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math> phase gives us an
equation with a <!-- l. 477 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>
on the right-hand side. For example: </p><table class='equation'><tr><td>
<!-- l. 478 --><p class='indent'>
</p><!-- l. 478 --><object id='x7-116007r11' data="svgs/eq-affine-eqs.svg" alt="diagram of eq:affine-eqs" class="svg-diagram"></object></td><td class='eq-no'>(5.11)</td></tr></table>
<!-- l. 481 --><p class='indent'>   That is, we get the set of vectors <!-- l. 481 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math>
satisfying <!-- l. 481 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>M</mi><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></mrow></math> for
some fixed matrix <!-- l. 481 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>
                                                                     

                                                                     
and vector <!-- l. 481 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></math>.
In the example above, its: </p><table class='equation-star'><tr><td>
<!-- l. 482 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mi>M</mi> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                   </mrow><mo fence='true' form='postfix'>)</mo></mrow><mspace class='qquad' width='2em'></mspace><mspace class='qquad' width='2em'></mspace><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 492 --><p class='indent'>   Whereas the set of all solutions to a system of homogeneous
linear equations always gives us a <span class='cmti-10x-x-109'>linear </span>subspace of
<!-- l. 492 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msubsup></math>, the
solutions to an inhomogeneous system will, in general, form an affine subspace.
Intuitively, an affine subspace is like a linear subspace that has been shifted away
from the origin by some fixed amount.
</p>
   <div class='newtheorem'>
<!-- l. 493 --><p class='noindent'><span class='head'>
<a id='x7-116008r4'></a>
<span class='cmbx-10x-x-109'>Definition 5.3.4.</span>  </span> An <span class='cmbx-10x-x-109'>affine subspace</span>
<!-- l. 494 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi> <mo class='MathClass-rel' stretchy='false'>⊆</mo> <msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msubsup></mrow></math> is
either: </p>
     <ul class='itemize1'>
     <li class='itemize'>the empty set, or
     </li>
     <li class='itemize'>a set of the form <!-- l. 497 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>S</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-bin' stretchy='false'>+</mo> <mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='thinspace' width='0.17em'></mspace><mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>S</mi><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
     for some fixed vector <!-- l. 497 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo> <msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msubsup></mrow></math>
     and a linear subspace <!-- l. 497 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi> <mo class='MathClass-rel' stretchy='false'>⊆</mo> <msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msubsup></mrow></math>.
     </li></ul>
   </div>
                                                                     

                                                                     
<!-- l. 499 --><p class='indent'>    Just like in the case of linear spaces, we have two equivalent representations
for an affine subspace, either in terms of a spanning set of vectors or a system of
equations. As before, these correspond to Z-X normal forms and X-Z
normal forms, respectively. In both cases, the extra data needed to define
an affine space (as opposed to a linear one) is included by introducing
<!-- l. 500 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
phases on to some of the X spiders. </p><table class='equation'><tr><td>
<!-- l. 501 --><p class='indent'>
</p><!-- l. 501 --><object id='x7-116009r12' data="svgs/eq-affine-ZX-XZ.svg" alt="diagram of eq:affine-ZX-XZ" class="svg-diagram"></object></td><td class='eq-no'>(5.12)</td></tr></table>
<!-- l. 504 --><p class='indent'>   As before, we have decorated spiders with vectors to mean that there is an edge to the
<!-- l. 504 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>-th spider
if the <!-- l. 504 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>-th
entry of the associated vector is 1. Note the second row is a general form for (<a href='#x7-116007r11'>5.11<!-- tex4ht:ref: eq:affine-eqs  --></a>), since
<!-- l. 504 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow><mrow><mi>T</mi> </mrow></msubsup><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow></math> gives the XOR of the
variables <!-- l. 504 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub></math> for which
<!-- l. 504 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>. Equivalently, the
vectors <!-- l. 504 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></math> correspond to
the rows in a matrix <!-- l. 504 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>
such that <!-- l. 504 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mi>M</mi><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>.
</p>
   <div class='newtheorem'>
<!-- l. 505 --><p class='noindent'><span class='head'>
<a id='x7-116010r11'></a>
<span class='cmbx-10x-x-109'>Exercise 5.11.</span>  </span> The bit strings appearing in the superposition in an AP
state are described by the solutions to the affine system of equations
<!-- l. 506 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>M</mi><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>. When we do row
operations on <!-- l. 506 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>
and <!-- l. 506 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></math>
(as in a Gaussian elimination of the linear system) this does
not change the solutions, and so this transformed system
<!-- l. 506 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>M</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
should still describe the same state. As the matrix
                                                                     

                                                                     
<!-- l. 506 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>
corresponds to the connectivity of the internal spiders to the boundary spiders,
show that these row operations can be implemented diagrammatically:
</p><table class='equation-star'><tr><td>
<!-- l. 507 --><object data="svgs/AP-row-operation.svg" alt="diagram of AP-row-operation" class="svg-diagram"></object></td></tr></table>
   </div>
<!-- l. 510 --><p class='indent'>     If we colour-change the X spiders, we see that we’re most of the way to an
AP form: </p><table class='equation'><tr><td>
<!-- l. 517 --><p class='indent'>
</p><!-- l. 517 --><object id='x7-116011r13' data="svgs/eq-affine-st.svg" alt="diagram of eq:affine-st" class="svg-diagram"></object></td><td class='eq-no'>(5.13)</td></tr></table>
<!-- l. 522 --><p class='indent'>   Hence, if we do not have phases on the outputs or Hadamard edges between
them, an AP form can always be described by an affine subspace. For a generic
AP form, by spider (un)fusion, we can split off the affine part from the rest,
which we’ll call the ‘phase’ part: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 523 --><object data="svgs/AP-state.svg" alt="diagram of AP-state" class="svg-diagram"></object></td></tr></table>
<!-- l. 526 --><p class='indent'>   The reason for the name is that the ‘phase’ part always forms a diagonal unitary, which
means all it will do to the state is introduce some phases on the computational basis states
<!-- l. 526 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> from (<a href='#x7-116011r13'>5.13<!-- tex4ht:ref: eq:affine-st  --></a>).
By unfusing some spiders, we can see that this phase part is generated by S gates, which
introduce <!-- l. 526 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></math>
phases to individual outputs, and CZ gates, which introduce Hadamard edges
between outputs. We can see that each of these gates affects the phase in a way
that depends on the computational basis state: </p><table class='equation-star'><tr><td>
<!-- l. 527 --><object data="svgs/eqn-1.svg" alt="diagram of eqn-1" class="svg-diagram"></object></td></tr></table>
<!-- l. 530 --><p class='indent'>   We can describe the action of unitaries built out of these gates using certain
polynomials, called <span class='cmbx-10x-x-109'>phase polynomials</span>. For example: </p><table class='equation-star'><tr><td>
<!-- l. 531 --><object data="svgs/ap-phase-ex.svg" alt="diagram of ap-phase-ex" class="svg-diagram"></object></td></tr></table>
   <table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 534 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
             <mspace class='qquad' width='2em'></mspace><mstyle class='text'><mtext class='textrm' mathvariant='normal'>where</mtext></mstyle><mspace class='qquad' width='2em'></mspace><mi>ϕ</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub>
</mrow></math></td></tr></table>
<!-- l. 538 --><p class='indent'>   Here, each single-qubit gate (i.e. the
<!-- l. 538 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> gate on the first
qubit and the <!-- l. 538 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>S</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>Z</mi></mrow></math>
gate on the second) contributes a linear term to
<!-- l. 538 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ϕ</mi></math>,
whereas each two-qubit CZ gate contributes a quandratic term, whose coefficient
is always even. Note that, even though these polynomials can contain products
of variables, they are always linear in each argument individually. For
that reason, we call these phase polynomials in <span class='cmbx-10x-x-109'>multilinear form</span>. In
Chapter <a href='main_htmlch7.html#universal-circuits'>7<!-- tex4ht:ref: ch:universal  --></a> we will see phase polynomials in <span class='cmbx-10x-x-109'>XOR-form</span>, and in Chapter
<a href='main_htmlch9.html#controlled-gates-and-classical-oracles'>9<!-- tex4ht:ref: ch:midlevel  --></a>, we will see how these two forms are related. By applying a diagonal
Clifford unitary to an affine state, the phase is applied to each of the terms
in the same. So, if we combine the example above with (<a href='#x7-116011r13'>5.13<!-- tex4ht:ref: eq:affine-st  --></a>) we get:
</p><table class='equation-star'><tr><td>
<!-- l. 540 --><object data="svgs/ap-ex.svg" alt="diagram of ap-ex" class="svg-diagram"></object></td></tr></table>
   <table class='equation'><tr><td>
<!-- l. 543 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 543 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='label' id='x7-116012r14'></mstyle><!-- endlabel --><mspace class='qquad' width='2em'></mspace><mstyle class='text'><mtext class='textrm' mathvariant='normal'>where</mtext></mstyle><mspace class='qquad' width='2em'></mspace><mrow class='cases'> <mrow><mo fence='true' form='prefix'>{</mo><mrow> <mtable align='axis' class='array' columnlines='none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='left'><mi>A</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='thinspace' width='0.17em'></mspace><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn><mo class='MathClass-close' stretchy='false'>}</mo><mspace class='quad' width='1em'></mspace></mtd>
</mtr><mtr class='array-row'><mtd class='array-td' columnalign='left'><mi>ϕ</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo>     <mspace class='quad' width='1em'></mspace></mtd></mtr> <!-- @{}l@{\quad }l@{} --></mtable>                       </mrow><mo fence='true' form='postfix'></mo></mrow></mrow>
</mrow></math></td><td class='eq-no'>(5.14)</td></tr></table>
   <div class='newtheorem'>
<!-- l. 550 --><p class='noindent'><span class='head'>
<a id='x7-116013r12'></a>
<span class='cmbx-10x-x-109'>Exercise 5.12.</span>  </span>Reduce the following diagram to AP-form:
</p>
<div class='center'>
<!-- l. 553 --><p class='noindent'>
</p><!-- l. 554 --><p class='noindent'><object data="svgs/AP-form-reduction-exer.svg" alt="diagram of AP-form-reduction-exer" class="svg-diagram"></object> </p></div>
<!-- l. 557 --><p class='indent'>   What is its parity matrix and its phase polynomial?
</p>
   </div>
<!-- l. 558 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='gslc-normal-form'><span class='titlemark'>5.3.2   </span> <a id='x7-1170005.3.2'></a>GSLC normal form</h4>
<!-- l. 565 --><p class='noindent'>In a diagram in AP form there are still some internal spiders. It turns out that
we can actually also get rid of these. However this does come at a cost: we must
then allow Hadamards on input and output wires, so that the diagram is not
what we have defined to be a ’graph-like diagram’. Just as it was useful
to define a ‘graph state with local Cliffords’, it will be useful here to
define a diagram that is graph-like up to Hadamards on the boundary
wires.
</p>
   <div class='newtheorem'>
<!-- l. 566 --><p class='noindent'><span class='head'>
<a id='x7-117001r5'></a>
<span class='cmbx-10x-x-109'>Definition 5.3.5.</span>  </span>We  say  a  diagram  is  <span class='cmbx-10x-x-109'>graph-like  with  Hadamards</span>
when it satisfies all the conditions for being graph-like (Definition <a href='#x7-109005r7'>5.1.7<!-- tex4ht:ref: def:graph-like  --></a>),
except that inputs and outputs are also allowed to be connected to Z-spiders
via a Hadamard.
                                                                     

                                                                     
</p>
   </div>
<!-- l. 568 --><p class='indent'>    Note that a graph-like diagram with Hadamards can be easily transformed
into a graph-like diagram by introducing some additional Z-spiders using the
<!-- l. 569 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>id</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> rule. So how
do we get rid of the final internal spiders in a Clifford diagram? Note that each of those
spiders has a <!-- l. 570 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
or <!-- l. 570 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
phase and is only connected to boundary spiders (in particular, it is connected to
<span class='cmti-10x-x-109'>at least one </span>boundary spider, since otherwise it would just be a floating scalar we
can ignore). The first step is to introduce some dummy Hadamards and
identity spiders to make this boundary spider into an internal spider:
</p><table class='equation'><tr><td>
<!-- l. 571 --><p class='indent'>
</p><!-- l. 571 --><object id='x7-117002r15' data="svgs/eq-pivot-boundary-unfuse.svg" alt="diagram of eq:pivot-boundary-unfuse" class="svg-diagram"></object></td><td class='eq-no'>(5.15)</td></tr></table>
<!-- l. 574 --><p class='indent'>   The diagram is now no longer just graph-like, but graph-like with Hadamards and the
spider with the <!-- l. 574 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>γ</mi></math>
phase has become internal. Then we make two case distinctions. If
<!-- l. 574 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>γ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math> or
<!-- l. 574 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>, we have an internal pair of
<!-- l. 574 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>/<!-- l. 574 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
spiders, and we can remove them using the pivot simplification Lemma <a href='#x7-114005r11'>5.2.11<!-- tex4ht:ref: lem:pivot-simp  --></a>. If
<!-- l. 574 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>γ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>,
then we can first remove that spider using the local complementation
Lemma <a href='#x7-114002r9'>5.2.9<!-- tex4ht:ref: lem:lc-simp  --></a>. As a result of this, the phase of the spider with the
<!-- l. 574 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>jπ</mi></mrow></math> phase becomes
<!-- l. 574 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>jπ</mi> <mo class='MathClass-bin' stretchy='false'>∓</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math> so that its
phase is also <!-- l. 574 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>.
We can then also remove this spider using local complementation. In both
cases we see that we can remove both spiders, and hence that we get
rid of the original internal spider. Note that in the second case, when
<!-- l. 574 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>γ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>, the other spiders it is
connected to also gain a <!-- l. 574 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>∓</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
phase, so that this might also give some additional opportunities to remove internal
                                                                     

                                                                     
spiders using local complementation. We can repeat this procedure for any remaining
internal spider. This might result in multiple Hadamards appearing on the same
input or output wire. In that case we can of course cancel these Hadamards using
<!-- l. 575 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>hh</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
Combining the simplifications so far we see that we can hence actually remove <span class='cmti-10x-x-109'>all</span>
internal spiders in a Clifford diagram. Let’s give a name to such a type of
diagram.
</p>
   <div class='newtheorem'>
<!-- l. 577 --><p class='noindent'><span class='head'>
<a id='x7-117003r6'></a>
<span class='cmbx-10x-x-109'>Definition 5.3.6.</span>  </span> We say a Clifford diagram is in <span class='cmbx-10x-x-109'>GSLC form </span>when it is
graph-like with Hadamards and has no internal spiders.
</p>
   </div>
<!-- l. 579 --><p class='indent'>    As before, GSLC here stands for <span class='cmti-10x-x-109'>graph state with local Cliffords</span>. This is a
fitting name, because states in GSLC form <span class='cmti-10x-x-109'>are </span>graph states with local Cliffords
as defined in Definition <a href='#x7-110004r11'>5.1.11<!-- tex4ht:ref: def:gslc  --></a>. Indeed, if we have a state, so a diagram with no
inputs, that is in GSLC form, then every spider must be connected to an output,
possibly via a Hadamard, so after unfusing the phases on the spiders, we see
that it is indeed a graph state followed by some single-qubit Clifford
unitaries:
</p>
<div class='center'>
<!-- l. 582 --><p class='noindent'>
</p><!-- l. 583 --><p class='noindent'><object data="svgs/GSLC-form-to-graph-state.svg" alt="diagram of GSLC-form-to-graph-state" class="svg-diagram"></object> </p></div>
<!-- l. 586 --><p class='indent'>   Let’s summarise what we have shown in a proposition.
</p>
   <div class='newtheorem'>
<!-- l. 587 --><p class='noindent'><span class='head'>
<a id='x7-117004r7'></a>
<span class='cmbx-10x-x-109'>Proposition 5.3.7.</span>  </span> Any Clifford diagram can be efficiently rewritten to
an equivalent diagram in GSLC form.
</p>
   </div>
                                                                     

                                                                     
<!-- l. 589 --><p class='indent'>    As a consequence of this, all <span class='cmti-10x-x-109'>Clifford states</span>, those states
that can be produced from applying a Clifford unitary to
<!-- l. 590 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, must
be equal to graph states with local Cliffords.
</p>
   <div class='newtheorem'>
<!-- l. 591 --><p class='noindent'><span class='head'>
<a id='x7-117005r8'></a>
<span class='cmbx-10x-x-109'>Theorem 5.3.8.</span>  </span>                                                             Let
<!-- l. 592 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
a  Clifford  unitary  (i.e. a  circuit  consisting  of  CNOTs,  Hadamards  and
<!-- l. 592 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
gates).                                                                                   Then
<!-- l. 592 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
is a graph state with local Cliffords.
</p>
   </div>
<!-- l. 593 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 595 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>We                    can                    easily                    represent
<!-- l. 595 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
as a Clifford diagram. Proposition <a href='#x7-117004r7'>5.3.7<!-- tex4ht:ref: prop:clifford-to-GSLC  --></a> shows it can be reduced to GSLC
form. Unfusing the phases then transforms this into a graph state with local
Cliffords.                                                                                     □
</p>
   </div>
<!-- l. 598 --><p class='indent'>   In fact, we have something even stronger: we can apply the Clifford circuit to
<!-- l. 598 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, and then also <span class='cmti-10x-x-109'>post-select</span>
some outputs to be <!-- l. 598 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
(or <!-- l. 598 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>1</mn><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>,
<!-- l. 598 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext class='MathClass-open' stretchy='false'>⟨+|</mtext></mrow></math> or
<!-- l. 598 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext class='MathClass-open' stretchy='false'>⟨−|</mtext></mrow></math> for
that matter), and <span class='cmti-10x-x-109'>still </span>have a graph state with local Cliffords.
</p>
   <div class='newtheorem'>
<!-- l. 599 --><p class='noindent'><span class='head'>
<a id='x7-117006r9'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Proposition 5.3.9.</span>  </span>Let <!-- l. 600 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
be a state produced by applying a Clifford unitary <!-- l. 600 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
to <!-- l. 600 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
and then post-selecting some qubits to <!-- l. 600 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>.
Then <!-- l. 600 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
is (proportional to) a graph state with local Cliffords.
</p>
   </div>
<!-- l. 601 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 603 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>The  rewrite  strategy  to  bring  the  diagram  to  GSLC  form  works
regardless of how we produced the Clifford ZX-diagram, so we can still apply
it in this setting.                                                                           □
</p>
   </div>
<!-- l. 605 --><p class='indent'>   This means that allowing Z-basis measurements on Clifford states doesn’t
give us something more general or powerful: we get exactly the same class of
states. Finally, let us write down an equivalence between two different notions of
Clifford states.
</p>
   <div class='newtheorem'>
<!-- l. 607 --><p class='noindent'><span class='head'>
<a id='x7-117007r10'></a>
<span class='cmbx-10x-x-109'>Proposition 5.3.10.</span>  </span> Let <!-- l. 608 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math>
be a Clifford diagram without inputs (i.e. a state). Then <!-- l. 608 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math>
is equal to a Clifford state <!-- l. 608 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
for some Clifford unitary <!-- l. 608 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>.
</p>
   </div>
<!-- l. 609 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 611 --><p class='indent'>   <span class='head'>
                                                                     

                                                                     
<span class='cmti-10x-x-109'>Proof.</span> </span>Rewrite
<!-- l. 611 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math>
to GSLC form so that it is a graph state with local Cliffords, and then build
<!-- l. 611 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
as                the                circuit                that                transforms
<!-- l. 611 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
into that graph state plus the local Cliffords.                                      □
</p>
   </div>
<!-- l. 613 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='normal-form-for-clifford-circuits'><span class='titlemark'>5.3.3   </span> <a id='x7-1180005.3.3'></a>Normal form for Clifford circuits</h4>
<!-- l. 614 --><p class='noindent'>In the previous section we saw that if we simplify a Clifford <span class='cmti-10x-x-109'>state</span>, that we get a
graph state with local Cliffords. What happens if we simplify a Clifford <span class='cmti-10x-x-109'>unitary</span>
in the same manner? Again, there are no internal spiders in the diagram, so each
spider must be connected to at least one input or output. By introducing
some dummy spiders we can ensure that each spider is connected to
exactly one input or output. The diagram will then look something like the
following:
</p>
<div class='center'>
<!-- l. 617 --><p class='noindent'>
</p><!-- l. 618 --><p class='noindent'><object data="svgs/gslc-diagram-unitary.svg" alt="diagram of gslc-diagram-unitary" class="svg-diagram"></object> </p></div>
<!-- l. 621 --><p class='indent'>   We have possible Hadamards on the inputs and outputs as our reduced
diagram is graph-like with Hadamards. Each spider can carry a phase, and each
spider is connected to exactly one input or output, so that we have two layers of
spiders. There are no further (obvious) restrictions for how the spiders can be
connected via Hadamard edges. We will now investigate how we can make
diagrams like this look more like circuits. First, note that we can unfuse the
phases on both sides so that the Hadamards and the phases form a layer of local
Cliffords:
</p>
<div class='center'>
<!-- l. 625 --><p class='noindent'>
</p><!-- l. 626 --><p class='noindent'><object data="svgs/gslc-diagram-unitary-unfused.svg" alt="diagram of gslc-diagram-unitary-unfused" class="svg-diagram"></object> </p></div>
                                                                     

                                                                     
<!-- l. 629 --><p class='indent'>   Second, we can unfuse the connections between the spiders in the same layer.
This reveals those connections to be CZ gates:
</p>
<div class='center'>
<!-- l. 631 --><p class='noindent'>
</p><!-- l. 632 --><p class='noindent'><object data="svgs/gslc-diagram-unitary-cz.svg" alt="diagram of gslc-diagram-unitary-cz" class="svg-diagram"></object> </p></div>
<!-- l. 635 --><p class='indent'>   It remains to see what is happening in the middle-part of the diagram. This
should become clear once we change the colour of the layer of spiders on the
right: </p><table class='equation'><tr><td>
<!-- l. 636 --><p class='indent'>
</p><!-- l. 636 --><object id='x7-118001r16' data="svgs/eq-gslc-diagram-unitary-cnots.svg" alt="diagram of eq:gslc-diagram-unitary-cnots" class="svg-diagram"></object></td><td class='eq-no'>(5.16)</td></tr></table>
<!-- l. 639 --><p class='indent'>   We recognise this middle part of the diagram as a parity normal form
(Definition <a href='main_htmlch4.html#x6-92004r2'>4.2.2<!-- tex4ht:ref: def:parity-NF  --></a>)! So far, all the steps we have done on this GSLC diagram
work regardless of whether the diagram is unitary. However, when the
diagram is unitary, then this parity normal form must represent a unitary
matrix itself, and hence by Proposition <a href='main_htmlch4.html#x6-94003r12'>4.2.12<!-- tex4ht:ref: prop:parity-to-CNOTs  --></a>, it is equivalent to a CNOT
circuit. Summarising this analysis of GSLC unitary diagrams we see
that we can represent any Clifford unitary as a particular sequence of
gates.
</p>
   <div class='newtheorem'>
<!-- l. 642 --><p class='noindent'><span class='head'>
<a id='x7-118002r11'></a>
<span class='cmbx-10x-x-109'>Theorem 5.3.11.</span>  </span> Let <!-- l. 643 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
be a Clifford unitary. Then <!-- l. 643 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
can be written as a circuit consisting of 8 layers of gates in the following order:
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 644 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
            <mstyle class='text'><mtext>Had</mtext></mstyle> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>S</mi> <mo class='MathClass-bin' stretchy='false'>−</mo><mstyle class='text'><mtext>CZ</mtext></mstyle> <mo class='MathClass-bin' stretchy='false'>−</mo><mstyle class='text'><mtext>CNOT</mtext></mstyle> <mo class='MathClass-bin' stretchy='false'>−</mo><mstyle class='text'><mtext>Had</mtext></mstyle> <mo class='MathClass-bin' stretchy='false'>−</mo><mstyle class='text'><mtext>CZ</mtext></mstyle> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>S</mi> <mo class='MathClass-bin' stretchy='false'>−</mo><mstyle class='text'><mtext>Had</mtext></mstyle>
</mrow></math></td></tr></table>
   </div>
<!-- l. 645 --><p class='indent'>    This is really surprising! For one thing, before we started this chapter you
might think there are an infinite number of different unitaries you can build from
the Hadamard, S and CNOT gate, as you can just make longer and longer
circuits, but this result shows that we can always reduce such a long
circuit to one consisting of just a few layers of gates. In particular, we
need at most a quadratic number of gates in terms of the number of
qubits.
</p>
   <div class='newtheorem'>
<!-- l. 647 --><p class='noindent'><span class='head'>
<a id='x7-118003r12'></a>
<span class='cmbx-10x-x-109'>Proposition 5.3.12.</span>  </span> Any <!-- l. 648 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
Clifford unitary can be represented by an equivalent circuit consisting of at
most <!-- l. 648 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>4</mn><mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>3</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
Hadamard, <!-- l. 648 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
and CNOT gates.
</p>
   </div>
<!-- l. 649 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 651 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>A layer of Hadamard gates contains at most
<!-- l. 651 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
gates, and there are three of those. Each layer of
<!-- l. 651 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> gates has at most
<!-- l. 651 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>3</mn></math> gates per qubits,
                                                                     

                                                                     
corresponding to an <!-- l. 651 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>,
<!-- l. 651 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math> or
<!-- l. 651 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></math> gate, and
there are again two of those layers. Hence, the single-qubit gates contribute at most
<!-- l. 651 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>9</mn><mi>n</mi></mrow></math> gates. A circuit of CZ
gates contains at most <!-- l. 652 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></math>
CZ gates (corresponding to all possible pairs of qubits there can be a CZ
between). A CZ gate can be constructed from a CNOT and two Hadamards,
and hence each CZ layer, of which there are two, contributes at most
<!-- l. 652 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>3</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></math> gates.
The number of CNOTs needed in the CNOT circuit corresponds to how
many Gaussian elimination row operations are needed to fully reduce the
associated parity matrix. It is a little exercise to show that you need at most
<!-- l. 652 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math> row
operations to fully reduce any matrix. The total number of needed Hadamard,
<!-- l. 653 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> and
CNOT gates is then: </p><table class='equation-star'><tr><td>
<!-- l. 654 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
    <mn>9</mn><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mn>3</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>6</mn><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>4</mn><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>4</mn><mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>3</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-punc' stretchy='false'>.</mo>   <mi>□</mi>
</mrow></math></td></tr></table>
   </div>
   <div class='newtheorem'>
<!-- l. 656 --><p class='noindent'><span class='head'>
<a id='x7-118004r13'></a>
<span class='cmbx-10x-x-109'>Corollary 5.3.13.</span>  </span>For any given number of qubits, there are only a finite
number of different Clifford unitaries.
</p>
   </div>
<!-- l. 658 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 659 --><p class='noindent'><span class='head'>
                                                                     

                                                                     
<a id='x7-118005r13'></a>
<span class='cmbx-10x-x-109'>Exercise 5.13.</span>  </span>Using Theorem <a href='#x7-118002r11'>5.3.11<!-- tex4ht:ref: thm:Clifford-layers  --></a>, give an upper-bound on the number
of different <!-- l. 660 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
Clifford unitaries for any <!-- l. 660 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>.
<span class='cmti-10x-x-109'>Hint: See Section </span><a href='main_htmlch4.html#better-cnot-circuit-extraction'><span class='cmti-10x-x-109'>4.5.1</span><!-- tex4ht:ref: sec:better-CNOT-extraction  --></a> <span class='cmti-10x-x-109'>for how you can count this.</span>
</p>
   </div>
<!-- l. 662 --><p class='indent'>    We can also conclude another interesting fact from this extraction of a circuit from
a GSLC normal form. The simplification procedure to get to this GSLC normal form
works for <span class='cmti-10x-x-109'>any </span>Clifford ZX-diagram, i.e. any ZX-diagram whose phases are multiples
of <!-- l. 663 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></math>,
not just those coming from a Clifford circuit. If such a diagram happens to be
unitary, then we can use the procedure above to transform it into a Clifford
circuit. Hence, the following proposition immediately follows.
</p>
   <div class='newtheorem'>
<!-- l. 664 --><p class='noindent'><span class='head'>
<a id='x7-118006r14'></a>
<span class='cmbx-10x-x-109'>Proposition 5.3.14.</span>  </span>  Any  unitary  Clifford  ZX-diagram  is  equal  to  a
Clifford circuit.
</p>
   </div>
<!-- l. 666 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 667 --><p class='noindent'><span class='head'>
<a id='x7-118007r14'></a>
<span class='cmbx-10x-x-109'>Exercise 5.14.</span>  </span> Show that any Clifford ZX-diagram of an isometry <!-- l. 668 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math>
can be transformed into a Clifford circuit with some ancilla qubits in state
<!-- l. 668 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
That is, there exists come Clifford circuit <!-- l. 668 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
such that <!-- l. 668 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>U</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-punc' stretchy='false'>.</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
or graphically:
</p>
                                                                     

                                                                     
<div class='center'>
<!-- l. 670 --><p class='noindent'>
</p><!-- l. 671 --><p class='noindent'><object data="svgs/U-with-ancillae.svg" alt="diagram of U-with-ancillae" class="svg-diagram"></object> </p></div>
<!-- l. 674 --><p class='noindent'><span class='cmti-10x-x-109'>Hint: See Exercise </span><a href='main_htmlch4.html#x6-94007r6'><span class='cmti-10x-x-109'>4.6</span><!-- tex4ht:ref: exer:CNOT-isometry  --></a><span class='cmti-10x-x-109'>.</span>
</p>
   </div>
<!-- l. 675 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 676 --><p class='noindent'><span class='head'>
<a id='x7-118008r15'></a>
<span class='cmbx-10x-x-109'>Exercise 5.15.</span>  </span>In Theorem <a href='#x7-118002r11'>5.3.11<!-- tex4ht:ref: thm:Clifford-layers  --></a> we had three layers of Hadamards. It turns
out we only need two, because we can get rid of either the first or last one by
doing some additional rewriting before extracting a circuit. To start, let’s assume
we have a unitary Clifford ZX-diagram in GSLC form. We are going to
progressively remove Hadamards on its input wires.
   </p><dl class='enumerate'><dt class='enumerate'>
a) </dt><dd class='enumerate'>
   <!-- l. 679 --><p class='noindent'>Suppose we have an input spider with a Hadamard on it, and that the
   phase of the spider is <!-- l. 679 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>aπ</mi></mrow></math>.
   Show that we can remove this Hadamard by doing a regular, non-vertex-removing,
   pivot (<a href='#x7-113003r8'>5.8<!-- tex4ht:ref: eq:pivot-zx  --></a>) between this input and an output it is connected to. Why will
   it always be connected to an output? Argue that this does not introduce
   any Hadamards on other inputs.
   </p></dd><dt class='enumerate'>
b) </dt><dd class='enumerate'>
   <!-- l. 680 --><p class='noindent'>Suppose we have an input spider with a Hadamard on it, and that the
   phase of the spider is <!-- l. 680 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>.
   Show that you can remove the Hadamard by using a Euler decomposition
   and removing the resulting <!-- l. 680 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi><mo class='MathClass-open' stretchy='false'>(</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
   phase using a regular local complementation (<a href='#x7-112003r4'>5.4<!-- tex4ht:ref: eq:local-comp-zx  --></a>). Show that you can
   rewrite  the  diagram  back  into  GSLC  form,  but  now  with  one  fewer
   Hadamard on an input wire.
   </p></dd><dt class='enumerate'>
c) </dt><dd class='enumerate'>
   <!-- l. 681 --><p class='noindent'>Argue that if you do these steps for all the inputs with Hadamards on
   them, that you get a GSLC form diagram where extracting a circuit does
   not give any Hadamards in the first layer. </p></dd></dl>
                                                                     

                                                                     
   </div>
<!-- l. 683 --><p class='indent'>
</p>
   <h3 class='sectionHead' id='classical-simulation-of-clifford-circuits'><span class='titlemark'>5.4   </span> <a id='x7-1190005.4'></a>Classical simulation of Clifford circuits</h3>
<!-- l. 685 --><p class='noindent'>In the previous sections we saw that we can use two simple rewrites, local
complementation and pivots, to reduce Clifford states to graph states
with local Cliffords, and Clifford circuits to a normal form consisting
of just a few layers of gates. There is a third class of relevant Clifford
diagrams that we can simplify using these rewrite rules: scalars. Recall
that a scalar diagram is any ZX-diagram that has no inputs or outputs.
The reason we care about scalar diagrams is because they can represent
amplitudes of a quantum computation. If we start with the basis state
<!-- l. 689 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, then apply
a unitary <!-- l. 689 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>,
and finally wish to know the amplitude of the state
<!-- l. 689 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
with respects to some computational basis effect
<!-- l. 689 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math> we get the scalar
<!-- l. 689 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. In our case we
are interested in <!-- l. 690 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>’s
that are Clifford unitaries, so that the resulting scalar ZX-diagram is also
Clifford. So what happens if we feed a scalar Clifford diagram to the
simplification procedure described in Section <a href='#simplifying-clifford-diagrams'>5.2<!-- tex4ht:ref: sec:cliff-simp  --></a>? Remember that the procedure
allowed us to remove any internal Clifford spider. However, in a scalar Clifford
diagram, <span class='cmti-10x-x-109'>all </span>spiders are internal and Clifford, so after we are done simplifying
there will be no spiders left! The diagram will have been simplified away
completely. What does this mean? The empty diagram evaluates to the scalar
<!-- l. 693 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>.
However, remember that all our rewrites also introduce some scalar
factors, which in the case of Clifford diagrams are always multiples of
<!-- l. 693 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></math> and
<!-- l. 693 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup></math>. So
the end result is just a number, which is equal to the amplitude we were
calculating. Let’s summarise all this in a proposition.
</p>
   <div class='newtheorem'>
<!-- l. 695 --><p class='noindent'><span class='head'>
<a id='x7-119001r1'></a>
<span class='cmbx-10x-x-109'>Proposition 5.4.1.</span>  </span> Let <!-- l. 696 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
                                                                     

                                                                     
be a Clifford circuit, and let <!-- l. 696 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
for <!-- l. 696 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math>
be  any  computational  basis  effect.  Then  we  can  efficiently  calculate  the
amplitude <!-- l. 696 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
</p>
   </div>
<!-- l. 697 --><p class='indent'>    This is really surprising! Clifford circuits contain essentially all the features
we would expect from a quantum computation—entanglement, superpositions,
and negative and complex amplitudes—and we can use Clifford circuits to realise
many truly quantum protocols such as quantum teleportation or quantum key
distribution, <span class='cmti-10x-x-109'>and yet</span>, such circuits offer no computational benefit over classical
computers. This result is known in the literature as the Gottesman-Knill
theorem.
     </p><blockquote class='quote'>
     <!-- l. 702 --><p class='noindent'><span class='cmbx-10x-x-109'>Gottesman-Knill theorem</span>: A Clifford computation can be
     efficiently classically simulated. </p></blockquote>
<!-- l. 704 --><p class='noindent'>Why is this the case? Well, on the surface we see it’s because we can just rewrite the
corresponding diagrams very well. But why is it that we can do that? A hint is
given by the affine with phases normal form of Clifford states. Apparently,
Clifford circuits can only produce quantum states that are uniform superpositions
of computational basis states that are efficiently described by an affine
subspace of bit strings. This means there is a limit to how much we can
actually use the complex amplitudes and entanglement present in Clifford
states. There is for instance no way in which we can iteratively repeat a
procedure to slowly add more and more amplitude to certain states like
is done in Grover’s algorithm: the amplitudes are always distributed
equally.
</p>
   <h4 class='subsectionHead' id='simulating-cliffords-efficiently'><span class='titlemark'>5.4.1   </span> <a id='x7-1200005.4.1'></a>Simulating Cliffords efficiently</h4>
<!-- l. 706 --><p class='noindent'>In Proposition <a href='#x7-119001r1'>5.4.1<!-- tex4ht:ref: prop:Clifford-amplitude-efficient  --></a> we said we could simulate a Clifford amplitude efficiently,
but how efficient are we talking? The entire ‘simulation’ just consists of diagram
simplification operations, so the complexity of the method, how expensive it
is to actually calculate an amplitude, comes down to how hard it is to
find the correct rewrite rule to apply, the number of rewrites we need to
do, and how hard these rewrites are to perform. The first two of these
questions are easily answered. First, how hard is it to find the correct rewrite
rule to apply? Well, local complementation applies to any spider with a
<!-- l. 709 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math> phase, so
                                                                     

                                                                     
we simply have to loop over the spiders of the diagram until we encounter a spider with
the correct phase. When we are done doing local complementations, any spider will
have a <!-- l. 709 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
or <!-- l. 709 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
phase left, so all the spiders are suitable for a pivot, and we only need to look at
any neighbour, so that finding a place where we can apply a rewrite rule is quite
trivial in this setting: we can do it anywhere. The second question, how many
rewrite rules need to be applied, is also easily answered. Each of the rewrite rules,
local complementation and pivoting, removes at least one spider, so that the
number of rewrite rules applied is bounded by the number of spiders. Finally,
how hard is it actually to change the diagram based on the rewrite rules? We will
measure this in terms of the number of <span class='cmbx-10x-x-109'>elementary graph operations </span>we
need to perform: vertex and edge additions or removals. When we do a
local complementation, we remove a single vertex, and we toggle the
connectivity of all its neighbours. In the worst case, the spider we wish to
remove is connected to pretty much all other spiders. In this case we
end up changing the connectivity of the entire graph. So if there are
<!-- l. 712 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>N</mi></math> spiders, then
this could cost <!-- l. 712 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>N</mi></mrow><mrow><mn>2</mn></mrow></msup></math>
edge additions and removals. A similar cost estimation holds for pivoting: we
remove two spiders, and we toggle connectivity between three groups of spiders
that could also pretty much encompass the entire graph, so that it also costs
<!-- l. 713 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>N</mi></mrow><mrow><mn>2</mn></mrow></msup></math> graph
operations to implement a pivot. So a single simplification costs about
<!-- l. 714 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>N</mi></mrow><mrow><mn>2</mn></mrow></msup></math>
elementary graph operations in the worst case, and as we’ve seen, we will need about
<!-- l. 714 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>N</mi></math>
rewrite rules to fully simplify the graph, which means we will need
<!-- l. 714 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>N</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <msup><mrow><mi>N</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>N</mi></mrow><mrow><mn>3</mn></mrow></msup></mrow></math>
graph operations in the worst case. In comparison to this, the cost of
finding the right rewrite rules to apply is negligible (adding at most an
<!-- l. 715 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> cost
to the application of every rewrite rule). We can now state a more detailed
version of Proposition <a href='#x7-119001r1'>5.4.1<!-- tex4ht:ref: prop:Clifford-amplitude-efficient  --></a>.
</p>
   <div class='newtheorem'>
<!-- l. 717 --><p class='noindent'><span class='head'>
<a id='x7-120001r2'></a>
<span class='cmbx-10x-x-109'>Proposition 5.4.2.</span>  </span> Let <!-- l. 718 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math>
be a scalar Clifford diagram containing <!-- l. 718 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>N</mi></math>
spiders. Then we can calculate the value of <!-- l. 718 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math>
in time <!-- l. 718 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>N</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
                                                                     

                                                                     
In particular, we can calculate amplitudes of a Clifford circuit containing
<!-- l. 719 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
gates in time <!-- l. 719 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>k</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
</p>
   </div>
<!-- l. 720 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 722 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>The  first  claim  follows  from  the  discussion  on  the  complexity  of
rewriting above. For the second claim we simply note that each gate in a
Clifford circuit can be translated into a fixed small number of spiders, so
that the ZX-diagram corresponding to the amplitude to be calculated has
<!-- l. 722 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>k</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
spiders.                                                                                       □
</p>
   </div>
<!-- l. 724 --><p class='indent'>   Now, <!-- l. 724 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>N</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
is not too bad, but it does mean that once we start dealing with diagrams with,
say, <span class='cmti-10x-x-109'>millions</span>, of spiders, that we run into trouble. Can we do better?
As it turns out: yes! With a more clever simplification strategy, we can
actually obtain a significantly better upper bound. The reason we got this
<!-- l. 726 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>N</mi></mrow><mrow><mn>3</mn></mrow></msup></math>
scaling, is because we weren’t telling the simplifier <span class='cmti-10x-x-109'>which </span>spiders to target, so
that we couldn’t limit the number of wires that end up in the diagram. There is a
better strategy that we can use to simplify the diagram, which works
when we know that the diagram came from a circuit. The idea is that
once we have a GSLC diagram that we can very efficiently ‘absorb’ a
Clifford gate and rewrite the whole thing as another GSLC diagram.
So suppose we have a Clifford circuit consisting of CZ, Hadamard and
<!-- l. 728 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> gates
(if your circuit contains CNOTs, then these can be converted into CZ gates
surrounded by Hadamards). Now when we write this circuit as a ZX-diagram, it
will only contain Z-spiders, so that it already looks a bit like a graph-like
diagram. <span class='cmti-10x-x-109'>However</span>, we will not actually reduce it to graph-like form like we
did with our previous simplification algorithm. Instead we will keep the
circuit structure intact. Now we will introduce some dummy spiders and
Hadamards in order to insert a GSLC form diagram at the start of the circuit:
</p><table class='equation'><tr><td>
<!-- l. 730 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 730 --><object id='x7-120002r17' data="svgs/Clifford-sim-dummy-spiders.svg" alt="diagram of Clifford-sim-dummy-spiders" class="svg-diagram"></object></td><td class='eq-no'>(5.17)</td></tr></table>
<!-- l. 733 --><p class='indent'>   We will now consume gates one by one from the circuit and absorb them into
the GSLC part of the diagram, transforming it into a different GSLC diagram,
while not affecting the other parts of the diagram. Depending on the gate and on
the specific configuration the GLSC part of the diagram is in, we will need to do
different things. The easiest gate to deal with is the Hadamard. This is simply
absorbed as part of the GSLC if there is no Hadamard already on that qubit, or
cancelled if there is one: </p><table class='equation'><tr><td>
<!-- l. 735 --><p class='indent'>
</p><!-- l. 735 --><object id='x7-120003r18' data="svgs/Clifford-sim-Hadamards.svg" alt="diagram of Clifford-sim-Hadamards" class="svg-diagram"></object></td><td class='eq-no'>(5.18)</td></tr></table>
<!-- l. 738 --><p class='indent'>   For <!-- l. 738 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
gates and CZ gates the situation is more complicated. If there are no Hadamards
on the qubits they act on, then we can also absorb them as part of the GSLC:
</p><table class='equation'><tr><td>
<!-- l. 739 --><p class='indent'>
</p><!-- l. 739 --><object id='x7-120004r19' data="svgs/Clifford-sim-S-CZ-absorb.svg" alt="diagram of Clifford-sim-S-CZ-absorb" class="svg-diagram"></object></td><td class='eq-no'>(5.19)</td></tr></table>
                                                                     

                                                                     
<!-- l. 742 --><p class='indent'>   For the CZ gate, as always, if there was already a Hadamard edge
present between the spiders, then we simply toggle the connectivity.
Now, if there <span class='cmti-10x-x-109'>is </span>a Hadamard in the way then we can’t just fuse the
<!-- l. 743 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
or CZ gate into the GSLC. Instead, we will need to resort to our
old friends, the local complementation and pivot. The reason we can
use these, is because if there is a Hadamard in the way, with an
<!-- l. 743 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
or CZ gate on the right-hand side, then the spider that is part of
the GSLC is ‘internal’ in the sense that all its connections are
to other spiders via a Hadamard edge. Now, if this spider has a
<!-- l. 743 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
phase, this is straightforward enough: we just apply a local
complementation on it to remove it. This connects the spider of the
<!-- l. 743 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
or CZ gate to all the neighbours of this internal spider, so that the
<!-- l. 743 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> or
CZ spider takes its place in the GSLC diagram: </p><table class='equation'><tr><td>
<!-- l. 744 --><p class='indent'>
</p><!-- l. 744 --><object id='x7-120005r20' data="svgs/Clifford-sim-lcomp.svg" alt="diagram of Clifford-sim-lcomp" class="svg-diagram"></object></td><td class='eq-no'>(5.20)</td></tr></table>
<!-- l. 747 --><p class='indent'>   Now, if the spider we wish to remove has a
<!-- l. 747 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math> or
<!-- l. 747 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
phase, then we need to apply a pivot to get rid of it. The spider must be
connected to at least one input spider (since the diagram is unitary), so that we
can apply the standard non-spider-removing pivot rule of (<a href='#x7-113003r8'>5.8<!-- tex4ht:ref: eq:pivot-zx  --></a>). The end result is
that the output Hadamard disappears, so that the spider of the gate can be
fused and become part of the GSLC diagram. Combining these different
options we see that we can always absorb a gate into the GSLC portion
of the diagram. We can hence simplify the entire circuit into a GSLC
diagram.
</p>
   <div class='newtheorem'>
<!-- l. 750 --><p class='noindent'><span class='head'>
                                                                     

                                                                     
<a id='x7-120006r16'></a>
<span class='cmbx-10x-x-109'>Exercise 5.16.</span>  </span>Reduce the following Clifford circuit to GSLC form using
the algorithm described in this section.
</p>
<div class='center'>
<!-- l. 753 --><p class='noindent'>
</p><!-- l. 754 --><p class='noindent'><object data="svgs/Clifford-circuit-exercise.svg" alt="diagram of Clifford-circuit-exercise" class="svg-diagram"></object> </p></div>
   </div>
<!-- l. 757 --><p class='indent'>    Crucially, the connectivity change resulting from these local
complementations and pivots is now restricted to just the other spiders
of the GSLC diagram and the spider corresponding to the gate to be
absorbed, instead of potentially involving the entire diagram. Letting
<!-- l. 758 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>q</mi></math> denote the number
of qubits, there are <!-- l. 758 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi>q</mi></mrow></math>
qubits in the GSLC diagram, so that this requires toggling at most
<!-- l. 758 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mi>q</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mn>2</mn></mrow></msup></math> edges. We need to
do such a rewrite potentially for every gate we absorb, so that the entire simplification costs
<!-- l. 759 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> elementary graph
operations where <!-- l. 759 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>N</mi></math>
is the number of gates in the circuit. Compare this to our previous method that
required <!-- l. 760 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>N</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
elementary graph operations. The number of gates is generally a lot more
than the number of qubits, so this is a significant savings. Indeed, from
Proposition <a href='#x7-118003r12'>5.3.12<!-- tex4ht:ref: prop:Clifford-number-of-gates  --></a> it follows that to represent an arbitrary Clifford unitary we need
<!-- l. 760 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> gates, so
taking <!-- l. 760 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>N</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>
we see that we have improved the complexity from
<!-- l. 760 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>q</mi></mrow><mrow><mn>6</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> to
<!-- l. 760 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>q</mi></mrow><mrow><mn>4</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
</p>
   <div class='newtheorem'>
<!-- l. 761 --><p class='noindent'><span class='head'>
<a id='x7-120007r3'></a>
<span class='cmbx-10x-x-109'>Proposition 5.4.3.</span>  </span> Let <!-- l. 762 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
be a <!-- l. 762 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>q</mi></math>-qubit
Clifford circuit with <!-- l. 762 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>N</mi></math>
                                                                     

                                                                     
CNOT, Hadamard and <!-- l. 762 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
gates. Then we can reduce it to GSLC form using <!-- l. 762 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
elementary graph operations. Furthermore, assuming that <!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>N</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mi>q</mi></mrow></math>,
we can also write <!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
in the layered normal form of Theorem <a href='#x7-118002r11'>5.3.11<!-- tex4ht:ref: thm:Clifford-layers  --></a> in <!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
time.
</p>
   </div>
<!-- l. 764 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 766 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>The reduction to GSLC form in <!-- l. 766 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
time follows from the algorithm described above. To rewrite a GSLC diagram
into the layered Clifford normal form requires a Gaussian elimination of the
central parity diagram (<a href='#x7-118001r16'>5.16<!-- tex4ht:ref: eq:gslc-diagram-unitary-cnots  --></a>). This takes <!-- l. 766 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>q</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
time for a total cost of <!-- l. 766 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>q</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
As long as <!-- l. 766 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>N</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mi>q</mi></mrow></math>,
this reduces to <!-- l. 766 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
                                                                   □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 768 --><p class='noindent'><span class='head'>
<a id='x7-120008r4'></a>
<span class='cmbx-10x-x-109'>Proposition 5.4.4.</span>  </span>Let <!-- l. 769 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
be a <!-- l. 769 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>q</mi></math>-qubit
Clifford circuit with <!-- l. 769 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>N</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mi>q</mi></mrow></math>
CNOT, Hadamard and <!-- l. 769 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
gates. Then we can calculate any amplitude <!-- l. 769 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
in <!-- l. 769 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
time. If <!-- l. 769 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
is given as a GSLC diagram then this reduces to <!-- l. 769 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>q</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
</p>
   </div>
<!-- l. 770 --><p class='indent'>
</p>
   <div class='proof'>
                                                                     

                                                                     
<!-- l. 772 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>We first reduce <!-- l. 772 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
to GSLC form using the algorithm described above. This takes <!-- l. 772 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
time. Then we compose the diagram with the ZX-diagrams for <!-- l. 772 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
and <!-- l. 772 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>.
This adds <!-- l. 772 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>q</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
spiders, so that the total diagram has <!-- l. 772 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>q</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
spiders. Using the standard simplification algorithm on this diagram then
requires <!-- l. 772 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>q</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
graph operations. Assuming <!-- l. 772 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>N</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mi>q</mi></mrow></math>
the total cost is then <!-- l. 772 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
for fully reducing the diagram to a scalar. If <!-- l. 772 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
were already given as a GSLC diagram, then only the final set of simplifications
is necessary, requiring just <!-- l. 772 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>q</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
graph operations.                                                                          □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 774 --><p class='noindent'><span class='head'>
<a id='x7-120009r17'></a>
<span class='cmbx-10x-x-109'>Exercise* 5.17.</span>  </span>The
<!-- l. 775 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>N</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
bound   on   calculating   amplitudes   in   Proposition <a href='#x7-120001r2'>5.4.2<!-- tex4ht:ref: prop:Clifford-amplitude-N3  --></a>   is   just   an
upper-bound. In practice it might turn out not to be so bad. Implement a
benchmark of random Clifford circuits with an increasing number of gates
and/or qubits and measure what the actual exponent is more like. Does
the exponent stay the same for different number of qubits? Can you find a
different strategy for targeting spiders to remove that leads to better scaling?
</p>
   </div>
<!-- l. 777 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='weak-vs-strong-simulation'><span class='titlemark'>5.4.2   </span> <a id='x7-1210005.4.2'></a>Weak vs strong simulation</h4>
<!-- l. 779 --><p class='noindent'>In the previous sections we discussed how to calculate the amplitude
corresponding to observing a particular effect on a Clifford state and we called
this ‘simulating’ a Clifford computation. But this is not entirely correct. In order
                                                                     

                                                                     
to truly say we are simulating a quantum computation we should be getting the
same types of outcomes that we would get when we would actually run
the quantum circuit. These outcomes come in the form of measurement
samples. Namely, we would prepare a quantum state, execute quantum gates
on it, and finally measure each qubit. The outcome is then a bit string
specifying which measurement outcome we got for each qubit. By running
the experiment many times we will see a particular distribution of bit
strings as outcomes. To simulate a quantum computation is then to be
able to generate a series of bit strings that have a similar distribution of
outcomes.
</p>
   <div class='newtheorem'>
<!-- l. 780 --><p class='noindent'><span class='head'>
<a id='x7-121001r5'></a>
<span class='cmbx-10x-x-109'>Definition 5.4.5.</span>  </span>Let
<!-- l. 781 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
be some unitary, and write
<!-- tex4ht:inline --></p><!-- l. 782 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                    <mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup>
</mrow></math>
<!-- l. 782 --><p class='nopar'> for the probabilities of observing the outcome <!-- l. 783 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
when applying <!-- l. 783 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
to the input state <!-- l. 783 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
We then say a probabilistic algorithm <span class='cmbx-10x-x-109'>weakly simulates </span><!-- l. 784 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
when it produces bit strings <!-- l. 784 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math>
according to a distribution suitably close to <!-- l. 784 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>P</mi></math>.
</p>
   </div>
<!-- l. 785 --><p class='indent'>    In this definition ‘suitably close’ can be made exact, but that won’t be
necessary for us for now. With what we have seen up to now, it is not
obvious how we can actually efficiently weakly simulate Clifford unitaries.
We are however quite close to being able to <span class='cmti-10x-x-109'>strongly </span>simulate Clifford
circuits.
                                                                     

                                                                     
</p>
   <div class='newtheorem'>
<!-- l. 789 --><p class='noindent'><span class='head'>
<a id='x7-121002r6'></a>
<span class='cmbx-10x-x-109'>Definition 5.4.6.</span>  </span>Let <!-- l. 790 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
be some unitary, and let <!-- l. 790 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
be its associated probability distribution as above. Then we say an algorithm
<span class='cmbx-10x-x-109'>strongly simulates </span><!-- l. 790 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
when it can calculate (or closely approximate) any marginal probability of
<!-- l. 790 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>P</mi></math>.
</p>
   </div>
<!-- l. 791 --><p class='indent'>    Let’s explain this definition. Recall that a <span class='cmbx-10x-x-109'>marginal probability
distribution </span>is one where we don’t care about the outcome of one or more of
the variables of the distribution. For instance, if we have a distribution
<!-- l. 793 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> of three variables, then
we can <span class='cmbx-10x-x-109'>marginalise </span><!-- l. 793 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub></math>
to get the distribution <!-- l. 793 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub></mrow></msub><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
When <!-- l. 794 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
corresponds to the probabilities of observing particular
measurement outcomes in a 3-qubit circuit, then this marginal
<!-- l. 794 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> tells us the probability
of observing <!-- l. 794 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
on qubit 1 and <!-- l. 794 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
on qubit 2, when we don’t measure qubit 3 at all. The reason we require the ability
to determine any marginal probability in the definition of strong simulation, is that
if we can only calculate the non-marginal probabilities, then it will generally take
exponential resources to determine marginal probabilities. Consider for instance an
<!-- l. 796 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-variable
distribution <!-- l. 796 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
of Boolean variables. Then to calculate the marginal
<!-- l. 796 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> we have to sum
the values of <!-- l. 796 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
variables <!-- l. 796 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></msub><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>, and this
summation contains <!-- l. 796 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
terms. Okay, so now that we understand what the definition says, it might be helpful
to answer why we call this ‘strong’ simulation as opposed to ‘weak’ simulation. First
of all, note that being able to weakly simulate doesn’t seem to easily imply the
ability to calculate the value of the probabilities: it might be that some probability
<!-- l. 797 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> is exponentially
small (in <!-- l. 797 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>),
                                                                     

                                                                     
and hence we would need to sample at least exponentially many bit strings using
weak simulation to get an estimate of its value. But the converse is true: if we can
<span class='cmti-10x-x-109'>strongly </span>simulate a unitary, then we can also <span class='cmti-10x-x-109'>weakly </span>simulate it. To see how to do
this, we need to recall the concept of conditional probabilities. A <span class='cmbx-10x-x-109'>conditional
probability distribution </span>tells us the probability of observing some outcome
<span class='cmti-10x-x-109'>conditional </span>on some other variables taking particular values. For instance
<!-- l. 800 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='thinspace' width='0.17em'></mspace><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
the probability of observing the particular values
<!-- l. 800 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub></math> and
<!-- l. 800 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></math> given
that <!-- l. 800 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>, is
equal to <!-- l. 800 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
Hence, since strong simulation allows us to calculate any marginal probability, we
can then also calculate any conditional probability. So how do we use
marginal and conditional probabilities to generate a sample bit string
<!-- l. 801 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></math> with
the correct distribution? We do this by determining the value of each bit of
<!-- l. 802 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></math> in turn. First we ask
for the probability <!-- l. 802 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
the marginal probability that we observe qubit 1 to give a value of
<!-- l. 802 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>. We then decide
with probability <!-- l. 802 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>p</mi></mrow><mrow><mn>1</mn></mrow></msub></math> to
set <!-- l. 802 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math> and otherwise
we set <!-- l. 802 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>. We then
calculate <!-- l. 803 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='thinspace' width='0.17em'></mspace><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> and set
<!-- l. 803 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>y</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math> with probability
<!-- l. 803 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>p</mi></mrow><mrow><mn>2</mn></mrow></msub></math> and otherwise
<!-- l. 803 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>y</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>. This means that
we have chosen <!-- l. 804 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
and <!-- l. 804 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>y</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
with probability </p><table class='equation'><tr><td>
<!-- l. 805 --><p class='indent'>
</p><!-- l. 805 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
          <mstyle class='label' id='x7-121003r21'></mstyle><!-- endlabel --><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>y</mi></mrow><mrow><mn>2</mn></mrow></msub><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='thinspace' width='0.17em'></mspace><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>y</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow> 
  <mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></mfrac>   <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>y</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo>
</mrow></math></td><td class='eq-no'>(5.21)</td></tr></table>
                                                                     

                                                                     
<!-- l. 808 --><p class='indent'>   which is the correct distribution. We carry on and calculate
<!-- l. 809 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='thinspace' width='0.17em'></mspace><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
and repeat the procedure until we have determined the entire bit string
<!-- l. 809 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>y</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></math>. Repeating
the argument of Eq. (<a href='#x7-121003r21'>5.21<!-- tex4ht:ref: eq:marginal-sample  --></a>) we see that we will have chosen this specific bit string with
probability <!-- l. 809 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
so that we are indeed sampling correctly from this distribution. To summarise:
</p>
     <ul class='itemize1'>
     <li class='itemize'>Weak  simulation  is  about  sampling  correctly  from  the  probability
     distribution of measurement outcomes we would get if we were to
     actually run the quantum circuit.
     </li>
     <li class='itemize'>Strong  simulation  is  about  calculating  the  actual  probabilities  of
     observing certain measurement outcomes;
     </li>
     <li class='itemize'>If we can do strong simulation, then we can do weak simulation. </li></ul>
<!-- l. 816 --><p class='noindent'>So how do we actually do strong simulation of Clifford circuits with
the ZX-diagram simplification strategies we have discussed in
this chapter? Well, we have seen how to calculate an amplitude
<!-- l. 816 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
which allows us to calculate a non-marginal probability
<!-- l. 816 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>. But
how do we calculate a marginal probability? To see this it first helps to expand
<!-- l. 817 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> in a way
that allows us to more easily represent it as a diagram. Recall that for a complex
number <!-- l. 818 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>z</mi></math>
we have <!-- l. 818 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>z</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>z</mi><msup><mrow><mi>z</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>∗</mo></mrow></msup></mrow></math>
where <!-- l. 818 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>z</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>∗</mo></mrow></msup></math>
is the conjugate. The conjugate of the inner product
<!-- l. 818 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> is
<!-- l. 818 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. We
can represent each of these by ZX-diagrams, and as they are scalar diagrams,
their multiplication is implemented just by putting them next to each other:
</p><table class='equation'><tr><td>
<!-- l. 819 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 819 --><object id='x7-121004r22' data="svgs/amplitude-to-probability.svg" alt="diagram of amplitude-to-probability" class="svg-diagram"></object></td><td class='eq-no'>(5.22)</td></tr></table>
<!-- l. 822 --><p class='indent'>   We get these scalar factors of <!-- l. 822 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></math>
because the X-spiders only represent <!-- l. 822 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
and <!-- l. 822 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> up
to a scalar. Note that these middle pairs of spiders correspond then (up to scalar) to
operators <!-- l. 823 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>.
Now if we want to calculate a marginal probability then this corresponds
to a sum of such diagrams where we vary the values of some of the
<!-- l. 824 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub></math>. Remember
that <!-- l. 824 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>x</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>x</mi><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>,
hence on the diagram we can implement this summation by replacing the middle
spiders by an identity wire: </p><table class='equation'><tr><td>
<!-- l. 825 --><p class='indent'>
</p><!-- l. 825 --><object id='x7-121005r23' data="svgs/eq-marginal-probability-diagram.svg" alt="diagram of eq:marginal-probability-diagram" class="svg-diagram"></object></td><td class='eq-no'>(5.23)</td></tr></table>
<!-- l. 828 --><p class='indent'>   Using this diagrammatic representation of a marginal probability allows to
calculate the marginals of a Clifford computation.
</p>
   <div class='newtheorem'>
<!-- l. 829 --><p class='noindent'><span class='head'>
<a id='x7-121006r7'></a>
<span class='cmbx-10x-x-109'>Proposition 5.4.7.</span>  </span>Let <!-- l. 830 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
be a <!-- l. 830 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>q</mi></math>-qubit
Clifford circuit with <!-- l. 830 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>N</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mi>q</mi></mrow></math>
gates. Then we can calculate any marginal probability of <!-- l. 830 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
                                                                     

                                                                     
using <!-- l. 830 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
graph operations. If <!-- l. 830 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
is given in GSLC form then it takes only <!-- l. 830 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>q</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
operations.
</p>
   </div>
<!-- l. 831 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 833 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>First reduce <!-- l. 833 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
to GSLC form using <!-- l. 833 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
operations (see Proposition <a href='#x7-120007r3'>5.4.3<!-- tex4ht:ref: prop:Clifford-efficient-reduce-GSLC  --></a>). Then construct the diagram as in (<a href='#x7-121005r23'>5.23<!-- tex4ht:ref: eq:marginal-probability-diagram  --></a>)
to represent the desired marginal probability. This diagram has <!-- l. 834 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>q</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
spiders, so fully simplifying it requires <!-- l. 834 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>q</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
graph operations. As <!-- l. 834 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>N</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mi>q</mi></mrow></math>
we see that the total number of steps taken is <!-- l. 834 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
                                                                   □
</p>
   </div>
<!-- l. 836 --><p class='indent'>   Since we can now calculate any marginal probability, we have also found a
way to sample measurement outcomes from the Clifford circuit.
</p>
   <div class='newtheorem'>
<!-- l. 837 --><p class='noindent'><span class='head'>
<a id='x7-121007r8'></a>
<span class='cmbx-10x-x-109'>Proposition 5.4.8.</span>  </span>Let <!-- l. 838 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
be a <!-- l. 838 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>q</mi></math>-qubit
Clifford circuit with <!-- l. 838 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>N</mi></math>
gates. Then we can sample <!-- l. 838 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
bit strings from its measurement distribution using <!-- l. 838 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>k</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>4</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
graph operations.
</p>
   </div>
<!-- l. 839 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 841 --><p class='indent'>   <span class='head'>
                                                                     

                                                                     
<span class='cmti-10x-x-109'>Proof.</span> </span>We first reduce <!-- l. 841 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
to GSLC form, which requires <!-- l. 841 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
operations. Now in order to sample a bit string from its distribution (i.e. to
perform weak simulation), we can use the method described above, which
requires us to calculate <!-- l. 841 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>q</mi></math>
marginals, each of which takes <!-- l. 841 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>q</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
operations to calculate. So sampling a single bit string requires <!-- l. 841 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>q</mi></mrow><mrow><mn>4</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
operations. We need to do this <!-- l. 841 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
times, so the total cost is <!-- l. 841 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>k</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>4</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
                                                                   □
</p>
   </div>
<!-- l. 843 --><p class='indent'>   It is perhaps a bit unsatisfying that the weak simulation seems to
be more expensive than the so-called strong simulation. However, it
turns out that there is a smarter way to perform weak simulation
of Clifford circuits. To do this, we also need to simplify our unitary
<!-- l. 845 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> using
ZX-calculus rewrites, but now instead of reducing to GSLC form, we want to
reduce it to the affine with phases form (AP form) of Section <a href='#the-affine-with-phases-normal-form'>5.3.1<!-- tex4ht:ref: sec:affine-NF  --></a>. We can do
this with the same order of graph operations as it takes to reduce to GSLC form.
We can see this in two ways. Either we first reduce to GSLC form using
Proposition <a href='#x7-120007r3'>5.4.3<!-- tex4ht:ref: prop:Clifford-efficient-reduce-GSLC  --></a>, and then we do some final rewrites to reduce it to AP form.
Or, we modify the algorithm used in Proposition <a href='#x7-120007r3'>5.4.3<!-- tex4ht:ref: prop:Clifford-efficient-reduce-GSLC  --></a> so that instead of
absorbing gates into a GSLC part of the diagram, we absorb gates into an AP
form diagram. We hence have the following.
</p>
   <div class='newtheorem'>
<!-- l. 846 --><p class='noindent'><span class='head'>
<a id='x7-121008r9'></a>
<span class='cmbx-10x-x-109'>Proposition 5.4.9.</span>  </span> Let <!-- l. 847 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
be a <!-- l. 847 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>q</mi></math>-qubit
Clifford unitary with <!-- l. 847 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>N</mi></math>
gates. Then we can write both <!-- l. 847 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
and <!-- l. 847 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
in AP form using <!-- l. 847 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
operations.
</p>
   </div>
                                                                     

                                                                     
<!-- l. 848 --><p class='indent'>    Recall from Eq. (<a href='#x7-116012r14'>5.14<!-- tex4ht:ref: eq:AP-form-poly  --></a>) that a state in AP form can naturally be written as
</p><table class='equation-star'><tr><td>
<!-- l. 850 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace>   <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow><mrow><mi>N</mi></mrow></msup></mrow></mfrac><munder class='msub'><mrow><mo> ∑</mo>
   </mrow><mrow><mtable class='subarray-c' columnalign='center' rowspacing='0'><mtr><mtd><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>∈</mo><mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>q</mi></mrow></msup>
</mtd></mtr><mtr><mtd><mi>A</mi><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>=</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover>
     </mtd></mtr>                                                                                                       </mtable></mrow></munder><msup><mrow><mi>i</mi></mrow><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td></tr></table>
<!-- l. 851 --><p class='indent'>   for some phase function <!-- l. 851 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>,
parity matrix <!-- l. 851 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
and bit string <!-- l. 851 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></math>.
This state is an equal superposition of those
<!-- l. 852 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> for which
<!-- l. 852 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>. Hence, if
we measure all the qubits then the outcomes will correspond to one of those bit strings
<!-- l. 852 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math> for which this
parity condition <!-- l. 852 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>
is satisfied (the phase function is irrelevant for the outcomes). So we see that sampling from
the distribution of <!-- l. 853 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
boils down to being able to uniformly randomly select vectors that satisfy such
parity conditions.
</p>
   <div class='newtheorem'>
<!-- l. 854 --><p class='noindent'><span class='head'>
<a id='x7-121009r10'></a>
<span class='cmbx-10x-x-109'>Proposition 5.4.10.</span>  </span>Let <!-- l. 855 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
be a <!-- l. 855 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>q</mi></math>-qubit
Clifford unitary with <!-- l. 855 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>N</mi></math>
gates. Then we can sample <!-- l. 855 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
bit strings from its measurement distribution using <!-- l. 855 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>q</mi></mrow><mrow><mn>3</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>k</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
operations.
</p>
   </div>
<!-- l. 856 --><p class='indent'>
</p>
                                                                     

                                                                     
   <div class='proof'>
<!-- l. 858 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>First write <!-- l. 858 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
in AP form using Proposition <a href='#x7-121008r9'>5.4.9<!-- tex4ht:ref: prop:Clifford-to-AP-efficient  --></a>, which requires <!-- l. 858 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>N</mi><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
operations, and let <!-- l. 858 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
and <!-- l. 858 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></math>
denote the parity matrix and bit string determining the AP form. Now we
need to uniformly randomly return <!-- l. 859 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
bit strings <!-- l. 859 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math>
that satisfy <!-- l. 859 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>.
First find a single <!-- l. 859 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover></math>
for which <!-- l. 859 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>.
This takes <!-- l. 859 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>q</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
operations as <!-- l. 859 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
is of size <!-- l. 859 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>q</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
and Gaussian elimination takes cubic time. Now do another Gaussian elimination
of <!-- l. 860 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
to find a basis <!-- l. 860 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>r</mi></mrow></msup></mrow></math>
for the kernel of <!-- l. 860 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>,
i.e. of those <!-- l. 860 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msup></math>
for which <!-- l. 860 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi><msup><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover></mrow></math>.
This also takes <!-- l. 860 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>q</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
time. Now to determine a uniformly random bit string <!-- l. 860 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math>
satisfying <!-- l. 860 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>
we simply generate uniformly random bits <!-- l. 860 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>c</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><msub><mrow><mi>c</mi></mrow><mrow><mi>r</mi></mrow></msub></mrow></math>
and output <!-- l. 860 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>c</mi></mrow><mrow><mn>1</mn></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>⋯</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>c</mi></mrow><mrow><mi>r</mi></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>r</mi></mrow></msup></mrow></math>
(this is indeed uniformly random as each bit string in the kernel of <!-- l. 860 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
can be written in a unique way as a combination of the basis vectors).
Hence, each additional sample just requires generating some random bits and
summing together <!-- l. 860 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>q</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
bit strings of length <!-- l. 860 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>q</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
for a total cost of <!-- l. 860 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>q</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
per sample.                                                                                  □
</p>
   </div>
<!-- l. 862 --><p class='indent'>   Instead of casting this algorithm in terms of Gaussian elimination, we can
also view it as a diagram rewriting exercise. In Eq. (<a href='#x7-116009r12'>5.12<!-- tex4ht:ref: eq:affine-ZX-XZ  --></a>) we saw that we can
relate the affine part of an AP form diagram, a X-Z normal form, to a different
Z-X form: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 863 --><object data="svgs/affine-XZ.svg" alt="diagram of affine-XZ" class="svg-diagram"></object></td></tr></table>
<!-- l. 866 --><p class='indent'>   From this latter type of diagram we can easily read of which computational basis
states <!-- l. 866 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
are part of the superposition making it up: each Z-spider represents a basis vector
<!-- l. 867 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><msup><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msup></mrow><mo accent='true'>→</mo></mover></math> of the
kernel of <!-- l. 867 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>,
where <!-- l. 867 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow><mrow><mi>j</mi></mrow></msubsup></math> is
<!-- l. 867 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>
precisely when the Z-spider is connected to output spider
<!-- l. 867 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>. While the spiders
give the solution to <!-- l. 867 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover></mrow></math>,
the <!-- l. 867 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
phases on the output transform this into solutions to
<!-- l. 867 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>.
</p>
   <h3 class='sectionHead' id='completeness-of-clifford-zxdiagrams'><span class='titlemark'>5.5   </span> <a id='x7-1220005.5'></a>Completeness of Clifford ZX-diagrams</h3>
<!-- l. 869 --><p class='noindent'>We have seen in this chapter that we can prove <span class='cmti-10x-x-109'>a lot </span>about Clifford circuits using
the ZX-calculus, but can we actually prove <span class='cmti-10x-x-109'>everything</span>? In the previous chapter
we saw that the phase-free ZX-calculus is <span class='cmti-10x-x-109'>complete</span>, meaning we can prove all
equations between phase-free ZX-diagrams using the rules of the phase-free
ZX-calculus. It turns out the same is true for Clifford diagrams, when we use the
Clifford rewrite rules. In this section we will adopt the scalar-accurate rewrite
rules of Section <a href='main_htmlch3.html#dealing-with-scalars'>3.6.2<!-- tex4ht:ref: sec:zx-scalars  --></a>. We will then show that these rewrite rules are complete for
the Clifford fragment, meaning that if we can represent a linear map by
a Clifford diagram, then any two ways to do so can be rewritten into
one another. We show completeness in two steps. First we study scalar
Clifford diagrams and show that these can be reduced to a form that
<span class='cmti-10x-x-109'>uniquely </span>encodes the number they are equal to. Hence, any two scalars
representing the same number are reduced to the same diagram, which shows
that we have completeness for these scalar diagrams. Then we show that
we can refine the AP normal form so that every Clifford diagram can
be reduced to a unique normal form. This means that if two diagrams
                                                                     

                                                                     
represent the same linear map, that they will be reduced to the same
normal form, and hence we have a path of rewriting from one to the
other.
</p>
   <h4 class='subsectionHead' id='a-normal-form-for-scalars'><span class='titlemark'>5.5.1   </span> <a id='x7-1230005.5.1'></a>A normal form for scalars</h4>
<!-- l. 874 --><p class='noindent'>First let’s show that we can correctly deal with scalar Clifford diagrams, so that
we are then again free to ignore them. For this we will use the results of
Section <a href='main_htmlch3.html#dealing-with-scalars'>3.6.2<!-- tex4ht:ref: sec:zx-scalars  --></a>, and hence we use the rules of Figure <a href='main_htmlch3.html#a-complete-and-scalaraccurate-set-of-rewrites-rules-for-the-clifford-fragment-of-the-zxcalculus-these-rules-hold-for-all-r'>3.0<!-- tex4ht:ref: fig:zx-rules-Clifford  --></a> there. We’ve
seen in Proposition <a href='main_htmlch3.html#x5-79007r5'>3.6.5<!-- tex4ht:ref: prop:zero-normal-form  --></a> that when the diagram contains a zero scalar
<!-- l. 875 --><img src="svgs/pi.svg" alt="diagram of pi" class="inline-diagram" />, that
the entire diagram can be reduced to a simple unique form. Hence, we may
assume our scalar diagram is non-zero. Our strategy will be to simplify
an arbitrarily complicated scalar Clifford diagram to a diagram that
consists of small disconnected bits and pieces that can each be dealt with
individually. It is straightforward enough to check that with the rules of
Figure <a href='main_htmlch3.html#a-complete-and-scalaraccurate-set-of-rewrites-rules-for-the-clifford-fragment-of-the-zxcalculus-these-rules-hold-for-all-r'>3.0<!-- tex4ht:ref: fig:zx-rules-Clifford  --></a> we can prove all the rules of Figure <a href='main_htmlch3.html#the-standard-rules-of-the-zxcalculus'>3.0<!-- tex4ht:ref: fig:zx-rules  --></a> up to some scalar diagrams
that contain at most two spiders. Hence, everything we have proven so
far using the rules of Figure <a href='main_htmlch3.html#the-standard-rules-of-the-zxcalculus'>3.0<!-- tex4ht:ref: fig:zx-rules  --></a> remains true using our scalar-accurate
set of rules, except that we might acquire some additional small scalar
diagrams. This means that in particular our simplification strategy for
Clifford diagrams still works, except for some small modifications. We can
still use the local complementation simplification Lemma <a href='#x7-114002r9'>5.2.9<!-- tex4ht:ref: lem:lc-simp  --></a>, but as
noted in Remark <a href='#x7-114004r10'>5.2.10<!-- tex4ht:ref: rem:lc-simp-scalar  --></a>, now it doesn’t actually <span class='cmti-10x-x-109'>remove </span>the spider we
complement on. Instead, the spider remains as an unconnected scalar.
Hence, if we were to apply this rewrite to an unconnected spider (so where
<!-- l. 881 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math> in
that lemma), it would not remove the spider. In order for the simplification
strategy to work we must then only apply this lemma to spiders with a
<!-- l. 881 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math> phase
that are connected to at least one other spider. The same consideration holds for
the pivot simplification Lemma <a href='#x7-114005r11'>5.2.11<!-- tex4ht:ref: lem:pivot-simp  --></a>, where we should only apply it if at least
one of the spiders being pivoted on is connected to some other spider. In
Section <a href='#classical-simulation-of-clifford-circuits'>5.4<!-- tex4ht:ref: sec:clifford-efficient  --></a> it was noted that if we apply the simplification strategy to a scalar
Clifford diagram, that the entire diagram is simplified away. With our
scalar-accurate calculus we see that this now becomes slightly different. We can
still remove most connections between spiders, but there will generally be some
small scalar subdiagrams left.
</p>
   <div class='newtheorem'>
<!-- l. 884 --><p class='noindent'><span class='head'>
<a id='x7-123001r1'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Proposition 5.5.1.</span>  </span> Any scalar Clifford diagram can be rewritten to be a
product of the following scalar subdiagrams: </p><table class='equation-star'><tr><td>
<!-- l. 886 --><object data="svgs/sqrt2-scalar.svg" alt="diagram of sqrt2-scalar" class="svg-diagram"></object></td></tr></table>
   </div>
<!-- l. 889 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 891 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>First  rewrite  the  ZX-diagram  to  graph-like  form,  except  that  we
can’t remove the triple set of wires in <img src="svgs/scalar-sqrt2inv.svg" alt="diagram of scalar-sqrt2inv" class="inline-diagram" /> . We leave
those subdiagrams as is. Then apply the scalar-accurate version of the local
complementation Lemma <a href='#x7-114002r9'>5.2.9<!-- tex4ht:ref: lem:lc-simp  --></a> to any spider with a <!-- l. 893 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
phase that is connected to at least one other spider. After doing this, any
connected spider must have a phase of <!-- l. 894 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
or <!-- l. 894 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>.
Apply the pivot Lemma <a href='#x7-114005r11'>5.2.11<!-- tex4ht:ref: lem:pivot-simp  --></a> to any such pair where at least one of the
spiders has connections to other spiders. Hence, after we are done there
can only be connections between pairs of spiders that aren’t connected to
anything else. By simply enumerating the possibilities (and applying some
colour-changes using <!-- l. 894 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>cc</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>)
we  see  that  the  only  possible  connected  subdiagrams  are  then  the  ones
listed above, <img src="svgs/sqrt2-scalar-pi.svg" alt="diagram of sqrt2-scalar-pi" class="inline-diagram" /> , and <img src="svgs/Z-scalar.svg" alt="diagram of Z-scalar" class="inline-diagram" /> . The first of
these can be rewritten to <img src="svgs/sqrt2-scalar-3.svg" alt="diagram of sqrt2-scalar-3" class="inline-diagram" /> using Lemma <a href='main_htmlch3.html#x5-79005r4'>3.6.4<!-- tex4ht:ref: lem:scalar-phase-consume  --></a>, and
<img src="svgs/Z-scalar.svg" alt="diagram of Z-scalar" class="inline-diagram" /> can be decomposed into a pair of <img src="svgs/sqrt2-scalar-3.svg" alt="diagram of sqrt2-scalar-3" class="inline-diagram" />
’s using Lemma <a href='main_htmlch3.html#x5-79002r1'>3.6.1<!-- tex4ht:ref: lem:scalar-2sqrt2-is-2  --></a>.                                                                    □
</p>
   </div>
                                                                     

                                                                     
<!-- l. 906 --><p class='indent'>   Now, if our scalar diagram contains a
<!-- l. 906 --><img src="svgs/pi.svg" alt="diagram of pi" class="inline-diagram" /> then
it can already be rewritten to a normal form, so let’s assume it does not contain that
subdiagram. Then our diagram is a composition of five different types of diagrams. By
applying <!-- l. 908 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>s</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
we can ensure that the diagram does not contain both a <img src="svgs/sqrt2-scalar-3.svg" alt="diagram of sqrt2-scalar-3" class="inline-diagram" />
and a <img src="svgs/scalar-sqrt2inv.svg" alt="diagram of scalar-sqrt2inv" class="inline-diagram" /> (as they are each others inverses). What other
relations hold between these scalars? Using Lemma <a href='main_htmlch3.html#x5-79010r7'>3.6.7<!-- tex4ht:ref: lem:scalar-min1  --></a> we see that
there can be at most one subdiagram of <img src="svgs/scalar-min1.svg" alt="diagram of scalar-min1" class="inline-diagram" /> and using
Lemma <a href='main_htmlch3.html#x5-79012r9'>3.6.9<!-- tex4ht:ref: lem:scalar-Clifford-pi2  --></a> we can make it so that there is at most one spider with a
<!-- l. 915 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math> phase
in our diagram.
</p>
   <div class='newtheorem'>
<!-- l. 916 --><p class='noindent'><span class='head'>
<a id='x7-123002r2'></a>
<span class='cmbx-10x-x-109'>Theorem 5.5.2.</span>  </span> We  can  rewrite  any  non-zero  scalar  Clifford  diagram
<!-- l. 917 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math>
to a unique normal form <!-- l. 917 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>k</mi></mrow></msubsup> <mo class='MathClass-bin' stretchy='false'>∘</mo> <msub><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>∘</mo> <msub><mrow><mi>D</mi></mrow><mrow><mn>3</mn></mrow></msub></mrow></math>
where <!-- l. 917 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℕ</mi></mrow></math>,
<!-- l. 917 --><img src="svgs/sqrt2-scalar-1.svg" alt="diagram of sqrt2-scalar-1" class="inline-diagram" />,
<!-- l. 919 --><img src="svgs/scalar-min1-1.svg" alt="diagram of scalar-min1-1" class="inline-diagram" />
and <!-- l. 921 --><img src="svgs/scalar-i.svg" alt="diagram of scalar-i" class="inline-diagram" />.
</p>
   </div>
<!-- l. 924 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 926 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Apply Proposition <a href='#x7-123001r1'>5.5.1<!-- tex4ht:ref: prop:Clifford-scalar-reduce  --></a> to rewrite the diagram to a product of pairs
of spiders. Apply Lemma <a href='main_htmlch3.html#x5-79012r9'>3.6.9<!-- tex4ht:ref: lem:scalar-Clifford-pi2  --></a> so that the diagram contains at most one
spider with a <!-- l. 926 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
phase. If this one diagram with a <!-- l. 926 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
is <img src="svgs/scalar-min-i.svg" alt="diagram of scalar-min-i" class="inline-diagram" /> then apply Lemma <a href='main_htmlch3.html#x5-79009r6'>3.6.6<!-- tex4ht:ref: lem:scalar-phases-combine  --></a> in reverse with <!-- l. 928 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>α</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>π</mi></mrow></math>
and <!-- l. 928 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>β</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>,
so that the <!-- l. 928 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
diagram is then <img src="svgs/scalar-i-3.svg" alt="diagram of scalar-i-3" class="inline-diagram" /> . Apply Lemma <a href='main_htmlch3.html#x5-79010r7'>3.6.7<!-- tex4ht:ref: lem:scalar-min1  --></a> so that there is
at most one instance of <img src="svgs/scalar-min1.svg" alt="diagram of scalar-min1" class="inline-diagram" /> . Finally, cancel all pairs of
<img src="svgs/sqrt2-scalar-3.svg" alt="diagram of sqrt2-scalar-3" class="inline-diagram" /> and <img src="svgs/scalar-sqrt2inv.svg" alt="diagram of scalar-sqrt2inv" class="inline-diagram" /> using <!-- l. 938 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>s</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
                                                                     

                                                                     
It is then straightforward to verify that the diagram must be of the form
specified. To see this is a unique representation of the scalar let <!-- l. 940 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>s</mi></math>
denote the value of the scalar the diagram represents. The type of <!-- l. 940 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>3</mn></mrow></msub></math>
tells us whether <!-- l. 940 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>Re</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>s</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext>Im</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>s</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
(<!-- l. 940 --><img src="svgs/fracpi2-3.svg" alt="diagram of fracpi2-3" class="inline-diagram" />),
<!-- l. 942 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>Re</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>s</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><mstyle class='text'><mtext>Im</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>s</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
(<!-- l. 942 --><img src="svgs/fracpi2-4.svg" alt="diagram of fracpi2-4" class="inline-diagram" />),
<!-- l. 944 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>Re</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>s</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>
(<!-- l. 944 --><img src="svgs/scalar-i-1.svg" alt="diagram of scalar-i-1" class="inline-diagram" />)
or <!-- l. 946 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>Im</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>s</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>
(<!-- l. 946 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>D</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='thinspace' width='0.17em'></mspace><img alt='' src='main_html0x.svg' /><mspace class='thinspace' width='0.17em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>).
As <!-- l. 946 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>s</mi><mo class='MathClass-rel' stretchy='false'>≠</mo><mn>0</mn></mrow></math>
by assumption <!-- l. 946 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>3</mn></mrow></msub></math>
must then be the same for any diagram representing <!-- l. 946 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>s</mi></math>
in this normal form. Similarly <!-- l. 946 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
tells us whether the real part of <!-- l. 946 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>s</mi></math>
is positive (or the imaginary part in case <!-- l. 946 --><img src="svgs/scalar-i-2.svg" alt="diagram of scalar-i-2" class="inline-diagram" />),
since <!-- l. 948 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
either represents <!-- l. 948 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></math>
or <!-- l. 948 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>,
so  that  this  must  also  be  the  same  diagram  for  every  representation  of
<!-- l. 948 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>s</mi></math>.
Finally, <!-- l. 949 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
being <!-- l. 949 --><img src="svgs/sqrt2-scalar-2.svg" alt="diagram of sqrt2-scalar-2" class="inline-diagram" />
or <!-- l. 951 --><img src="svgs/scalar-sqrt2inv-1.svg" alt="diagram of scalar-sqrt2inv-1" class="inline-diagram" />
together with the value of <!-- l. 953 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
tells us the magnitude of <!-- l. 953 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>Re</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>s</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
(or Im<!-- l. 953 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>s</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>),
and hence is also uniquely determined by <!-- l. 953 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>s</mi></math>.
                                                                   □
</p>
   </div>
<!-- l. 955 --><p class='indent'>   This theorem tells us that we can always rewrite any two scalar Clifford
ZX-diagrams into one another if they represent the same scalar, since they can
both be rewritten into this unique normal form.
</p>
   <h4 class='subsectionHead' id='a-unique-normal-form-for-clifford-diagrams'><span class='titlemark'>5.5.2   </span> <a id='x7-1240005.5.2'></a>A unique normal form for Clifford diagrams</h4>
<!-- l. 957 --><p class='noindent'>The previous section settled the question of completeness for scalar Clifford
diagrams. In this section we will do the same for non-scalar Clifford diagrams.
Since the question of scalars is now settled, we will again revert back
to not caring about these scalar subdiagrams. As before, we will write
                                                                     

                                                                     
<!-- l. 957 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-rel' stretchy='false'>∝</mo></mrow></math> when
we are denoting an equality up to a non-zero scalar factor. We will just work with
states in this section, so diagrams that don’t have any inputs. Once we have
completeness for states, completeness for all diagrams follows easily just
by bending some wires (like we did in Theorem <a href='main_htmlch4.html#x6-96006r6'>4.3.6<!-- tex4ht:ref: thm:completeness-pp-zx  --></a>). What we will
show in this section is that we can refine the AP form, rewriting it into
something more canonical. We will then show that this reduced normal form
is unique. In particular, we will rewrite our diagrams to the following
form.
</p>
   <div class='newtheorem'>
<!-- l. 959 --><p class='noindent'><span class='head'>
<a id='x7-124001r3'></a>
<span class='cmbx-10x-x-109'>Definition 5.5.3.</span>  </span> A non-zero diagram in AP-form defined by the triple
<!-- l. 960 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mi>ϕ</mi></mrow></math> is in
<span class='cmbx-10x-x-109'>reduced AP-form </span>when:
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 962 --><p class='noindent'><!-- l. 962 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
     is in reduced row echelon form (RREF) with no zero rows,
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 963 --><p class='noindent'><!-- l. 963 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ϕ</mi></math>
     only contains free variables from the system <!-- l. 963 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>.
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 964 --><p class='noindent'>all the coefficients of <!-- l. 964 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ϕ</mi></math>
     are in the interval <!-- l. 964 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
     </p></dd></dl>
   </div>
<!-- l. 966 --><p class='indent'>    Recall that the first non-zero element in a row of a matrix
<!-- l. 967 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math> in
RREF is called a <span class='cmbx-10x-x-109'>pivot </span>(no relation to the pivot graph rewrite rule). The variable
<!-- l. 967 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub></math> is called a <span class='cmti-10x-x-109'>free
variable </span>if the <!-- l. 967 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>th
column of <!-- l. 967 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
does <span class='cmti-10x-x-109'>not </span>contain a pivot, otherwise it is called a <span class='cmti-10x-x-109'>bound variable</span>. The utility of
looking at the reduced AP-form is the following theorem.
                                                                     

                                                                     
</p>
   <div class='newtheorem'>
<!-- l. 968 --><p class='noindent'><span class='head'>
<a id='x7-124005r4'></a>
<span class='cmbx-10x-x-109'>Theorem 5.5.4.</span>  </span> For any non-zero state
<!-- l. 969 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, there is at
most one triple <!-- l. 969 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>A</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mi>ϕ</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
satisfying the conditions of Definition <a href='#x7-124001r3'>5.5.3<!-- tex4ht:ref: def:reduced-ap-form  --></a> such that: </p><table class='equation-star'><tr><td>
<!-- l. 970 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                      <mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∝</mo><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mi>A</mi><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>=</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></mrow></munder><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iπ</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mi>ϕ</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td></tr></table>
   </div>
<!-- l. 973 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 975 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Since <!-- l. 975 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>≠</mo><mn>0</mn></mrow></math>,
the set <!-- l. 975 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>A</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mi>A</mi><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
is non-empty. Hence, there is a unique system of equations in RREF that define
<!-- l. 975 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>A</mi></mstyle></math> (why?). From this
it follows that <!-- l. 975 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math> and
<!-- l. 975 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></math> are uniquely fixed. Now,
for any assignment <!-- l. 975 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mi>x</mi></mrow><mrow><msub><mrow><mi>i</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>c</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><msub><mrow><mi>i</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>c</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math> of free
variables, there exists <!-- l. 975 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∈</mo><mstyle mathvariant='script'><mi>A</mi></mstyle></mrow></math>
such that <!-- l. 975 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><msub><mrow><mi>i</mi></mrow><mrow><mi>μ</mi></mrow></msub></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>c</mi></mrow><mrow><mi>μ</mi></mrow></msub></mrow></math>
(this is why we call these variables ‘free’, they can be chosen
without restrictions while still satisfying the constraints given by
<!-- l. 975 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>).
Hence: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 976 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                        <mo class='MathClass-open' stretchy='false'>⟨</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>λ</mi><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iπϕ</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>c</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>c</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup>
</mrow></math></td></tr></table>
<!-- l. 979 --><p class='indent'>   for some fixed constant <!-- l. 979 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>λ</mi><mo class='MathClass-rel' stretchy='false'>≠</mo><mn>0</mn></mrow></math>.
From this it follows that, by inspection of <!-- l. 979 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
we can determine the value of <!-- l. 979 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ϕ</mi></math>
at all inputs <!-- l. 979 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>c</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>c</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>∈</mo> <msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msubsup></mrow></math>,
modulo <!-- l. 979 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>2</mn></math>.
This is enough to compute each of the coefficients of <!-- l. 979 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ϕ</mi></math>,
modulo 2. (Q: How?) Since we require the coefficients of <!-- l. 980 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ϕ</mi></math>
to be in the interval <!-- l. 980 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>,
we can drop the “modulo 2” and conclude that <!-- l. 980 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ϕ</mi></math>
is uniquely fixed by <!-- l. 980 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
                                                                   □
</p>
   </div>
<!-- l. 982 --><p class='indent'>   Our goal then will be to show that we can rewrite any Clifford
diagram into reduced AP-form. We already know that we can
rewrite the diagram to AP form using Proposition <a href='#x7-116005r2'>5.3.2<!-- tex4ht:ref: prop:AP-form  --></a>. Such a
diagram is then fully described (up to scalar) by a parity matrix
<!-- l. 984 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>, a bit string vector
<!-- l. 984 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></math> and a phase function
<!-- l. 984 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ϕ</mi></math>. We fully Gaussian
eliminate the pair <!-- l. 985 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>A</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
and do the corresponding transformation on the diagram as in Exercise <a href='#x7-116010r11'>5.11<!-- tex4ht:ref: exer:AP-row-operation  --></a>, to
bring it to RREF. If the Gaussian elimination shows that there is no solution to
the affine system, then this corresponds to a scalar X-spider with phase
<!-- l. 986 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math> appearing, which is
equal to the scalar <!-- l. 986 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>.
In this case, we can bring the diagram to the zero normal form of
Proposition <a href='main_htmlch3.html#x5-79007r5'>3.6.5<!-- tex4ht:ref: prop:zero-normal-form  --></a>. So let’s suppose that this is not the case, and the
affine system is not inconsistent. We remove all the zero rows of
<!-- l. 987 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
(which correspond to scalar spiders). So now each row of
<!-- l. 987 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math> is a
linear independent bit string. The affine part of the diagram is then unique. It then
                                                                     

                                                                     
remains to show that we can rewrite the phase part so that the phase function
<!-- l. 989 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ϕ</mi></math> only
depends on free variables. To do this it will be useful to introduce some
notation. Each of the internal spiders in the diagram defines a <span class='cmti-10x-x-109'>parity set</span>
<!-- l. 990 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mi>j</mi></mrow></msub></math>
containing the spiders it is connected to. Since we have fully reduced the matrix
<!-- l. 990 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>, each
<!-- l. 990 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mi>j</mi></mrow></msub></math> contains a <span class='cmti-10x-x-109'>pivot
spider </span><!-- l. 990 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>∈</mo> <msub><mrow><mi>P</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></math> that does
not appear in any other parity set. We then need to rewrite the diagram so that the pivot spiders
<!-- l. 990 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>p</mi></mrow><mrow><mi>j</mi></mrow></msub></math> does not interact
at all with <!-- l. 990 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ϕ</mi></math>. This
means it must not have any phase, and not be involved with any CZs. First, if a pivot spider
has a phase of <!-- l. 991 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>,
then this can be pushed to the other spiders of its parity set: </p><table class='equation-star'><tr><td>
<!-- l. 992 --><object data="svgs/AP-push-pi.svg" alt="diagram of AP-push-pi" class="svg-diagram"></object></td></tr></table>
<!-- l. 995 --><p class='indent'>   If instead its phase is <!-- l. 995 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
then we can remove it by applying a local complementation type rewrite rule. We
start by applying the local complementation Lemma <a href='#x7-114002r9'>5.2.9<!-- tex4ht:ref: lem:lc-simp  --></a> in reverse:
</p><table class='equation-star'><tr><td>
<!-- l. 997 --><object data="svgs/AP-local-complementation-pf.svg" alt="diagram of AP-local-complementation-pf" class="svg-diagram"></object></td></tr></table>
                                                                     

                                                                     
<!-- l. 1000 --><p class='indent'>   Here in the last step we also implicitly got rid of the scalar spiders that result after applying
the copy rule <!-- l. 1000 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>sc</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
Now that all pivot spiders have no more phase, we will remove all the Hadamard
edges that pivot spiders are involved in. First, we remove all the Hadamard edges
from a pivot to a spider within its own parity set. We can do this by repeating
the following rewrite: </p><table class='equation-star'><tr><td>
<!-- l. 1002 --><object data="svgs/AP-CZ-push-parity.svg" alt="diagram of AP-CZ-push-parity" class="svg-diagram"></object></td></tr></table>
<!-- l. 1005 --><p class='indent'>   After every such rewrite the number of Hadamard edges from a pivot strictly
decreases, so that the procedure terminates. Finally, we can use a variation of
this rewrite rule to remove Hadamard edges from a pivot to a spider outside its
parity set: </p><table class='equation-star'><tr><td>
<!-- l. 1007 --><object data="svgs/AP-CZ-push-outside.svg" alt="diagram of AP-CZ-push-outside" class="svg-diagram"></object></td></tr></table>
<!-- l. 1010 --><p class='indent'>   Note that this rewrite can introduce new Hadamard edges to the pivot of the
other parity set, namely when we apply the rewrite rule to two pivots that are
connected to each other. However, the rewrite rule either decreases the total
number of edges that are connected to a pivot <span class='cmti-10x-x-109'>or </span>it decreases the number of
pivots that are connected to each other, so that we can always keep applying it
and it will always reduce one of these metrics, so that the procedure does
terminate. In the end when we can no longer apply the rewrite rule anywhere, it
must mean that there are no Hadamard edges attached to a pivot in the
diagram.
</p>
                                                                     

                                                                     
   <div class='newtheorem'>
<!-- l. 1011 --><p class='noindent'><span class='head'>
<a id='x7-124006r5'></a>
<span class='cmbx-10x-x-109'>Remark 5.5.5.</span>  </span>The previous phase-removal and edge-removal rewrites also
apply when the pivot spider is the only spider in its parity set, but then these
rewrites become quite trivial: </p><table class='equation-star'><tr><td>
<!-- l. 1013 --><object data="svgs/AP-remove-phase.svg" alt="diagram of AP-remove-phase" class="svg-diagram"></object></td></tr></table>
   </div>
<!-- l. 1016 --><p class='indent'>    We conclude then that we get a diagram in reduced AP form.
</p>
   <div class='newtheorem'>
<!-- l. 1018 --><p class='noindent'><span class='head'>
<a id='x7-124007r6'></a>
<span class='cmbx-10x-x-109'>Proposition 5.5.6.</span>  </span>Any  diagram  in  AP  form  can  be  transformed  to
reduced AP form.
</p>
   </div>
<!-- l. 1020 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 1021 --><p class='noindent'><span class='head'>
<a id='x7-124008r7'></a>
<span class='cmbx-10x-x-109'>Theorem 5.5.7.</span>  </span> The ZX-calculus is complete for Clifford diagrams.
                                                                     

                                                                     
</p>
   </div>
<!-- l. 1023 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 1025 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Suppose we have two diagrams <!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
and <!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
that  represent  the  same  linear  map.  Without  loss  of  generality  we  may
assume that they are states by bending all the wires to the right. We can
rewrite the diagrams to reduced AP forms <!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>′</mi></mrow></msubsup></math>,
respectively <!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup></math>.
The diagrams represent the same linear map and Theorem <a href='#x7-124005r4'>5.5.4<!-- tex4ht:ref: thm:uniqueness-reduced-AP  --></a> shows that
this linear map has a unique reduced AP form associated to it, so that
<!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>′</mi></mrow></msubsup></math>
and <!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup></math>
must be the same diagram. Furthermore, by reducing the scalars in the
diagrams to a unique normal form (Theorem <a href='#x7-123002r2'>5.5.2<!-- tex4ht:ref: thm:Clifford-scalar-completeness  --></a>), we see that the scalar
parts of the diagram are also equal. We then indeed have a set of rewrites
from <!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
to <!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow></msub></math>:
first go from <!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
to <!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>′</mi></mrow></msubsup></math>,
which is equal to <!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup></math>,
and then do rewrites in reverse to go from <!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup></math>
to <!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow></msub></math>.
                                                                   □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 1027 --><p class='noindent'><span class='head'>
<a id='x7-124009r8'></a>
<span class='cmbx-10x-x-109'>Remark 5.5.8.</span>  </span>The  reader  familiar  with  stabiliser  theory  might  be
wondering how it is that we get a <span class='cmti-10x-x-109'>unique </span>normal form for Clifford states,
as there is no really ‘canonical’ way to do this. The trick is that we fully
Gaussian eliminate the parity matrix. This procedure makes a distinction
between the qubits: the first qubit is much more ‘likely’ to be a pivot than
the last qubit. A state that is symmetric in the qubits hence would not
necessarily be reduced to a symmetric unique normal form (try to construct
                                                                     

                                                                     
for instance the reduced AP form of the GHZ state).
</p>
   </div>
<!-- l. 1029 --><p class='indent'>    You might wonder how these reduced AP forms relate to graph states. We
have already seen that we can transform a state in AP form to one in GSLC form
by doing some boundary pivots. If the diagram is in <span class='cmti-10x-x-109'>reduced </span>AP form, the
translation is even simpler: since for every internal spider we have a pivot spider
that does not have a phase, it’s Z-spider is actually an identity, and we can do
some identity removal and colour change to turn it into a GSLC state:
</p><table class='equation-star'><tr><td>
<!-- l. 1031 --><object data="svgs/reduced-AP-to-GSLC.svg" alt="diagram of reduced-AP-to-GSLC" class="svg-diagram"></object></td></tr></table>
<!-- l. 1034 --><p class='indent'>   We see that that every internal spider in AP form translates into a
Hadamard on the output of its corresponding pivot in the resulting graph
state.
</p>
   <h3 class='sectionHead' id='summary-what-to-remember3'><span class='titlemark'>5.6   </span> <a id='x7-1250005.6'></a>Summary: What to remember</h3>
<!-- l. 1037 --><p class='noindent'>
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 1037 --><p class='noindent'>Clifford <span class='cmti-10x-x-109'>circuits </span>are circuits consisting of CNOT, Hadamard and <!-- l. 1037 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
     gates. Clifford <span class='cmti-10x-x-109'>states </span>are the quantum states that can be produced by
     starting with <!-- l. 1037 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     and then applying a Clifford circuit to it.
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 1038 --><p class='noindent'>Clifford circuits are represented by ZX-diagrams where all the phases
     are multiples of <!-- l. 1038 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>.
     We call these diagrams <span class='cmti-10x-x-109'>Clifford diagrams</span>.
                                                                     

                                                                     
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 1039 --><p class='noindent'>Any  Clifford  diagram  that  is  unitary  can  be  written  as  a  Clifford
     circuit.
     </p></dd><dt class='enumerate'>
  4.. </dt><dd class='enumerate'>
     <!-- l. 1040 --><p class='noindent'>We can efficiently simplify Clifford diagrams by the graph-theoretic
     operations of local complementation and pivoting.
     </p></dd><dt class='enumerate'>
  5.. </dt><dd class='enumerate'>
     <!-- l. 1041 --><p class='noindent'>This allows us to
        </p><dl class='enumerate'><dt class='enumerate'>
     a) </dt><dd class='enumerate'>
        <!-- l. 1043 --><p class='noindent'>reduce each Clifford circuit to a normal-form consisting of just a few
        layers of Hadamard, <!-- l. 1043 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>,
        CNOT and CZ gates,
        </p></dd><dt class='enumerate'>
     b) </dt><dd class='enumerate'>
        <!-- l. 1044 --><p class='noindent'>write each Clifford state in the <span class='cmti-10x-x-109'>affine with phases </span>form,
        </p></dd><dt class='enumerate'>
     c) </dt><dd class='enumerate'>
        <!-- l. 1045 --><p class='noindent'>write each Clifford state as a <span class='cmti-10x-x-109'>graph state with local Cliffords</span>,
        </p></dd><dt class='enumerate'>
     d) </dt><dd class='enumerate'>
        <!-- l. 1046 --><p class='noindent'>efficiently calculate amplitudes of Clifford states,
        </p></dd><dt class='enumerate'>
     e) </dt><dd class='enumerate'>
        <!-- l. 1047 --><p class='noindent'>efficiently calculate marginal probabilities of Clifford states (<span class='cmti-10x-x-109'>strong</span>
        simulation),
        </p></dd><dt class='enumerate'>
     f) </dt><dd class='enumerate'>
        <!-- l. 1048 --><p class='noindent'>efficiently  sample  measurement  outcomes  from  a  Clifford  state
        (<span class='cmti-10x-x-109'>weak </span>simulation). </p></dd></dl>
     </dd><dt class='enumerate'>
  6.. </dt><dd class='enumerate'>
     <!-- l. 1050 --><p class='noindent'>This scalar-accurate set of rewrites of the ZX-calculus is <span class='cmti-10x-x-109'>complete </span>for
     Clifford ZX-diagrams, meaning that any two Clifford diagrams representing
     the same linear map can be rewritten into each other using these rewrite
     rules.
                                                                     

                                                                     
     </p></dd><dt class='enumerate'>
  7.. </dt><dd class='enumerate'>
     <!-- l. 1051 --><p class='noindent'>This follows from the existence of a <span class='cmti-10x-x-109'>unique normal form </span>for Clifford states
     that we call the reduced AP form. </p></dd></dl>
<!-- l. 1053 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='references-and-further-reading3'><span class='titlemark'>5.7   </span> <a id='x7-1260005.7'></a>References and further reading</h3>
<!-- l. 1054 --><p class='noindent'><span class='paragraphHead' id='classical-simulation'><a id='x7-127000'></a><span class='cmbx-10x-x-109'>Classical simulation</span></span>
   Clifford circuits were first shown to be efficiently classically simulable by
[<a href='main_htmlli2.html#Xgottesman1998heisenberg'>113</a>], using what he called the <span class='cmti-10x-x-109'>Heisenberg representation</span>, which is now more
commonly called the stabiliser representation or stabiliser tableau. We
will go into detail on this structure in Chapter <a href='main_htmlch6.html#stabiliser-theory'>6<!-- tex4ht:ref: ch:stabiliser  --></a>. Notably, the classical
simulation theorem itself appears in this single-author paper by Gottesman as
“Knill’s theorem”, crediting Knill with the idea. These days it is called the
<span class='cmbx-10x-x-109'>Gottesman-Knill theorem</span>.
</p>
<!-- l. 1057 --><p class='noindent'><span class='paragraphHead' id='circuit-normal-forms'><a id='x7-128000'></a><span class='cmbx-10x-x-109'>Circuit normal forms</span></span>
   The first Clifford circuit synthesis algorithm was given by [<a href='main_htmlli2.html#Xaaronsongottesman2004'>1</a>], which
produced a circuit with 11 layers of distinct gate types. This was subsequently
improved to more compact forms [<a href='main_htmlli2.html#Xdehaene2003clifford'>79</a>, <a href='main_htmlli2.html#Xvandennest2010classical'>226</a>, <a href='main_htmlli2.html#Xmaslov2018shorter'>170</a>]. The shallowest decompositions,
at the time of this writing, are due to [<a href='main_htmlli2.html#Xmaslov2022depth'>171</a>] have a 2-qubit gate depth of
<!-- l. 1058 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --></mrow><mrow><mn>2</mn></mrow></msup><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
</p>
<!-- l. 1059 --><p class='noindent'><span class='paragraphHead' id='graph-states-with-local-cliffords'><a id='x7-129000'></a><span class='cmbx-10x-x-109'>Graph states with local Cliffords</span></span>
   The GSLC form for Clifford ZX diagrams is based on a result by [<a href='main_htmlli2.html#Xvandennest2004graphical'>227</a>],
who showed that any stabiliser state, i.e. any state prepared from
<!-- l. 1060 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo>…</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> using
a Clifford circuit, can be expressed as a graph state with local Cliffords. The
definition of GSLC form for ZX diagrams is due to [<a href='main_htmlli2.html#XBackensCompleteness'>19</a>], who used it to prove
completeness of the Clifford ZX calculus. The reduction of an arbitrary diagram
to GSLC form is from [<a href='main_htmlli2.html#Xduncan2019graph'>88</a>].
</p>
<!-- l. 1061 --><p class='noindent'><span class='paragraphHead' id='local-complementation'><a id='x7-130000'></a><span class='cmbx-10x-x-109'>Local complementation</span></span>
   Local complementation, as a purely graph-theoretic concept, goes back
to [<a href='main_htmlli2.html#Xkotzig'>158</a>]. It’s relevance to quantum computing originates with [<a href='main_htmlli2.html#XNestMBQC'>225</a>], who showed
that two graph states are equal up to local Cliffords if and only if one
                                                                     

                                                                     
graph can be transformed into the other via local complementations. [<a href='main_htmlli2.html#Xelliott2008graphical'>94</a>]
showed that, furthermore, this sequence of local complementations can
be found efficiently. The local complementation rule was proved in the
ZX-calculus by [<a href='main_htmlli2.html#XDP1'>90</a>]. A more accessible proof is provided in Ref. [<a href='main_htmlli2.html#XCKbook'>62</a>,
Prop. 9.125]. The pivoting rule was introduced for ZX diagrams by [<a href='main_htmlli2.html#Xduncan2013pivoting'>92</a>], where it
was used to show completeness of the “real stabiliser” fragment of the
ZX-calculus, i.e. for ZX diagrams generated by phase-free spiders and the
Hadamard gate. The simplification-versions of local complementation and
pivot rules (i.e. the ones that delete spiders) were introduced by [<a href='main_htmlli2.html#Xduncan2019graph'>88</a>] to
simplify non-Clifford circuits, and with some additional variations on
the pivoting rule, they were used in [<a href='main_htmlli2.html#Xwetering-gflow'>23</a>] to simplify MBQC patterns
(though note that the idea that ’a pivot deletes vertices’ was also present
in [<a href='main_htmlli2.html#Xmhalla_hal-00934104'>178</a>]).
</p>
<!-- l. 1065 --><p class='noindent'><span class='paragraphHead' id='ap-normal-form'><a id='x7-131000'></a><span class='cmbx-10x-x-109'>AP normal form</span></span>
   The AP form and reduced AP form were introduced in a preprint of this book
in 2022 to give, among other things, a simplified proof of Clifford completeness. It
first appears in published form in [<a href='main_htmlli2.html#XPoor2022Masters'>192</a>] for the case of odd-prime-dimensional
qudits. A circuit decomposition for Clifford state preparations, which is closely
related to the AP normal form, appears more than ten years earlier, in a
classical simulation paper by [<a href='main_htmlli2.html#Xvandennest2010classical'>226</a>].     </p><!-- l. 11 --><div class='crosslinks'><p class='noindent'>[<a href='main_htmlch6.html'>next</a>] [<a href='main_htmlch4.html'>prev</a>] [<a href='main_htmlch4.html#tailmain_htmlch4.html'>prev-tail</a>] [<a href='main_htmlch5.html'>front</a>] [<a href='main_html.html#main_htmlch5.html'>up</a>]
</p></div>
<!-- l. 11 --><p class='indent'>   <a id='tailmain_htmlch5.html'></a></p> 
<script type="text/javascript" src="proof_collapse.js"></script> 
<script type="text/javascript" src="navigation_menu.js"></script> </body> 
</html>