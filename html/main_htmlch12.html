<!DOCTYPE html> 
<html lang='en-US' xml:lang='en-US'> 
<head><title>12 Quantum error correction</title> 
<meta charset='utf-8' /> 
<meta content='TeX4ht (https://tug.org/tex4ht/)' name='generator' /> 
<meta content='width=device-width,initial-scale=1' name='viewport' /> 
<link href='main_html.css' rel='stylesheet' type='text/css' /> 
<meta content='main_html.tex' name='src' /> 
 <script async='async' id='MathJax-script' src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-chtml.js' type='text/javascript'></script>  
</head><body>
   <!-- l. 7 --><div class='crosslinks'><p class='noindent'>[<a href='main_htmlli3.html'>next</a>] [<a href='main_htmlch11.html'>prev</a>] [<a href='main_htmlch11.html#tailmain_htmlch11.html'>prev-tail</a>] [<a href='#tailmain_htmlch12.html'>tail</a>] [<a href='main_html.html#main_htmlch12.html'>up</a>] </p></div>
   <h2 class='chapterHead' id='quantum-error-correction'><span class='titlemark'>Chapter 12</span><br /><a id='x15-27600012'></a>Quantum error correction</h2>
<!-- l. 8 --><p class='noindent'>Classical error correction is ubiquitous in modern computing. The basic idea is to
pad out a message we want to send with some extra redundant data, which give
us enough info to recover the original message as long as no (catastrophically
bad) errors occurred. In the 1990s, people started to notice that many of the
same concepts could be applied to quantum data. Namely, by encoding some
qubits into a higher-dimensional system and making careful choices of
measurements, we can often detect whether errors occurred and even correct
them (again if they are not too bad). One of the key ideas behind quantum error
correction is identifying analogous notions between classical, linear, error
correction and stabiliser theory. We have already seen in previous chapters that
there are several deep connections between stabiliser (i.e. Clifford) states and
<!-- l. 9 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>-linear structures, and it
just so happens that <!-- l. 9 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>-linear
structures are the bread and butter of classical error correction. In this
chapter, we will start to cash out these connections and show how quantum
error correction can be done in a way that is, in many ways, similar to
its classical counterpart. For example, if I want to send you three bits,
<!-- l. 10 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> and actually I
send you six bits <!-- l. 10 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>z</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
then I can always recover the original message even if one of these six bits gets
flipped. In this simple example, we encode our message (an element of
<!-- l. 10 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mn>3</mn></mrow></msubsup></math>) into a 3D
subspace <!-- l. 10 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>z</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='thinspace' width='0.17em'></mspace><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>z</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-rel' stretchy='false'>∈</mo> <msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
of <!-- l. 10 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mn>6</mn></mrow></msubsup></math>
called the <span class='cmbx-10x-x-109'>codespace</span>. If a single error occurs in such an encoded bit string, it
leaves the codespace, so we can detect it just by checking if the last three bits are
indeed the correct parities of the first three. Furthermore, there is at most 1
element in the codespace that is within 1 bit flip of any string of six
bits, so we can actually <span class='cmti-10x-x-109'>correct </span>a single error. Hence, a major aspect of
designing good error correcting codes is finding particular subspaces of
<!-- l. 10 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msubsup></math>
that have nice properties like this, as we’ll discuss in Section <a href='#classical-codes-and-parameters'>12.1<!-- tex4ht:ref: sec:distance  --></a>.
Quantum error correcting codes can be defined as subspaces of
<!-- l. 11 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>ℂ</mi><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>n</mi></mrow></math> , the space
of <!-- l. 11 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> qubits,
which have analogous nice properties. Unlike the classical case, these are going to be huge
<!-- l. 11 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℂ</mi></math>-linear subspaces, namely
<!-- l. 11 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup></math>-dimensional subspaces
of the <!-- l. 11 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></math>-dimensional
space <!-- l. 11 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>ℂ</mi><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>n</mi></mrow></math> . As
a result, it is not practical to work with these spaces explicitly (e.g by enumerating a
                                                                     

                                                                     
spanning set of vectors). However, as we have already seen in Chapter <a href='main_htmlch6.html#stabiliser-theory'>6<!-- tex4ht:ref: ch:stabiliser  --></a>, stabiliser
theory gives us a powerful tool for efficiently representing complicated subspaces
of <!-- l. 11 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>ℂ</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>n</mi></mrow></msup></math>.
Thanks to the <span class='cmbx-10x-x-109'>Fundamental Theorem of Stabiliser Theory</span>, we can fix a
<!-- l. 11 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup></math>-dimensional
stabiliser subspace of <!-- l. 11 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>ℂ</mi><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>n</mi></mrow></math>
by giving <!-- l. 11 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>k</mi></mrow></math>
independent generators of the stabiliser group.
</p>
   <h3 class='sectionHead' id='classical-codes-and-parameters'><span class='titlemark'>12.1   </span> <a id='x15-27700012.1'></a>Classical codes and parameters</h3>
<!-- l. 14 --><p class='noindent'>Let’s look again at the codespace </p><table class='equation'><tr><td>
<!-- l. 15 --><p class='indent'>
</p><!-- l. 15 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
           <mstyle class='label' id='x15-277001r1'></mstyle><!-- endlabel --><mi>S</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>z</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='thinspace' width='0.17em'></mspace><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>z</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-rel' stretchy='false'>∈</mo> <msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo><mo class='MathClass-rel' stretchy='false'>⊆</mo> <msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mn>6</mn></mrow></msubsup>
</mrow></math></td><td class='eq-no'>(12.1)</td></tr></table>
<!-- l. 18 --><p class='indent'>   We claimed before that <!-- l. 18 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
can correct a single error. That is, if I start with a vector in
<!-- l. 18 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
and flip 1 bit, this vector will no longer be in
<!-- l. 18 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>, and furthermore, there
is a unique vector in <!-- l. 18 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
that is one bit-flip way. For example, if I receive the string:
<!-- l. 18 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>, I can tell there is an
error somewhere, since <!-- l. 18 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>y</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
and <!-- l. 18 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>z</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>,
but <!-- l. 18 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>.
It could be that either my first 3 data bits are wrong, or it could
be that the parity bits are wrong. However, there is only one way
to satisfy all the parities by flipping a <span class='cmti-10x-x-109'>single </span>bit, namely setting
<!-- l. 18 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>z</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>. Similarly, if I
look at a string <!-- l. 18 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
the only possibility for a single-bit error is that the final parity bit
<!-- l. 18 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math> is wrong.
Since <!-- l. 19 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
                                                                     

                                                                     
is a linear subspace, it turns out we can succinctly capture the property of being
able to detect any of some family of errors (e.g. single bit-flips) and to correct
those errors in a single concept called code distance.
</p>
   <div class='newtheorem'>
<!-- l. 20 --><p class='noindent'><span class='head'>
<a id='x15-277002r1'></a>
<span class='cmbx-10x-x-109'>Definition 12.1.1.</span>  </span>For a linear subspace <!-- l. 21 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi> <mo class='MathClass-rel' stretchy='false'>⊆</mo> <msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msubsup></mrow></math>,
the <span class='cmbx-10x-x-109'>code distance </span>of <!-- l. 21 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
is the smallest non-zero Hamming weight of a vector in <!-- l. 21 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>.
</p>
   </div>
<!-- l. 22 --><p class='indent'>    Suppose we could flip a single bit of a vector
<!-- l. 23 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>S</mi></mrow></math> and obtain
another vector <!-- l. 23 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>S</mi></mrow></math>.
Then, their sum <!-- l. 23 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-bin' stretchy='false'>⊕</mo><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>
is also in <!-- l. 23 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>,
and it would just be a unit vector consisting of a single 1 in the location of the
flipped bit, e.g. </p><table class='equation-star'><tr><td>
<!-- l. 24 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                   <mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo>
</mrow></math></td></tr></table>
<!-- l. 27 --><p class='indent'>   The same applies if we flip <!-- l. 27 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math>
bits: the sum will have 1’s in precisely the locations of the flipped bits. So, saying that
flipping <!-- l. 27 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math>
bits leaves <!-- l. 27 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
is the same thing as saying there is no vector in
<!-- l. 27 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> with Hamming
weight <!-- l. 27 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math>. In other
words, a space <!-- l. 27 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
with code distance <!-- l. 27 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math>
can detect any amount of errors strictly less than
                                                                     

                                                                     
<!-- l. 27 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math>. It is
also the case that being able to <span class='cmti-10x-x-109'>correct </span>a given number of errors can
be stated in terms of the code distance. We noted before that the code
<!-- l. 28 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
in (<a href='#x15-277001r1'>12.1<!-- tex4ht:ref: eq:codespace-ex  --></a>) has the property that, if we take any vector
<!-- l. 28 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>S</mi></mrow></math> and flip a single bit,
there is no other vector <!-- l. 28 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>S</mi></mrow></math>
that is a single bit-flip away. In other words, there are no two vectors
<!-- l. 28 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>S</mi></mrow></math> that are two bit-flips
apart, or equivalently, <!-- l. 28 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
has a code distance of (at least) 3. In fact, the code distance is exactly
3, which we can see by enumerating all 8 vectors in this 3D subspace:
</p><table class='equation-star'><tr><td>
<!-- l. 29 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mi>S</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mrow><mo fence='true' form='prefix'>{</mo><mrow> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>,</mo> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>,</mo> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>,</mo> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>,</mo> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>,</mo> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>,</mo> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>,</mo> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow> </mrow><mo fence='true' form='postfix'>}</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 41 --><p class='indent'>   and noting that all the non-zero vectors have Hamming weight
3 or more. This is a general feature: any code with distance
<!-- l. 41 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>d</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>2</mn><mi>e</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn></mrow></math>
can always correct an error consisting of at most
<!-- l. 41 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>e</mi></math> bit flips.
To move toward the quantum analogue of classical linear codes, we can proceed
by thinking of stabiliser measurements as analogous to classical parity checks. As
we already mentioned, for classical codes, we can very quickly check whether
<!-- l. 42 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>S</mi></mrow></math> by taking XORs of
certain bits. For the code <!-- l. 42 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
in (<a href='#x15-277001r1'>12.1<!-- tex4ht:ref: eq:codespace-ex  --></a>), then <!-- l. 42 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>v</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>v</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>v</mi></mrow><mrow><mn>4</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>v</mi></mrow><mrow><mn>5</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>v</mi></mrow><mrow><mn>6</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
is in <!-- l. 42 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
precisely when the following linear equations are satisfied: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 43 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
 <mtable align='axis' class='array' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>v</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>v</mi></mrow><mrow><mn>4</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn> </mtd>
</mtr>  <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>v</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>v</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>v</mi></mrow><mrow><mn>5</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn> </mtd>
</mtr>  <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>v</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>v</mi></mrow><mrow><mn>6</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn> </mtd></mtr><!-- c --></mtable>
</mrow></math></td></tr></table>
<!-- l. 50 --><p class='indent'>   As we saw in Chapter <a href='main_htmlch4.html#cnot-circuits-and-phasefree-zxdiagrams'>4<!-- tex4ht:ref: ch:phasefree  --></a>, given a system of homogeneous
<!-- l. 50 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>-linear equations fixing
a linear subspace <!-- l. 50 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
essentially the same as giving a spanning set for
<!-- l. 50 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></math>. In
this case, this is: </p><table class='equation-star'><tr><td>
<!-- l. 51 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow>
<mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext class='textrm' mathvariant='normal'>Span</mtext></mstyle> <mrow><mo fence='true' form='prefix'>{</mo><mrow> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>,</mo> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>,</mo> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow> </mrow><mo fence='true' form='postfix'>}</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 58 --><p class='indent'>   To check <!-- l. 58 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>S</mi></mrow></math>, it suffices
to check <!-- l. 58 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow><mrow><mi>T</mi> </mrow></msubsup><mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math> for each
of the basis vectors <!-- l. 58 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></math>
of <!-- l. 58 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></math>.
If this holds, then we can be sure no error of weight
<!-- l. 58 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>d</mi></mrow></math> has
occurred. If <!-- l. 58 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow><mrow><mi>T</mi> </mrow></msubsup><mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>,
this is called a <span class='cmbx-10x-x-109'>syndrome</span>, because it indicates that there is an error somewhere
in <!-- l. 58 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover></math>.
</p>
   <h3 class='sectionHead' id='quantum-stabiliser-codes'><span class='titlemark'>12.2   </span> <a id='x15-27800012.2'></a>Quantum stabiliser codes</h3>
<!-- l. 60 --><p class='noindent'>In this section, we’ll expand on the analogy between parity checks
and stabiliser measurements, and show how to define the notion
of code distance for a stabiliser subspace. Fix a stabiliser group
<!-- l. 60 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>S</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> with associated
                                                                     

                                                                     
stabiliser subspace <!-- l. 60 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi> <mo class='MathClass-rel' stretchy='false'>⊆</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>ℂ</mi><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>n</mi></mrow></math>.
Since we can use stabiliser subspaces to correct errors, we will from henceforth
use the terms stabiliser subspace and <span class='cmbx-10x-x-109'>stabiliser code </span>interchangeably.
This is analogous to the classical case, where we referred to subspaces of
<!-- l. 60 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msubsup></math> as codes.
Thanks to the Fundamental Theorem of Stabiliser Theory from Chapter <a href='main_htmlch6.html#stabiliser-theory'>6<!-- tex4ht:ref: ch:stabiliser  --></a>, we know
that <!-- l. 61 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> is
<!-- l. 61 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup></math>-dimensional,
for <!-- l. 61 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>m</mi></mrow></math>.
Hence, we can think of the stabiliser subspace as encoding
<!-- l. 61 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> <span class='cmbx-10x-x-109'>logical
qubits </span>in <!-- l. 61 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
physical qubits. This gives us quantum analogues to the parameters
<!-- l. 61 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> and
<!-- l. 61 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> from
classical codes. To build up to the notion of code distance, let’s have a look at how we
can use <!-- l. 61 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>
to detect and correct errors. We can treat the generators of
<!-- l. 62 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math> as
“quantum parity checks” in a very specific way. If we measure an arbitrary state
<!-- l. 62 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∈</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>ℂ</mi><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>n</mi></mrow></math> with
one of stabiliser generators, we can compute the Born rule probability as:
</p><table class='equation-star'><tr><td>
<!-- l. 63 --><object data="svgs/stab-born.svg" alt="diagram of stab-born" class="svg-diagram"></object></td></tr></table>
<!-- l. 66 --><p class='indent'>   If we restrict to the case where <!-- l. 66 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>S</mi></mrow></math>,
then <!-- l. 66 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, then by
Proposition <a href='main_htmlch6.html#x9-136002r2'>6.2.2<!-- tex4ht:ref: prop:pauli-proj  --></a> we know <!-- l. 66 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='normal'>Π</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo><msub><mrow>
<mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
Hence: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 67 --><object data="svgs/stab-born-0.svg" alt="diagram of stab-born-0" class="svg-diagram"></object></td></tr></table>
<!-- l. 70 --><p class='indent'>   So, we will always get outcome <!-- l. 70 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>s</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>
if no error occurred on <!-- l. 70 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
From this, we can also conclude that we’ll never get outcome
<!-- l. 70 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>s</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>:
</p><table class='equation-star'><tr><td>
<!-- l. 71 --><object data="svgs/stab-born-1.svg" alt="diagram of stab-born-1" class="svg-diagram"></object></td></tr></table>
<!-- l. 74 --><p class='indent'>   Now, suppose an error <span class='cmti-10x-x-109'>does  </span>occur on
<!-- l. 74 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. For
simplicity, we’ll initially assume that this error takes the form of a self-adjoint Pauli
string <!-- l. 74 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math>.
In Section <a href='#detecting-and-correcting-quantum-errors'>12.2.2<!-- tex4ht:ref: sec:detect-and-correct  --></a>, we’ll show that arbitrary errors can be reduced to this case.
Namely, if we can detect/correct Pauli errors, then we can detect/correct
arbitrary errors. There are two possibilities, either the error commutes with
<!-- l. 75 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math> or it anti-commutes
with <!-- l. 75 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math>. These
two possibilities translate into the following commutation rule with respect to the
Pauli box <!-- l. 75 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math>.
</p>
   <div class='newtheorem'>
<!-- l. 76 --><p class='noindent'><span class='head'>
<a id='x15-278001r1'></a>
<span class='cmbx-10x-x-109'>Exercise 12.1.</span>  </span> Show that: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 78 --><object data="svgs/pauli-box-comm.svg" alt="diagram of pauli-box-comm" class="svg-diagram"></object></td></tr></table>
<!-- l. 81 --><p class='indent'>   where <!-- l. 81 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>
if <!-- l. 81 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>
and <!-- l. 81 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
if <!-- l. 81 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>.
</p>
   </div>
<!-- l. 82 --><p class='indent'>    As a consequence of Exercise <a href='#x15-278001r1'>12.1<!-- tex4ht:ref: exer:pauli-box-comm  --></a>, if a commuting error
<!-- l. 83 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math> happens to
<!-- l. 83 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, the outcome
of measuring <!-- l. 83 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>j</mi></mrow></msub></math>
is unaffected: </p><table class='equation-star'><tr><td>
<!-- l. 84 --><object data="svgs/born-error.svg" alt="diagram of born-error" class="svg-diagram"></object></td></tr></table>
<!-- l. 87 --><p class='indent'>   So, <!-- l. 87 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>Prob</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>s</mi></mrow><mrow><mi>j</mi></mrow></msub><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='thinspace' width='0.17em'></mspace><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext class='textrm' mathvariant='normal'>Prob</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>s</mi></mrow><mrow><mi>j</mi></mrow></msub><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. Hence, we’ll
again get outcome <!-- l. 87 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>s</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math> with
certainty. However, if <!-- l. 87 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math>
anti-commutes with <!-- l. 87 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>j</mi></mrow></msub></math>,
it kicks a <!-- l. 87 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
up into the measurement outcome, so the probabilities flip: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 88 --><object data="svgs/born-error-2.svg" alt="diagram of born-error-2" class="svg-diagram"></object></td></tr></table>
<!-- l. 91 --><p class='indent'>   Hence, we’ll get outcome <!-- l. 91 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>s</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math> with
certainty. We can measure all <!-- l. 92 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>m</mi></math>
stabilisers generating <!-- l. 92 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>.
Since all of the stabilisers commute, we can either think of doing each of
these measurements in sequence (where the order doesn’t matter), or
equivalently, doing one big measurement whose outcome is given by:
</p><table class='equation-star'><tr><td>
<!-- l. 93 --><object data="svgs/stab-born-group.svg" alt="diagram of stab-born-group" class="svg-diagram"></object></td></tr></table>
<!-- l. 96 --><p class='indent'>   If <!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> is of
the form <!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ϕ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> for
some state <!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ϕ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
in the stabiliser subspace and some (possibly trivial) Pauli error
<!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math>,
this will yield some particular bitstring of outcomes with certainty. If
<!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>, the outcome will always
be <!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>s</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>s</mi></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. Hence, each time
<!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>s</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>, this indicates that (1)
some non-trivial error <!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math>
has occurred, and (2) that error anti-commutes with the
<!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>-th stabiliser
<!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>j</mi></mrow></msub></math>. By analogy
to the classical case, this vector of measurement outcomes is called the <span class='cmbx-10x-x-109'>syndrome</span>.
If we are lucky, this syndrome will provide us with enough information to send
                                                                     

                                                                     
<!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> back to the
error free state <!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ϕ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
For example, if it uniquely fixes the Pauli string
<!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math>,
that is definitely good enough, because we can then just apply
<!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math> again to get
<!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><msup><mrow> <mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ϕ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>ϕ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. However, we don’t even
need to hit <!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math> on-the-nose,
because if we correct <!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
with some <!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>′</mi></mrow></msup></math> that is
the product of <!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math> and
some stabiliser <!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo><mstyle mathvariant='script'><mi>S</mi></mstyle></mrow></math>,
we get: </p><table class='equation-star'><tr><td>
<!-- l. 98 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow>
            <mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ϕ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∝</mo><msup><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msup><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ϕ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ϕ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>ϕ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td></tr></table>
<!-- l. 101 --><p class='indent'>   So, we again recover the state <!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ϕ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
possibly up to an irrelevant global phase. Lets see how this works by means of a
simple example. Consider the following stabiliser group on three qubits:
</p><table class='equation-star'><tr><td>
<!-- l. 103 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
               <mstyle mathvariant='script'><mi>S</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td></tr></table>
<!-- l. 106 --><p class='indent'>   <!-- l. 106 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math> has two independent
stabilisers, so <!-- l. 106 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi class='qopname'>dim</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='text'><mtext>Stab</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mn>2</mn></mrow><mrow><mn>3</mn><mo class='MathClass-bin' stretchy='false'>−</mo><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>2</mn></mrow></math>.
Hence, this code, called the <span class='cmbx-10x-x-109'>GHZ code </span>encodes one qubit into three. Fixing a basis
                                                                     

                                                                     
for <!-- l. 106 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>Stab</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
we have </p><table class='equation-star'><tr><td>
<!-- l. 107 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                     <mstyle class='text'><mtext>Stab</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext class='textrm' mathvariant='normal'>Span</mtext></mstyle><mo class='MathClass-open' stretchy='false'>{</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>000</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>111</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>}</mo>
</mrow></math></td></tr></table>
<!-- l. 110 --><p class='indent'>   For the following discussion, it will be conventient to write
<!-- l. 110 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>Stab</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> as
the image of a map from one qubit into three qubits, called the <span class='cmbx-10x-x-109'>encoder </span>of
<!-- l. 110 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>. We
will say more about encoders in the following sections, including how to build
them from stabiliser codes. But for now, note that: </p><table class='equation'><tr><td>
<!-- l. 111 --><p class='indent'>
</p><!-- l. 111 --><object id='x15-278002r2' data="svgs/eq-ghz-encoder.svg" alt="diagram of eq:ghz-encoder" class="svg-diagram"></object></td><td class='eq-no'>(12.2)</td></tr></table>
<!-- l. 114 --><p class='indent'>   It thus follows that: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 115 --><object data="svgs/ghz-encoder.svg" alt="diagram of ghz-encoder" class="svg-diagram"></object></td></tr></table>
<!-- l. 118 --><p class='indent'>   Hence, we can write a generic state
<!-- l. 118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi mathvariant='normal'>Ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∈</mo><mstyle class='text'><mtext>Stab</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> as:
</p><table class='equation-star'><tr><td>
<!-- l. 119 --><object data="svgs/ghz-encoded.svg" alt="diagram of ghz-encoded" class="svg-diagram"></object></td></tr></table>
<!-- l. 122 --><p class='indent'>   As before, we can look at the Born rule probabilities associated with measuring the stabiliser
generators <!-- l. 122 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></math> and
<!-- l. 122 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></math>. As was shown in
Exercise <a href='main_htmlch6.html#x9-136022r7'>6.7<!-- tex4ht:ref: exer:zzz-xxx-meas  --></a>, all-<!-- l. 122 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
and all-<!-- l. 122 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
Pauli projectors take a particularly simple form: </p><table class='equation-star'><tr><td>
<!-- l. 123 --><object data="svgs/pproj-zzz-1.svg" alt="diagram of pproj-zzz-1" class="svg-diagram"></object></td></tr></table>
<!-- l. 126 --><p class='indent'>   This generalises to Pauli strings formed just from
<!-- l. 126 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math> and
<!-- l. 126 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>I</mi></math> (or
just <!-- l. 126 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
                                                                     

                                                                     
and <!-- l. 126 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>I</mi></math>)
by connecting the projector to just the subset of qubits were a
<!-- l. 126 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math> (or
<!-- l. 126 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>)
appears. For example, we have: </p><table class='equation-star'><tr><td>
<!-- l. 127 --><object data="svgs/pproj-zzi.svg" alt="diagram of pproj-zzi" class="svg-diagram"></object></td></tr></table>
<!-- l. 130 --><p class='indent'>   Applying <!-- l. 130 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='normal'>Π</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>k</mi><mo class='MathClass-close' stretchy='false'>)</mo>
<mi mathvariant='italic'>ZZI</mi></mrow></math>
to an encoded state: </p><table class='equation-star'><tr><td>
<!-- l. 131 --><object data="svgs/ghz-noerror-eigen.svg" alt="diagram of ghz-noerror-eigen" class="svg-diagram"></object></td></tr></table>
<!-- l. 134 --><p class='indent'>   we see that, as expected: </p><table class='equation-star'><tr><td>
<!-- l. 135 --><object data="svgs/ghz-encoded-1.svg" alt="diagram of ghz-encoded-1" class="svg-diagram"></object></td></tr></table>
                                                                     

                                                                     
<!-- l. 138 --><p class='indent'>   By symmetry, we see the same probabilities for measuring
<!-- l. 138 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi></mrow></math>.
This is consistent with what we saw before: measuring states in
<!-- l. 138 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>Stab</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> with the
generators of <!-- l. 138 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>
will leave the states unchanged, and yield outcome 0 with probability 1. However,
suppose we introduce an error to our encoded state, such as a ‘bit flip’, i.e. a Pauli
<!-- l. 139 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math> applied to the
first qubit. Since <!-- l. 139 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi></mrow></math>
anti-commutes we <!-- l. 139 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi></mrow></math>,
we get: </p><table class='equation-star'><tr><td>
<!-- l. 140 --><object data="svgs/ghz-error-eigen.svg" alt="diagram of ghz-error-eigen" class="svg-diagram"></object></td></tr></table>
<!-- l. 143 --><p class='indent'>   Hence the Born rule probabilities are flipped: </p><table class='equation-star'><tr><td>
<!-- l. 144 --><object data="svgs/ghz-encoded-error.svg" alt="diagram of ghz-encoded-error" class="svg-diagram"></object></td></tr></table>
<!-- l. 147 --><p class='indent'>   so we obtain <!-- l. 147 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>s</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
for out first syndrome bit. On the other hand, if we measure
<!-- l. 148 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi></mrow></math> instead, this
commutes with <!-- l. 148 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi></mrow></math>,
so: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 149 --><object data="svgs/ghz-error2-eigen.svg" alt="diagram of ghz-error2-eigen" class="svg-diagram"></object></td></tr></table>
<!-- l. 152 --><p class='indent'>   so we obtain outcome <!-- l. 152 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>s</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>
for the second syndrome bit. By symmetry, it is easy to check that each
of the single bit-flip errors can be associated with a unique syndrome:
</p><table class='equation-star'><tr><td>
<!-- l. 153 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
 <mtable align='axis' class='array' columnlines='none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mi>X</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi> </mtd><mtd class='array-td' columnalign='center'> <mspace class='qquad' width='2em'></mspace> <mo class='MathClass-rel' stretchy='false'>↔</mo><mspace class='qquad' width='2em'></mspace> </mtd><mtd class='array-td' columnalign='center'> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>s</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>s</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo> </mtd>
</mtr>  <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>X</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi> </mtd><mtd class='array-td' columnalign='center'> <mspace class='qquad' width='2em'></mspace> <mo class='MathClass-rel' stretchy='false'>↔</mo><mspace class='qquad' width='2em'></mspace> </mtd><mtd class='array-td' columnalign='center'> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>s</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>s</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> </mtd>
</mtr>  <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>X</mi> </mtd><mtd class='array-td' columnalign='center'> <mspace class='qquad' width='2em'></mspace> <mo class='MathClass-rel' stretchy='false'>↔</mo><mspace class='qquad' width='2em'></mspace> </mtd><mtd class='array-td' columnalign='center'> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>s</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>s</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> </mtd></mtr><!-- ccc --></mtable>
</mrow></math></td></tr></table>
<!-- l. 166 --><p class='indent'>   Hence, if any single bit-flip error occurs, we always know how to fix it.
We just need to measure the stabiliser generators and apply a Pauli
<!-- l. 166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
on the correct qubit to cancel out the error. Unfortunately, the GHZ
code is not good enough to correct arbitrary single qubit errors. Notably,
if a Pauli Z error occurs on one of the qubits (which is sometimes
called a ‘phase-flip’ error), it commutes with all of the generators of
<!-- l. 167 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>. Hence, the syndrome
will always be <!-- l. 167 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
and we’ll have no idea that the error even happened. In this sense, the GHZ code
is not very good at detecting or correcting errors. By analogy to the classical
case, this a distance-one code, meaning that there are even single-qubit
errors that can go undetected. In order to understand what this means
(and ultimately to find codes which <span class='cmti-10x-x-109'>can </span>detect and correct errors), we
will now formalise the notion of code distance for quantum stabiliser
codes.
                                                                     

                                                                     
</p>
   <h4 class='subsectionHead' id='code-distance-for-stabiliser-codes'><span class='titlemark'>12.2.1   </span> <a id='x15-27900012.2.1'></a>Code distance for stabiliser codes</h4>
<!-- l. 170 --><p class='noindent'>We saw in Section <a href='#classical-codes-and-parameters'>12.1<!-- tex4ht:ref: sec:distance  --></a> that we could quantify the number of detectable
errors using the classical code distance. We can do a similar thing for
stabiliser codes, where the following notion plays the role of the Hamming
weight.
</p>
   <div class='newtheorem'>
<!-- l. 171 --><p class='noindent'><span class='head'>
<a id='x15-279001r1'></a>
<span class='cmbx-10x-x-109'>Definition 12.2.1.</span>  </span> The <span class='cmbx-10x-x-109'>weight </span><!-- l. 172 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
of a Pauli string <!-- l. 172 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math>
is the number of non-identity Pauli operators that appear in <!-- l. 172 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math>.
</p>
   </div>
<!-- l. 173 --><p class='indent'>    For example, the Pauli string <!-- l. 174 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi></mrow></math>
has weight 2 and the identity string always has weight 0.
</p>
   <div class='newtheorem'>
<!-- l. 175 --><p class='noindent'><span class='head'>
<a id='x15-279002r2'></a>
<span class='cmbx-10x-x-109'>Exercise 12.2.</span>  </span> Show that we can bound the weight of a product of two Pauli
strings as follows: </p><table class='equation-star'><tr><td>
<!-- l. 177 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                        <mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-rel' stretchy='false'>≤</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo>
</mrow></math></td></tr></table>
   </div>
                                                                     

                                                                     
<!-- l. 178 --><p class='indent'>    Using this notion, we can quantify the number of detectable errors.
Note that an error produces a non-zero syndrome if and only if it
anti-commutes with at least one of the generators of the stabiliser
group. So, to be undetectable, it must commute with everything in
<!-- l. 179 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>.
Furthermore, we only care about errors that actually mess up the states in our
stabiliser subspace, so we shouldn’t count elements of the stabiliser group itself as
errors.
</p>
   <div class='newtheorem'>
<!-- l. 180 --><p class='noindent'><span class='head'>
<a id='x15-279003r2'></a>
<span class='cmbx-10x-x-109'>Definition 12.2.2.</span>  </span> For a stabiliser group <!-- l. 181 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>,
we define the <span class='cmbx-10x-x-109'>distance </span>of the associated stabiliser code as the minimum
weight <!-- l. 181 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>d</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
of a Pauli string <!-- l. 181 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>∉</mo><mstyle mathvariant='script'><mi>S</mi></mstyle></mrow></math>
that commutes with every element in <!-- l. 181 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>.
</p>
   </div>
<!-- l. 182 --><p class='indent'>    Note that, since <!-- l. 183 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>
is a subgroup, <!-- l. 183 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>I</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo><mstyle mathvariant='script'><mi>S</mi></mstyle></mrow></math>,
so <!-- l. 183 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math>
must have non-zero weight. Also, note that
<!-- l. 183 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math> commutes with
everything in <!-- l. 183 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>
if and only if it commutes with each of the generators, so we can efficiently decide whether
<!-- l. 183 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math> commutes with
everything in <!-- l. 183 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>.
However, like in the classical case, we cannot in general compute the code
distance efficiently, since we need to show that <span class='cmti-10x-x-109'>all </span>Pauli strings with
<!-- l. 183 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>d</mi></mrow></math> are either in
<!-- l. 183 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math> or anti-commute with
something in <!-- l. 183 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>. If a stabiliser
code has distance <!-- l. 184 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math>, it can
detect any error with <!-- l. 184 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>d</mi></mrow></math>. In other
words, it can detect up to <!-- l. 184 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>d</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
single-qubit errors. Similarly to the classical case, it can also correct up to
<!-- l. 184 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⌊</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>d</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn><mo class='MathClass-close' stretchy='false'>⌋</mo></mrow></math> errors. More
precisely, errors <!-- l. 184 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math>
with <!-- l. 184 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-rel' stretchy='false'>≤</mo><mo class='MathClass-open' stretchy='false'>⌊</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>d</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn><mo class='MathClass-close' stretchy='false'>⌋</mo></mrow></math>
are uniquely fixed, up to stabilisers.
                                                                     

                                                                     
</p>
   <div class='newtheorem'>
<!-- l. 185 --><p class='noindent'><span class='head'>
<a id='x15-279004r3'></a>
<span class='cmbx-10x-x-109'>Theorem 12.2.3.</span>  </span> Suppose <!-- l. 186 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>S</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
defines a stabiliser code with distance <!-- l. 186 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math>.
Then if two errors <!-- l. 186 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></math>,
<!-- l. 186 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></math>
with <!-- l. 186 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-rel' stretchy='false'>≤</mo><mo class='MathClass-open' stretchy='false'>⌊</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>d</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn><mo class='MathClass-close' stretchy='false'>⌋</mo></mrow></math>
yield the same syndrome <!-- l. 186 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>s</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>s</mi></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
then <!-- l. 186 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></mrow></math>
for some <!-- l. 186 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo><mstyle mathvariant='script'><mi>S</mi></mstyle></mrow></math>.
</p>
   </div>
<!-- l. 187 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 189 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>If <!-- l. 189 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>s</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>,
then <!-- l. 189 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></math>
and <!-- l. 189 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></math>
both commute with the <!-- l. 189 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>-th
stabiliser generator <!-- l. 189 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>j</mi></mrow></msub></math>,
whereas if <!-- l. 189 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>s</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>,
then they both anti-commute with <!-- l. 189 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>j</mi></mrow></msub></math>.
In either case, the product <!-- l. 189 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></mrow></math>
commutes with all of the generators of <!-- l. 189 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>.
By Exercise <a href='#x15-279002r2'>12.2<!-- tex4ht:ref: exer:weight-bound  --></a>, we know <!-- l. 189 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-rel' stretchy='false'>≤</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-rel' stretchy='false'>≤</mo> <mn>2</mn><mo class='MathClass-open' stretchy='false'>⌊</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>d</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn><mo class='MathClass-close' stretchy='false'>⌋</mo><mo class='MathClass-rel' stretchy='false'>≤</mo> <mi>d</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>.
Because <!-- l. 189 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>
has distance <!-- l. 189 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math>,
<!-- l. 189 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></mrow></math>
equals some <!-- l. 189 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo><mstyle mathvariant='script'><mi>S</mi></mstyle></mrow></math>.
Hence <!-- l. 189 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><msubsup><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></mrow></math>.
                                                                   □
</p>
   </div>
<!-- l. 191 --><p class='indent'>   So, as in the classical case, a quantum code can correct
<!-- l. 191 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>e</mi></math> errors if
                                                                     

                                                                     
<!-- l. 191 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi>e</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mi>d</mi></mrow></math>.
Putting the three parameters together, we will write
<!-- l. 191 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-open' stretchy='false'>[</mo><mi>n</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>k</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>d</mi><mo class='MathClass-close' stretchy='false'>]</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
to indicate a quantum error correcting code that encodes
<!-- l. 191 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> logical qubits in
<!-- l. 191 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> physical qubits,
with code distance <!-- l. 191 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math>.
</p>
   <div class='newtheorem'>
<!-- l. 192 --><p class='noindent'><span class='head'>
<a id='x15-279005r4'></a>
<span class='cmbx-10x-x-109'>Example 12.2.4.</span>  </span> The following 7-qubit code is called the <span class='cmti-10x-x-109'>Steane code</span>:
</p><table class='equation-star'><tr><td>
<!-- l. 194 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mtable class='aligned'><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi></mtd><mtd columnalign='right'></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>3</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></mtd> <mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></mtd> <mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>3</mn></mrow></msub></mtd> <mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi></mtd>
</mtr><mtr><mtd columnalign='right'></mtd>
   </mtr>                                                                 </mtable>
</mrow></math></td></tr></table>
<!-- l. 205 --><p class='indent'>   Since it consists of 7 physical qubits and 6 stabiliser generators, it encodes
<!-- l. 205 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>7</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>6</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
logical qubit. Any Pauli consisting of a <!-- l. 205 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
on one or two qubits anti-commutes with at least one of <!-- l. 205 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></math>
generators, whereas any Pauli consisting of <!-- l. 205 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
on one or two qubits anti-commutes with at least one of the <!-- l. 205 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></math>
generators. Any Pauli string <!-- l. 205 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math>
of weight <!-- l. 205 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mn>2</mn></mrow></math>
can be written as a product of an all-X string of weight <!-- l. 205 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mn>2</mn></mrow></math>
and an all-Z string of weight <!-- l. 205 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mn>2</mn></mrow></math>.
Hence <!-- l. 205 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math>
must anti-commute with some generator. On the other hand, <!-- l. 205 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi></mrow></math>
                                                                     

                                                                     
commutes with all of the generators above and can’t be obtained as a product
of them. Hence, this code has a distance of 3, i.e. it is a <!-- l. 205 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-open' stretchy='false'>[</mo><mn>7</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>3</mn><mo class='MathClass-close' stretchy='false'>]</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
code.
</p>
   </div>
<!-- l. 206 --><p class='indent'>    If we don’t care about error correction and just want to be able to detect an
arbitrary weight-1 error, the following code will work.
</p>
   <div class='newtheorem'>
<!-- l. 208 --><p class='noindent'><span class='head'>
<a id='x15-279006r5'></a>
<span class='cmbx-10x-x-109'>Example 12.2.5.</span>  </span> The following is a
<!-- l. 209 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>⟦</mi><mn>4</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mi>⟧</mi></mrow></math> error
detecting code: </p><table class='equation-star'><tr><td>
<!-- l. 210 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mtable class='aligned'><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi></mtd><mtd columnalign='right'></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></mtd> <mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi></mtd>
</mtr><mtr><mtd columnalign='right'></mtd>
   </mtr>                                                                 </mtable>
</mrow></math></td></tr></table>
<!-- l. 217 --><p class='indent'>   Clearly  any  weight-1  Pauli  will  anti-commute  with  one  of  the  two
stabilisers above, hence it detects a single error. Furthermore, since it has
only 2 stabilisers for 4 physical qubits, it encodes 2 logical qubits.
</p>
   </div>
<!-- l. 218 --><p class='indent'>    In the last two examples, the codes were split into all-X and all-Z generators,
which as we’ll see in Section <a href='#css-codes'>12.3<!-- tex4ht:ref: sec:css-codes  --></a> has some nice consequences which make them
easier to work with. However, if we drop this restriction, we can find even smaller
distance 3 codes.
</p>
   <div class='newtheorem'>
<!-- l. 220 --><p class='noindent'><span class='head'>
<a id='x15-279007r6'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Example 12.2.6.</span>  </span> The following is a
<!-- l. 221 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-open' stretchy='false'>[</mo><mn>5</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>3</mn><mo class='MathClass-close' stretchy='false'>]</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> code:
</p><table class='equation-star'><tr><td>
<!-- l. 222 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mtable class='aligned'><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi></mtd><mtd columnalign='right'></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>3</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>4</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi></mtd>
</mtr><mtr><mtd columnalign='right'></mtd>
   </mtr>                                                                 </mtable>
</mrow></math></td></tr></table>
   </div>
<!-- l. 231 --><p class='indent'>    In the next section, we will see how the code distance enables us to detect
and correct not just Pauli errors, but a large class of errors.
</p>
   <div class='newtheorem'>
<!-- l. 233 --><p class='noindent'><span class='head'>
<a id='x15-279008r3'></a>
<span class='cmbx-10x-x-109'>Exercise 12.3.</span>  </span> Consider the following encoder map, which is a “doubled up”
version of the GHZ encoder from the previous section: </p><table class='equation'><tr><td>
<!-- l. 235 --><p class='indent'>
</p><!-- l. 235 --><object id='x15-279009r3' data="svgs/eq-shor-encoder.svg" alt="diagram of eq:shor-encoder" class="svg-diagram"></object></td><td class='eq-no'>(12.3)</td></tr></table>
<!-- l. 238 --><p class='indent'>   It embeds 1 logical qubit into 9 physical qubits, so its image should have 8
stabilisers. What are they? What is the code distance?
                                                                     

                                                                     
</p>
   </div>
<!-- l. 239 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='detecting-and-correcting-quantum-errors'><span class='titlemark'>12.2.2   </span> <a id='x15-28000012.2.2'></a>Detecting and correcting quantum errors</h4>
<!-- l. 242 --><p class='noindent'>A natural question arises when one first encounters quantum error correcting
codes: why the fixation on Pauli errors? In the classical case, it is quite
natural to focus on bit-flips (and sometimes bit-loss) as the only basic
kinds of errors we care about. Intuitively, these are the only kinds of
errors that can occur for classical data. However, there are many ways
for a qubit to experience an error, so why is it we can get away with
just Pauli X, Y, and Z? Indeed, quantum theory says that the physical
processes that cause quantum errors could act in infinitely many ways on
our qubits, and even interact our qubits with some external systems
outside our control, introducing unwanted entanglement. To capture all
such possibilities, a generic error can be modelled as a unitary like this:
</p><table class='equation-star'><tr><td>
<!-- l. 244 --><object data="svgs/gen-error.svg" alt="diagram of gen-error" class="svg-diagram"></object></td></tr></table>
<!-- l. 247 --><p class='indent'>   where the first <!-- l. 247 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
qubits represent the system we are actually doing the computation on, and the extra
system <!-- l. 247 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>H</mi></mstyle></math>
represents some environment that those qubits might interact with when the
error occurs. The key trick at this point is to realise that the Pauli matrices
<!-- l. 248 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>I</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>X</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>Y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>Z</mi></mrow></math> span the whole
4D space of <!-- l. 248 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn> <mo class='MathClass-bin' stretchy='false'>×</mo> <mn>2</mn></mrow></math>
matrices.
</p>
   <div class='newtheorem'>
<!-- l. 249 --><p class='noindent'><span class='head'>
<a id='x15-280001r4'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Exercise 12.4.</span>  </span> For a matrix: </p><table class='equation-star'><tr><td>
<!-- l. 251 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mi>M</mi> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mi>a</mi> </mtd><mtd class='array-td' columnalign='center'> <mi>b</mi> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mi>c</mi> </mtd> <mtd class='array-td' columnalign='center'> <mi>d</mi></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                          </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 254 --><p class='indent'>   find complex numbers <!-- l. 254 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>λ</mi></mrow><mrow><mi>i</mi></mrow></msub></math>
such that <!-- l. 254 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>M</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>λ</mi></mrow><mrow><mn>0</mn></mrow></msub><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>λ</mi></mrow><mrow><mn>1</mn></mrow></msub><mi>X</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>λ</mi></mrow><mrow><mn>2</mn></mrow></msub><mi>Y</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>λ</mi></mrow><mrow><mn>3</mn></mrow></msub><mi>Z</mi></mrow></math>.
</p>
   </div>
<!-- l. 255 --><p class='indent'>    Consequently, Pauli strings of length
<!-- l. 256 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> span the whole space
of <!-- l. 256 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>×</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math> matrices. Using this
fact, we can decompose <!-- l. 256 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>E</mi></mstyle></math>
as follows: </p><table class='equation-star'><tr><td>
<!-- l. 257 --><object data="svgs/gen-error-decomp.svg" alt="diagram of gen-error-decomp" class="svg-diagram"></object></td></tr></table>
<!-- l. 260 --><p class='indent'>   where <!-- l. 260 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>D</mi></mrow><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo> <mstyle mathvariant='script'><mi>H</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>→</mo><mstyle mathvariant='script'><mi>H</mi></mstyle></mrow></math>
is some linear map on the rest of the space that can vary with
<!-- l. 260 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math>. We
don’t expect to be able to correct <span class='cmti-10x-x-109'>all </span>errors of this form. For example, if
<!-- l. 260 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>E</mi></mstyle></math> simply swapped all
our qubits out into <!-- l. 260 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>H</mi></mstyle></math>
and replaced them with garbage from the environment, there is no way to
recover. So, we should put some kind of reasonable restriction on
                                                                     

                                                                     
<!-- l. 260 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>E</mi></mstyle></math>. First,
let’s split <!-- l. 260 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>E</mi></mstyle></math>
into two parts based on the weight of the Pauli strings: </p><table class='equation-star'><tr><td>
<!-- l. 261 --><object data="svgs/gen-error-decomp-2.svg" alt="diagram of gen-error-decomp-2" class="svg-diagram"></object></td></tr></table>
<!-- l. 264 --><p class='indent'>   For reasonably well-behaved error processes, the second
part of the sum will get exponentially small as we increase
<!-- l. 264 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math>. So, in true
physicist style, we will just ignore it! This gives us the following pretty good approximation
for <!-- l. 264 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>E</mi></mstyle></math>:
</p><table class='equation'><tr><td>
<!-- l. 265 --><p class='indent'>
</p><!-- l. 265 --><object id='x15-280002r4' data="svgs/eq-error-decomp.svg" alt="diagram of eq:error-decomp" class="svg-diagram"></object></td><td class='eq-no'>(12.4)</td></tr></table>
<!-- l. 268 --><p class='indent'>   This is a non-trivial assumption, which comes from the fact
that we assume the interference from the environment is relatively
localised (cf. Remark <a href='#x15-280003r7'>12.2.7<!-- tex4ht:ref: rem:k-local-ham  --></a>). An important consequence is that as
<!-- l. 268 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math> gets
larger, the form (<a href='#x15-280002r4'>12.4<!-- tex4ht:ref: eq:error-decomp  --></a>) gives us a better approximation of an arbitrary error
process.
</p>
   <div class='newtheorem'>
<!-- l. 269 --><p class='noindent'><span class='head'>
<a id='x15-280003r7'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Remark 12.2.7.</span>  </span> We can motivate the form of a “reasonably well-behaved”
error process (<a href='#x15-280002r4'>12.4<!-- tex4ht:ref: eq:error-decomp  --></a>), by considering only those that come from local interactions
with the environment. Recall from Section <a href='main_htmlch7.html#hamiltonian-simulation'>7.5<!-- tex4ht:ref: sec:hammy-sim  --></a> that unitary evolutions in
quantum theory are generated by Hamiltonians, so we can write <!-- l. 270 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>E</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itH</mi></mrow></msup></mrow></math>
for some Hamiltonian <!-- l. 270 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>.
Many physical interactions are well-approximated by so-called <!-- l. 270 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>K</mi></math><span class='cmbx-10x-x-109'>-local
Hamiltonians</span>, which are those <!-- l. 270 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>
that can be written as linear combinations of operators with weight at most
<!-- l. 270 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>K</mi></math>.
Usually <!-- l. 270 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>K</mi></math>
is small (e.g. <!-- l. 270 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>2</mn></math>),
so terms of high weight in <!-- l. 270 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>E</mi></mstyle></math>
all come from higher-order terms in the Taylor expansion (i.e. terms with
high <!-- l. 270 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>
in equation (<a href='main_htmlch7.html#x10-183001r81'>7.81<!-- tex4ht:ref: eq:taylor  --></a>) from Section <a href='main_htmlch7.html#hamiltonian-simulation'>7.5<!-- tex4ht:ref: sec:hammy-sim  --></a>). When <!-- l. 270 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math>
is small, these terms get exponentially close to zero as we increase <!-- l. 270 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>.
</p>
   </div>
<!-- l. 271 --><p class='indent'>    Let’s use this form of an error to talk about a single round of
error detection or correction. We’ll start by assuming that we can
perform stabiliser measurements perfectly (i.e. without introducing more
errors). This is of course not the case, as we’ll see when we discuss
fault-tolerant measurements in Section <a href='#faulttolerant-pauli-measurements'>12.4.2<!-- tex4ht:ref: sec:ft-meas  --></a>. Fix a stabiliser code of distance
<!-- l. 273 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math> given by the stabiliser
group <!-- l. 273 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>S</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. Suppose we
start with a state <!-- l. 273 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∈</mo><mstyle class='text'><mtext class='textrm' mathvariant='normal'>Stab</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
at <!-- l. 273 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>t</mi></mrow><mrow><mn>0</mn></mrow></msub></math>, then measure
the generators of <!-- l. 273 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>
at <!-- l. 273 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>t</mi></mrow><mrow><mn>1</mn></mrow></msub></math>. If
we assume an arbitrary error of the form of (<a href='#x15-280002r4'>12.4<!-- tex4ht:ref: eq:error-decomp  --></a>) could happen between
<!-- l. 273 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>t</mi></mrow><mrow><mn>0</mn></mrow></msub></math> and
<!-- l. 273 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>t</mi></mrow><mrow><mn>1</mn></mrow></msub></math>,
the resulting state, which depends on the measurement outcomes
<!-- l. 273 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>s</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>s</mi></mrow><mrow><mi>m</mi></mrow></msub></mrow></math> looks
like this, up to normalisation: </p><table class='equation'><tr><td>
<!-- l. 274 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 274 --><object id='x15-280004r5' data="svgs/eq-error-detect-state.svg" alt="diagram of eq:error-detect-state" class="svg-diagram"></object></td><td class='eq-no'>(12.5)</td></tr></table>
<!-- l. 277 --><p class='indent'>   If we did not detect an error, this means we get outcome
<!-- l. 277 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>s</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>s</mi></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. In
that case, the resulting state is the following: </p><table class='equation'><tr><td>
<!-- l. 278 --><p class='indent'>
</p><!-- l. 278 --><object id='x15-280005r6' data="svgs/eq-error-detect-state-000.svg" alt="diagram of eq:error-detect-state-000" class="svg-diagram"></object></td><td class='eq-no'>(12.6)</td></tr></table>
<!-- l. 281 --><p class='indent'>   From (<a href='#x15-280002r4'>12.4<!-- tex4ht:ref: eq:error-decomp  --></a>), we can expand <!-- l. 281 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>E</mi></mstyle></math>
as a sum over Pauli strings <!-- l. 281 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math>
with <!-- l. 281 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>d</mi></mrow></math>:
</p><table class='equation'><tr><td>
<!-- l. 282 --><p class='indent'>
</p><!-- l. 282 --><object id='x15-280006r7' data="svgs/eq-error-detect-sum.svg" alt="diagram of eq:error-detect-sum" class="svg-diagram"></object></td><td class='eq-no'>(12.7)</td></tr></table>
<!-- l. 285 --><p class='indent'>   Then, since <!-- l. 285 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>
has distance <!-- l. 285 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math>, all
<!-- l. 285 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math> are either elements
of <!-- l. 285 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math> or anti-commute
with at least one <!-- l. 285 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>∈</mo><mstyle mathvariant='script'><mi>S</mi></mstyle></mrow></math>.
However, terms in (<a href='#x15-280002r4'>12.4<!-- tex4ht:ref: eq:error-decomp  --></a>) corresponding to anti-commuting Pauli
strings vanish. To see this, note that stabiliser generators all
commute, so we can always move the projector corresponding to
                                                                     

                                                                     
<!-- l. 285 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>j</mi></mrow></msub></math> to
the front of the list of projectors in (<a href='#x15-280002r4'>12.4<!-- tex4ht:ref: eq:error-decomp  --></a>). Then:
</p>
<div class='center'>
<!-- l. 287 --><p class='noindent'>
</p><!-- l. 288 --><p class='noindent'><object data="svgs/anti-comm-zero.svg" alt="diagram of anti-comm-zero" class="svg-diagram"></object> </p></div>
<!-- l. 291 --><p class='indent'>   where <!-- l. 291 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext class='MathClass-open' stretchy='false'>(∗)</mtext></mrow></math> is using
the fact that <!-- l. 291 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='normal'>Π</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo><msub><mrow>
<mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> since
<!-- l. 291 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∈</mo><mstyle class='text'><mtext class='textrm' mathvariant='normal'>Stab</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. The only remaining
terms are those where <!-- l. 292 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo><mstyle mathvariant='script'><mi>S</mi></mstyle></mrow></math>.
But then, <!-- l. 292 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. Combining
this with the fact that <!-- l. 292 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
is also invariant under the projection on to
<!-- l. 292 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>Stab</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
(<a href='#x15-280005r6'>12.6<!-- tex4ht:ref: eq:error-detect-state-000  --></a>) reduces to:
</p>
<div class='center'>
<!-- l. 294 --><p class='noindent'>
</p><!-- l. 295 --><p class='noindent'><object data="svgs/no-error-pf.svg" alt="diagram of no-error-pf" class="svg-diagram"></object> </p></div>
<!-- l. 298 --><p class='indent'>   where <!-- l. 298 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>D</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>∈</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-rel' stretchy='false'>&lt;</mo><mi>d</mi></mrow></msub><msub><mrow><mi>D</mi></mrow><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub></mrow></math> is
some (irrelevant) process acting independently on the environment, without disturbing
<!-- l. 298 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. Hence, even
though <!-- l. 298 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>
might not be a Pauli string, if we perform a round of stabiliser measurements and
detect no errors, we will nevertheless project back on to the error-free state
<!-- l. 298 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
But what happens if we <span class='cmti-10x-x-109'>do </span>detect errors? Then, we can attempt
to <span class='cmbx-10x-x-109'>decode </span>the error syndrome by finding some Pauli string
<!-- l. 299 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>∉</mo><mstyle mathvariant='script'><mi>S</mi></mstyle></mrow></math>
that could have produced that error and undo it. In fact, for
reasons that will soon become clear, we often want to find such a
<!-- l. 299 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math> with
weight as small as possible.
</p>
   <div class='newtheorem'>
<!-- l. 300 --><p class='noindent'><span class='head'>
<a id='x15-280007r8'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Definition 12.2.8.</span>  </span> For a stabiliser code defined by
<!-- l. 301 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>S</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> and
syndrome <!-- l. 301 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>s</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>s</mi></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
a <span class='cmbx-10x-x-109'>minimum weight decoding </span>is a Pauli string
<!-- l. 301 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math>
of minimal weight that anti-commutes with
<!-- l. 301 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>j</mi></mrow></msub></math> if and only if
<!-- l. 301 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>s</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>. Diagrammatically,
we have for all <!-- l. 301 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>:
</p><table class='equation-star'><tr><td>
<!-- l. 302 --><object data="svgs/syndrome-comm.svg" alt="diagram of syndrome-comm" class="svg-diagram"></object></td></tr></table>
   </div>
<!-- l. 305 --><p class='indent'>    Clearly if <!-- l. 306 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>s</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>s</mi></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>, the minimum
weight decoding is <!-- l. 306 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mn>1</mn></mrow><mo accent='true'>→</mo></mover></math>.
Otherwise, <!-- l. 306 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math>
will always be a non-trivial Pauli string. If we post-compose
the result of a round of stabiliser measurements (<a href='#x15-280004r5'>12.5<!-- tex4ht:ref: eq:error-detect-state  --></a>) with
<!-- l. 306 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math>, we can push
<!-- l. 306 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math> inside, which
cancels out the <!-- l. 306 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>s</mi></mrow><mrow><mi>j</mi></mrow></msub></math>:
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 307 --><object data="svgs/error-correct-state.svg" alt="diagram of error-correct-state" class="svg-diagram"></object></td></tr></table>
<!-- l. 310 --><p class='indent'>   Hence, we obtain the form of (<a href='#x15-280005r6'>12.6<!-- tex4ht:ref: eq:error-detect-state-000  --></a>) for a new error process
<!-- l. 310 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>E</mi></mrow><mrow><mi>′</mi></mrow></msup></math>. If
<!-- l. 310 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math> is a sum over
Paulis with weight <!-- l. 310 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-rel' stretchy='false'>≤</mo><mo class='MathClass-open' stretchy='false'>⌊</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>d</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn><mo class='MathClass-close' stretchy='false'>⌋</mo></mrow></math>,
and <!-- l. 310 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-rel' stretchy='false'>≤</mo><mo class='MathClass-open' stretchy='false'>⌊</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>d</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn><mo class='MathClass-close' stretchy='false'>⌋</mo></mrow></math>, then
<!-- l. 310 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>E</mi></mrow><mrow><mi>′</mi></mrow></msup></math> is a sum over Paulis
with weight at most <!-- l. 310 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>d</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>.
Hence, if <!-- l. 310 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math> has
distance <!-- l. 310 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math>,
we can use the same argument as before to reduce the expression above to
<!-- l. 310 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>D</mi></mrow></math>,
so we have successfully corrected the error
<!-- l. 310 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>. Note that the weight
of the terms in <!-- l. 311 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>E</mi></mrow><mrow><mi>′</mi></mrow></msup></math> depends
on the weight of <!-- l. 311 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math>. This
is why we try to find <!-- l. 311 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math>
with weight as small as possible, to give the greatest chance to correcting the error. Naïvely,
we can find <!-- l. 311 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math>
by enumerating all of the Pauli strings of weight
<!-- l. 311 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>3</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo></mrow></math> until
we find one with the correct syndrome. Clearly this will take exponential time, so
it becomes infeasible for large codes. Minimum weight decoding for stabiliser
codes is (at least) as hard as for classical codes, which is already known
to be NP-hard for some families of error correcting codes. Hence, for a
stabiliser code to be useful, it needs to not only have good parameters
<!-- l. 312 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-open' stretchy='false'>[</mo><mi>n</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>k</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>d</mi><mo class='MathClass-close' stretchy='false'>]</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>, but
also an efficient way to find minimum weight (or at least low weight)
decodings.
</p>
   <h4 class='subsectionHead' id='encoders-and-logical-operators'><span class='titlemark'>12.2.3   </span> <a id='x15-28100012.2.3'></a>Encoders and logical operators</h4>
<!-- l. 314 --><p class='noindent'>An <!-- l. 314 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-open' stretchy='false'>[</mo><mi>n</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>k</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>d</mi><mo class='MathClass-close' stretchy='false'>]</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
stabiliser code is defined by a stabiliser group
<!-- l. 314 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math> with
<!-- l. 314 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>m</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>k</mi></mrow></math> generators and fixes a
<!-- l. 314 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup></math>-dimensional subspace
                                                                     

                                                                     
<!-- l. 314 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>Stab</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>⊆</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>ℂ</mi><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>n</mi></mrow></math>. Hence, we can think
of this as <!-- l. 314 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> logical qubits
embedded in a space of <!-- l. 314 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
physical qubits. <!-- l. 314 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>Stab</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
tells us <span class='cmti-10x-x-109'>where </span>those qubits lie within the big space, but it does not tell how exactly
<span class='cmti-10x-x-109'>how </span>those qubits are embedded. For example, if we are encoding 2 qubits, which
part of <!-- l. 314 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>Stab</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
corresponds to the first qubit and which to the second qubit? How do
unitaries applied to the physical qubits map on to transformations of the
logical qubits? If we only intend to use quantum error correction for
quantum memory, the answers to these questions are not too important.
However, as we will see in Section <a href='#faulttolerance'>12.4<!-- tex4ht:ref: sec:fault-tolerance  --></a>, they are of central importance when
we start wanting to perform fault-tolerant computations on encoded
qubits. For that reason, it is useful to define an explicit isometry
<!-- l. 316 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>E</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>ℂ</mi><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>→</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>ℂ</mi><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>n</mi></mrow></math> such that
the image of <!-- l. 316 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>
is <!-- l. 316 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>Stab</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
This isometry is called an <span class='cmbx-10x-x-109'>encoder </span>associated with code
<!-- l. 316 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>:
</p>
<div class='center'>
<!-- l. 318 --><p class='noindent'>
</p><!-- l. 319 --><p class='noindent'><object data="svgs/embedding.svg" alt="diagram of embedding" class="svg-diagram"></object> </p></div>
<!-- l. 322 --><p class='indent'>   We already saw some explicit examples of encoder maps, built as ZX
diagrams in Equations (<a href='#x15-278002r2'>12.2<!-- tex4ht:ref: eq:ghz-encoder  --></a>) and (<a href='#x15-279009r3'>12.3<!-- tex4ht:ref: eq:shor-encoder  --></a>). On some occasions, we may actually
want to implement the encoder physically, e.g. as a unitary circuit with
ancillae. However, this need not be the case, and in fact most of the time, it
suffices to treat this as a purely mathematical object, tracking how our
<!-- l. 323 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> logical qubits are
embedded into the space of <!-- l. 323 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
physical qubits. Most importantly, it tracks the relationship between logical maps performed
on our <!-- l. 324 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
logical qubits and the associated physical maps performed on the
<!-- l. 324 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
physical qubits.
</p>
   <div class='newtheorem'>
<!-- l. 325 --><p class='noindent'><span class='head'>
<a id='x15-281001r9'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Definition 12.2.9.</span>  </span> A map <!-- l. 326 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>ℂ</mi><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>→</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>ℂ</mi><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>n</mi></mrow></math> is
said to <span class='cmbx-10x-x-109'>implement </span>a map <!-- l. 326 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>ℂ</mi><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>→</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>ℂ</mi><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>k</mi></mrow></math> in
a stabiliser code with encoder <!-- l. 326 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>
if: </p><table class='equation'><tr><td>
<!-- l. 327 --><p class='indent'>
</p><!-- l. 327 --><object id='x15-281002r8' data="svgs/eq-ftqc.svg" alt="diagram of eq:ftqc" class="svg-diagram"></object></td><td class='eq-no'>(12.8)</td></tr></table>
   </div>
<!-- l. 330 --><p class='indent'>    Intuitively, <!-- l. 331 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>F</mi></math> acts
like <!-- l. 331 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math> on the codespace
of <!-- l. 331 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>, which is isomorphic
to the space of <!-- l. 331 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
qubits. To formalise exactly what “acts like
<!-- l. 331 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>”
means, we need to choose an isomorphism between this subspace and
<!-- l. 331 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>ℂ</mi><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>k</mi></mrow></math>, which is
exactly what <!-- l. 331 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>
does for us. This is a very important concept, since in order for quantum
error correction to work, our quantum data needs to be continuously
protected from errors. Hence, we cannot decode and re-encode qubits every
time we want to apply a gate. As we will see in Section <a href='#faulttolerance'>12.4<!-- tex4ht:ref: sec:fault-tolerance  --></a>, finding an
<!-- l. 331 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>F</mi></math>
satisfying equation (<a href='#x15-281002r8'>12.8<!-- tex4ht:ref: eq:ftqc  --></a>) will help us to implement <span class='cmbx-10x-x-109'>fault tolerant</span>
operations on encoded qubits. Given a generating set of stabilisers for
<!-- l. 332 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>,
we can always derive an encoder by following the procedure we
used to prove the FTST in Section <a href='main_htmlch6.html#the-fundamental-theorem-of-stabiliser-theory'>6.2.1<!-- tex4ht:ref: sec:ftst  --></a>. Namely, we can on to
<!-- l. 332 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>Stab</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> by finding
an isometry <!-- l. 332 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>
such that <!-- l. 332 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='normal'>Π</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>E</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>E</mi></mrow></math>:
</p><table class='equation'><tr><td>
<!-- l. 333 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 333 --><object id='x15-281003r9' data="svgs/eq-stab-split-encoder-def.svg" alt="diagram of eq:stab-split-encoder-def" class="svg-diagram"></object></td><td class='eq-no'>(12.9)</td></tr></table>
<!-- l. 336 --><p class='indent'>   Furthermore, an encoder derived this way will always be a Clifford isometry, so it
is easy to reason about the propagation of Pauli errors. Note that the stabiliser group
<!-- l. 337 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math> only fixes the image
of <!-- l. 337 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math> (or equivalently,
the projector <!-- l. 337 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='normal'>Π</mi></math>).
There are many different ways to split a projector, so following the procedure from the
proof of the FTST gives us just one possible choice. In particular, for any unitary
<!-- l. 337 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>ℂ</mi><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>→</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>ℂ</mi><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>k</mi></mrow></math>, the encoders
<!-- l. 337 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math> and
<!-- l. 337 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>E</mi></mrow><mrow><mi>′</mi></mrow></msup> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='italic'>EU</mi></mrow></math> have the same
image in <!-- l. 337 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>ℂ</mi><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>n</mi></mrow></math>,
hence they correspond to the same stabiliser code
<!-- l. 337 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>. However,
whenever <!-- l. 338 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>
is Clifford, we can perform a nice trick to describe
<!-- l. 338 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math> fully in
terms of Pauli strings: we bend the wires! If we bend the input wires around using cups,
we obtain an <!-- l. 338 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>k</mi></mrow></math>
qubit state <!-- l. 338 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>E</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>:
</p>
<div class='center'>
<!-- l. 340 --><p class='noindent'>
</p><!-- l. 341 --><p class='noindent'><object data="svgs/encoder-bend.svg" alt="diagram of encoder-bend" class="svg-diagram"></object> </p></div>
<!-- l. 344 --><p class='indent'>   Now, we know from the Fundamental Theorem of Stabiliser Theory that
<!-- l. 344 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>k</mi></mrow></math> independent stabilisers
will uniquely fix <!-- l. 344 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>E</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, and
hence will uniquely fix <!-- l. 344 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>. We
already have <!-- l. 344 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>k</mi></mrow></math> stabilisers
given by the generators of <!-- l. 344 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>S</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>:
</p><table class='equation'><tr><td>
<!-- l. 345 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 345 --><object id='x15-281004r10' data="svgs/eq-encoder-stabs.svg" alt="diagram of eq:encoder-stabs" class="svg-diagram"></object></td><td class='eq-no'>(12.10)</td></tr></table>
<!-- l. 348 --><p class='indent'>   So, the question is: where can we find
<!-- l. 348 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi>k</mi></mrow></math>
more stabilisers? The first thing to note is, assuming
<!-- l. 348 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math> is a
Clifford isometry, we can always push arbitrary Pauli strings from its inputs to its
outputs, thanks to Proposition <a href='main_htmlch6.html#x9-134005r6'>6.1.6<!-- tex4ht:ref: prop:isometry-pauli-push  --></a>. In particular, we can always push single-qubit
Pauli <!-- l. 348 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math> and
<!-- l. 348 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math> gates
through <!-- l. 348 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>.
As a consequence, we can always find a Pauli string
<!-- l. 348 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></math>
that implements (in the sense of Definition <a href='#x15-281001r9'>12.2.9<!-- tex4ht:ref: def:implement-logical  --></a>) a Pauli
<!-- l. 348 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math> gate applied
in the <!-- l. 348 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>-th
logical qubit, i.e. </p><table class='equation'><tr><td>
<!-- l. 349 --><p class='indent'>
</p><!-- l. 349 --><object id='x15-281005r11' data="svgs/eq-logical-x.svg" alt="diagram of eq:logical-x" class="svg-diagram"></object></td><td class='eq-no'>(12.11)</td></tr></table>
<!-- l. 352 --><p class='indent'>   Similarly, for a <!-- l. 352 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math> gate on
the <!-- l. 352 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>-th qubit, there exists
a different Pauli string <!-- l. 352 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></math>
such that: </p><table class='equation'><tr><td>
<!-- l. 353 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 353 --><object id='x15-281006r12' data="svgs/eq-logical-z.svg" alt="diagram of eq:logical-z" class="svg-diagram"></object></td><td class='eq-no'>(12.12)</td></tr></table>
<!-- l. 356 --><p class='indent'>   This gives us <!-- l. 356 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi>k</mi></mrow></math>
Pauli strings <!-- l. 356 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
called the <span class='cmbx-10x-x-109'>logical operators </span>associated with
<!-- l. 356 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>.
</p>
   <div class='newtheorem'>
<!-- l. 357 --><p class='noindent'><span class='head'>
<a id='x15-281007r5'></a>
<span class='cmbx-10x-x-109'>Exercise 12.5.</span>  </span> Show that the logical operators <!-- l. 358 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
are self-adjoint and commute with every element of the stabiliser group
<!-- l. 358 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>.
Furthermore, show that the pair of logical operators <!-- l. 358 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></math>
and <!-- l. 358 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></math>
anti-commute for all <!-- l. 358 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>
and all other pairs of logical operators commute.
</p>
   </div>
<!-- l. 359 --><p class='indent'>     In the following exercises we will see that any undetectable error, i.e. a
Pauli that commutes with all the stabilisers, is (up to multiplication by
stabilisers), a product of logical operators. Hence, such an error actually changes
the logical information stored in the state, so that it produces another valid
codeword, and there is no chance for us to correct it.
</p>
   <div class='newtheorem'>
<!-- l. 382 --><p class='noindent'><span class='head'>
<a id='x15-281008r6'></a>
<span class='cmbx-10x-x-109'>Exercise 12.6.</span>  </span> Let <!-- l. 383 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>S</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
be a stabiliser group and let <!-- l. 383 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msub></mrow></math>,
<!-- l. 383 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msub></mrow></math>
be the logical operators. Show that the group <!-- l. 383 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>C</mi></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
of Pauli strings that commute with all elements of <!-- l. 383 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math>
                                                                     

                                                                     
is <!-- l. 383 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
<span class='cmti-10x-x-109'>Hint: If an element </span><!-- l. 384 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>T</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo><mstyle mathvariant='script'><mi>C</mi></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
<span class='cmti-10x-x-109'>commutes with all </span><!-- l. 384 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mrow><mi>i</mi></mrow></msub></math><span class='cmti-10x-x-109'>,
then </span><!-- l. 384 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>T</mi></mrow><mo accent='true'>→</mo></mover></math>
<span class='cmti-10x-x-109'>is an element of the maximal stabiliser group </span><!-- l. 384 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math><span class='cmti-10x-x-109'>,
and hence a product of these elements. If instead it does not commute with
some </span><!-- l. 384 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mrow><mi>i</mi></mrow></msub></math>
<span class='cmti-10x-x-109'>show that we can still write it as a product of the logicals and stabilisers.</span>
</p>
   </div>
<!-- l. 385 --><p class='indent'>     By moving the <!-- l. 389 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
gate to the right-hand side of (<a href='#x15-281005r11'>12.11<!-- tex4ht:ref: eq:logical-x  --></a>) and bending the wires, we see that each logical operator
<!-- l. 389 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></math> gives us a stabiliser
for the Choi state <!-- l. 389 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>E</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>:
</p><table class='equation'><tr><td>
<!-- l. 390 --><p class='indent'>
</p><!-- l. 390 --><object id='x15-281009r13' data="svgs/eq-encoder-logical-z-stabs.svg" alt="diagram of eq:encoder-logical-z-stabs" class="svg-diagram"></object></td><td class='eq-no'>(12.13)</td></tr></table>
<!-- l. 393 --><p class='indent'>   Similarly, each <!-- l. 393 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></math>
gives us a stabiliser for <!-- l. 393 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>E</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>:
</p><table class='equation'><tr><td>
<!-- l. 394 --><p class='indent'>
</p><!-- l. 394 --><object id='x15-281010r14' data="svgs/eq-encoder-logical-x-stabs.svg" alt="diagram of eq:encoder-logical-x-stabs" class="svg-diagram"></object></td><td class='eq-no'>(12.14)</td></tr></table>
                                                                     

                                                                     
<!-- l. 397 --><p class='indent'>   Note that the operators of the form (<a href='#x15-281009r13'>12.13<!-- tex4ht:ref: eq:encoder-logical-z-stabs  --></a>) and (<a href='#x15-281010r14'>12.14<!-- tex4ht:ref: eq:encoder-logical-x-stabs  --></a>) all pairwise commute. This is because
the <!-- l. 397 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math> coming from
anti-commuting an <!-- l. 397 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
and <!-- l. 397 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math> on
the <!-- l. 397 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>-th
qubit is always cancelled out by anti-commuting
<!-- l. 397 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></math> with
<!-- l. 397 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></math> on the
last <!-- l. 397 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
qubits (cf. Exercise <a href='#x15-281007r5'>12.5<!-- tex4ht:ref: exer:logical-operators-comm  --></a>). If we combine the stabilisers coming from
<!-- l. 398 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>S</mi></mstyle></math> in
equation (<a href='#x15-281004r10'>12.10<!-- tex4ht:ref: eq:encoder-stabs  --></a>) with those coming from the logical operators, we obtain
<!-- l. 398 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>k</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>k</mi></mrow></math> stabilisers for
<!-- l. 398 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>E</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, which is by
construction an <!-- l. 398 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>k</mi></mrow></math>
qubit state. Hence, <!-- l. 398 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>
is totally fixed up to a scalar factor. Hence, if we perform the method from Section <a href='main_htmlch6.html#the-fundamental-theorem-of-stabiliser-theory'>6.2.1<!-- tex4ht:ref: sec:ftst  --></a> for
the full set of <!-- l. 399 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>k</mi></mrow></math>
stabilisers for <!-- l. 399 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>E</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
then bend the wires, we’ll get the encoder associated with a stabiliser group
and a set of logical operators. In general, this will be a relatively deep
ZX-diagram, with approximately one layer for each stabiliser and logical
operator. We could then try and simplify things to get a more compact form,
e.g. by reducing to GSLC or AP form, but in general this picture of the
encoder might be a bit awkward to work with. However, as we’ll see in
Section <a href='#css-codes'>12.3<!-- tex4ht:ref: sec:css-codes  --></a>, for a certain family of codes, called CSS codes, things get a lot
simpler!
</p>
   <h4 class='subsectionHead' id='the-decoder'><span class='titlemark'>12.2.4   </span> <a id='x15-28200012.2.4'></a>The decoder</h4>
<!-- l. 402 --><p class='noindent'>The encoder has a dual operation, which we call the <span class='cmti-10x-x-109'>ideal decoder</span>, or simply the
<span class='cmbx-10x-x-109'>decoder</span>. This is slightly more difficult to work with than the encoder, so
whenever possible we will state things in terms of the encoder rather
than the decoder. However, having a way to at least in principle decode
<!-- l. 402 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> physical qubits
back into <!-- l. 402 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
logical qubits while detecting/correcting errors is still a useful thing to have in
our back pocket. The encoder is an isometry, so we know how to implement it
straight away as a unitary circuit with ancillae. In fact, this definition of
<!-- l. 403 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math> is already
clear from the definition of the encoder in equation (<a href='#x15-281003r9'>12.9<!-- tex4ht:ref: eq:stab-split-encoder-def  --></a>) in terms of the splitting
of the projectors onto the stabiliser subspace. However, we can’t deterministically
                                                                     

                                                                     
implement <!-- l. 404 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>E</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></math>
because it would require performing the unitary
<!-- l. 404 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></math>
then post-selecting each of the ancilla qubits on to
<!-- l. 404 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>.
However, we can <span class='cmti-10x-x-109'>measure </span>those ancillae instead: </p><table class='equation-star'><tr><td>
<!-- l. 405 --><object data="svgs/decode-1.svg" alt="diagram of decode-1" class="svg-diagram"></object></td></tr></table>
<!-- l. 408 --><p class='indent'>   But what are these measurement outcomes
<!-- l. 408 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>s</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>s</mi></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>?
Recall the following equation from Exercise* <a href='main_htmlch6.html#x9-137011r10'>6.10<!-- tex4ht:ref: exer:stab-measurement-split  --></a>:
</p>
<div class='center'>
<!-- l. 410 --><p class='noindent'>
</p><!-- l. 411 --><p class='noindent'><object data="svgs/gen-stab-group-split.svg" alt="diagram of gen-stab-group-split" class="svg-diagram"></object> </p></div>
<!-- l. 414 --><p class='indent'>   This implies that for an encoded state
<!-- l. 414 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi mathvariant='normal'>Ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, performing
<!-- l. 414 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></math>
and measuring the ancillae will give us the same outcome
<!-- l. 414 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover></math> as
measuring all of the stabilisers.  Hence, we can use the measurement outcomes
from the ancillae to do error detection or correction. If we get outcome
<!-- l. 416 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
we can conclude that no logical error has occurred with weight
<!-- l. 416 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>d</mi></mrow></math>. If we get any
other syndrome, we can do least-distance decoding to find the smallest weight physical error
<!-- l. 416 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math> with error
syndrome <!-- l. 416 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover></math>,
and then figure out the appropriate correction to do on the
<!-- l. 416 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> logical qubits we
have left. Since <!-- l. 416 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></math>
                                                                     

                                                                     
is Clifford, we can do this efficiently.
</p>
   <div class='newtheorem'>
<!-- l. 417 --><p class='noindent'><span class='head'>
<a id='x15-282001r7'></a>
<span class='cmbx-10x-x-109'>Exercise 12.7.</span>  </span> Fix a stabiliser code with generators <!-- l. 418 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
and distance <!-- l. 418 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math>.
For a syndrome <!-- l. 418 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover></math>,
let <!-- l. 418 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub></math>
be a Pauli of minimal weight with that syndrome, and let <!-- l. 418 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub></math>
be the first <!-- l. 418 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
qubits of the Pauli string <!-- l. 418 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><mi>U</mi></mrow></math>.
Show that for any Pauli string <!-- l. 419 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math>
with syndrome <!-- l. 419 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover></math>
and weight <!-- l. 419 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math>
where <!-- l. 419 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi>t</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mi>d</mi></mrow></math>,
we have:
</p>
<div class='center'>
<!-- l. 421 --><p class='noindent'>
</p><!-- l. 422 --><p class='noindent'><object data="svgs/decode-2.svg" alt="diagram of decode-2" class="svg-diagram"></object> </p></div>
   </div>
<!-- l. 425 --><p class='indent'>      Given this, we therefore define the <span class='cmbx-10x-x-109'>decoder </span>as a
non-deterministic process consisting of a measurement yielding syndrome
<!-- l. 436 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover></math> followed by the associated
Pauli correction <!-- l. 436 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub></math>
defined as in Exercise <a href='#x15-282001r7'>12.7<!-- tex4ht:ref: exer:decoder-works  --></a>: </p><table class='equation'><tr><td>
<!-- l. 437 --><p class='indent'>
</p><!-- l. 437 --><object id='x15-282002r15' data="svgs/eq-decoder-def.svg" alt="diagram of eq:decoder-def" class="svg-diagram"></object></td><td class='eq-no'>(12.15)</td></tr></table>
                                                                     

                                                                     
<!-- l. 440 --><p class='indent'>   When <!-- l. 440 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover></mrow></math>,
<!-- l. 440 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>, so
<!-- l. 440 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mover accent='true'><mrow><mi>D</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>E</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></mrow></math>. Hence this
process acts like <!-- l. 440 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>E</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></math>
in the error-free case, but it additionally also “swallows” any correctable errors when
<!-- l. 440 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>≠</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover></mrow></math>.
</p>
   <div class='newtheorem'>
<!-- l. 441 --><p class='noindent'><span class='head'>
<a id='x15-282003r10'></a>
<span class='cmbx-10x-x-109'>Remark* 12.2.10.</span>  </span>If we don’t care about the outcome of the syndrome
measurement and just want the error-corrected state out, we can represent the
decoder as a single quantum channel (cf. Section* <a href='main_htmlch2.html#quantum-mixed-states-and-channels'>2.7.1<!-- tex4ht:ref: sec:channels  --></a>) with Kraus operators
<!-- l. 442 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow> <mrow><mo fence='true' form='prefix'>{</mo><mrow><msub><mrow><mi>D</mi></mrow><mrow><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub></mrow><mo fence='true' form='postfix'>}</mo></mrow> </mrow><mrow><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>∈</mo><msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>m</mi></mrow></msubsup></mrow></msub></math>, i.e.
</p><table class='equation-star'><tr><td>
<!-- l. 443 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                     <mstyle mathvariant='script'><mi>D</mi></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>ρ</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo><munder class='msub'><mrow><mo> ∑</mo>
   </mrow><mrow><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>∈</mo><msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>m</mi></mrow></msubsup></mrow></munder><msub><mrow><mi>D</mi></mrow><mrow><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><mi>ρ</mi><msubsup><mrow><mi>D</mi></mrow><mrow><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msubsup>
</mrow></math></td></tr></table>
<!-- l. 444 --><p class='indent'>   One can check this is trace-preserving and for any correctable Pauli error
<!-- l. 444 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math>,
we have <!-- l. 444 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>D</mi></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover><mi>ρ</mi><msup><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle mathvariant='script'><mi>D</mi></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>ρ</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
</p>
   </div>
<!-- l. 445 --><p class='indent'>
</p>
   <h3 class='sectionHead' id='css-codes'><span class='titlemark'>12.3   </span> <a id='x15-28300012.3'></a>CSS codes</h3>
<!-- l. 447 --><p class='noindent'>In this section, we’ll define a family of stabiliser codes called <span class='cmbx-10x-x-109'>Calderbank-Shor-Steane
codes</span>, or <span class='cmbx-10x-x-109'>CSS codes </span>for short. As you may have already noticed from
Examples <a href='#x15-279005r4'>12.2.4<!-- tex4ht:ref: ex:steane  --></a> and <a href='#x15-279006r5'>12.2.5<!-- tex4ht:ref: ex:422-code  --></a>, some stabiliser codes have generators that split
nicely into an all-X part and an all-Z part. In a sense, such codes behave like
                                                                     

                                                                     
two classical error correcting codes mushed together, where the parity
checks of one code become the Z stabilisers (which detect bit errors) and
those of the other code become the X stabilisers (which detect phase
errors). That is pretty much all there is to defining a CSS code, once
you additionally account for the fact that all of the stabilisers need to
commute. It turns out there is a very natural way to impose this in terms of
bitstrings.
</p>
   <div class='newtheorem'>
<!-- l. 449 --><p class='noindent'><span class='head'>
<a id='x15-283001r8'></a>
<span class='cmbx-10x-x-109'>Exercise 12.8.</span>  </span> Suppose we define two Pauli strings from the bitstrings
<!-- l. 450 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover></math> and
<!-- l. 450 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover></math> as
follows: </p><table class='equation-star'><tr><td>
<!-- l. 451 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                 <mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo><munderover accent='false' accentunder='false'><mrow><mo> ⊗</mo>
   </mrow><mrow><mi>j</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>1</mn></mrow><mrow><mi>n</mi></mrow></munderover><msup><mrow><mi>X</mi></mrow><mrow><msub><mrow><mi>v</mi></mrow><mrow><mi>j</mi></mrow></msub>
   </mrow></msup><mspace class='qquad' width='2em'></mspace><mspace class='qquad' width='2em'></mspace><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo><munderover accent='false' accentunder='false'><mrow><mo> ⊗</mo>
</mrow><mrow><mi>j</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>1</mn></mrow><mrow><mi>n</mi></mrow></munderover><msup><mrow><mi>Z</mi></mrow><mrow><msub><mrow><mi>w</mi></mrow><mrow><mi>j</mi></mrow></msub>
   </mrow></msup>
</mrow></math></td></tr></table>
<!-- l. 456 --><p class='indent'>   Show                                                                                  that
<!-- l. 456 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>→</mo></mover></math>
and
<!-- l. 456 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></math>
commute                  if                  and                  only                  if
<!-- l. 456 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover></math>
and
<!-- l. 456 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover></math>
are                                      orthogonal,                                      i.e.
<!-- l. 456 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>T</mi> </mrow></msup><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>
(mod 2).
</p>
   </div>
                                                                     

                                                                     
<!-- l. 457 --><p class='indent'>    Hence, if we fix two classical codespaces, one for the X-stabilisers
and one for the Z-stabilisers, all the stabilisers will commute precisely
when those subspaces are mutually orthogonal. We say two subspaces
<!-- l. 458 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>T</mi></mrow></math> are
orthogonal if <!-- l. 458 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>T</mi> </mrow></msup><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>
for all <!-- l. 458 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>v</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>S</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>w</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>T</mi></mrow></math>, or
equivalently <!-- l. 458 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>T</mi> <mo class='MathClass-rel' stretchy='false'>⊆</mo> <msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></mrow></math>.
</p>
   <div class='newtheorem'>
<!-- l. 459 --><p class='noindent'><span class='head'>
<a id='x15-283002r1'></a>
<span class='cmbx-10x-x-109'>Definition 12.3.1.</span>  </span>The <span class='cmti-10x-x-109'>CSS code </span>generated by orthogonal subspaces
<!-- l. 460 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>T</mi> <mo class='MathClass-rel' stretchy='false'>⊆</mo> <msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msubsup></mrow></math> is a
stabiliser code whose generators are of the following form: </p><table class='equation-star'><tr><td>
<!-- l. 461 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow>
              <mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo><munderover accent='false' accentunder='false'><mrow><mo> ⊗</mo>
   </mrow><mrow><mi>k</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>1</mn></mrow><mrow><mi>n</mi></mrow></munderover><msup><mrow><mi>X</mi></mrow><mrow><msub><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>v</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>k</mi></mrow></msub>
      </mrow></msup><mspace class='qquad' width='2em'></mspace><mspace class='qquad' width='2em'></mspace><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo><munderover accent='false' accentunder='false'><mrow><mo> ⊗</mo>
</mrow><mrow><mi>k</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>1</mn></mrow><mrow><mi>n</mi></mrow></munderover><msup><mrow><mi>Z</mi></mrow><mrow><msub><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>w</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>k</mi></mrow></msub>
       </mrow></msup>
</mrow></math></td></tr></table>
<!-- l. 466 --><p class='indent'>   where <!-- l. 466 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>p</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
is a basis spanning <!-- l. 466 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
and <!-- l. 466 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mi>w</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>q</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
a basis spanning <!-- l. 466 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>.
A CSS code is called <span class='cmti-10x-x-109'>maximal </span>if <!-- l. 466 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>T</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></mrow></math>.
</p>
   </div>
<!-- l. 467 --><p class='indent'>    That is, we let the basis vectors of
<!-- l. 468 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
define the X generators and we let the basis vectors of
<!-- l. 468 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> define the Z generators.
Since addition in <!-- l. 468 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
is taken modulo 2, orthogonality guarantees that each X generator overlaps
with a Z generator in an even number of places, which makes the group
commutative. Using this fact, it is easy to verify the resulting group is a stabiliser
group.
                                                                     

                                                                     
</p>
   <div class='newtheorem'>
<!-- l. 469 --><p class='noindent'><span class='head'>
<a id='x15-283003r2'></a>
<span class='cmbx-10x-x-109'>Example 12.3.2.</span>  </span> Let <!-- l. 470 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
be a 3D subspace of <!-- l. 470 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mn>7</mn></mrow></msubsup></math>
spanned by: </p><table class='equation-star'><tr><td>
<!-- l. 471 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
           <mo class='MathClass-open' stretchy='false'>{</mo><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>}</mo>
</mrow></math></td></tr></table>
<!-- l. 474 --><p class='indent'>   This particular subspace is known as a <span class='cmti-10x-x-109'>Hamming code</span>. It’s
classical code distance is 3, and it has the nice property that
<!-- l. 474 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> is orthogonal to itself.
Hence, we can use <!-- l. 474 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
to derive both the X and Z generators of a CSS code. In fact, we already saw this
code: it is the <span class='cmti-10x-x-109'>Steane code </span>from Example <a href='#x15-279005r4'>12.2.4<!-- tex4ht:ref: ex:steane  --></a>. </p><table class='equation-star'><tr><td>
<!-- l. 475 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mtable class='aligned'><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi></mtd><mtd columnalign='right'></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>3</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></mtd> <mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></mtd> <mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>3</mn></mrow></msub></mtd> <mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi></mtd>
</mtr><mtr><mtd columnalign='right'></mtd>
   </mtr>                                                                 </mtable>
</mrow></math></td></tr></table>
                                                                     

                                                                     
   </div>
<!-- l. 486 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='stabilisers-and-pauli-zx-diagrams'><span class='titlemark'>12.3.1   </span> <a id='x15-28400012.3.1'></a>Stabilisers and Pauli ZX diagrams</h4>
<!-- l. 488 --><p class='noindent'>Recall from Section <a href='main_htmlch4.html#phasefree-states-and-f-linear-subspaces'>4.3<!-- tex4ht:ref: sec:phase-free-subspace  --></a> that phase-free ZX-diagrams can always be put into Z-X
or X-Z normal form, which correspond respectively to representations of an
<!-- l. 488 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>-linear subspace
<!-- l. 488 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> using a
basis for <!-- l. 488 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> or
a basis for <!-- l. 488 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></math>:
</p><table class='equation-star'><tr><td>
<!-- l. 489 --><object data="svgs/phase-free-state-sm.svg" alt="diagram of phase-free-state-sm" class="svg-diagram"></object></td></tr></table>
   <table class='equation-star'><tr><td>
<!-- l. 492 --><object data="svgs/X-Z-nf-state-1.svg" alt="diagram of X-Z-nf-state-1" class="svg-diagram"></object></td></tr></table>
<!-- l. 495 --><p class='indent'>   If we combine this knowledge with these equations, which follow from
<!-- l. 495 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x6-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>π</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>:
</p><table class='equation'><tr><td>
<!-- l. 496 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 496 --><object id='x15-284001r16' data="svgs/eq-zx-stab.svg" alt="diagram of eq:zx-stab" class="svg-diagram"></object></td><td class='eq-no'>(12.16)</td></tr></table>
<!-- l. 499 --><p class='indent'>   we can see immediately how to derive a generating set of stabilisers for a
phase-free ZX-diagram. As we’ll see in this section, those stabilisers always
generate a CSS code, and conversely any CSS code can be presented using a
phase-free ZX-diagram.
</p>
   <h4 class='subsectionHead' id='maximal-css-codes-as-zx-diagrams'><span class='titlemark'>12.3.2   </span> <a id='x15-28500012.3.2'></a>Maximal CSS codes as ZX diagrams</h4>
<!-- l. 501 --><p class='noindent'>Eq. (<a href='#x15-284001r16'>12.16<!-- tex4ht:ref: eq:zx-stab  --></a>), plus the two normal forms from Section <a href='main_htmlch4.html#phasefree-completeness'>4.3.1<!-- tex4ht:ref: sec:pp-complete  --></a>, will give us
everything we need to prove our main theorem.
</p>
   <div class='newtheorem'>
<!-- l. 502 --><p class='noindent'><span class='head'>
<a id='x15-285001r3'></a>
<span class='cmbx-10x-x-109'>Theorem 12.3.3.</span>  </span> For any <!-- l. 503 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>-linear
subspace <!-- l. 503 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi> <mo class='MathClass-rel' stretchy='false'>⊆</mo> <msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msubsup></mrow></math>,
<!-- l. 503 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
is stabilised by the maximal CSS code <!-- l. 503 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>S</mi><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
if and only if it is equivalent, up to a scalar factor, to a phase-free ZX diagram
with an X-Z normal form given by <!-- l. 503 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
(or equivalently with a Z-X normal form given by <!-- l. 503 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></math>).
</p>
   </div>
<!-- l. 504 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 506 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Suppose <!-- l. 506 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
is described by a phase-free ZX-diagram. Then it can be translated into X-Z normal form,
for some basis <!-- l. 506 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>v</mi></mrow><mrow><mi>p</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
                                                                     

                                                                     
of an <!-- l. 506 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>-linear
space <!-- l. 506 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>. Then,
for each <!-- l. 506 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>v</mi></mrow><mrow><mi>i</mi></mrow></msub></math>,
we can apply Eq. (<a href='#x15-284001r16'>12.16<!-- tex4ht:ref: eq:zx-stab  --></a>) to introduce an X phase of
<!-- l. 506 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
on every wire adjacent to the Z spider labelled by
<!-- l. 506 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>v</mi></mrow><mrow><mi>i</mi></mrow></msub></math> and
commute it to the output using (sp’): </p><table class='equation-star'><tr><td>
<!-- l. 507 --><object data="svgs/fire-v.svg" alt="diagram of fire-v" class="svg-diagram"></object></td></tr></table>
<!-- l. 510 --><p class='indent'>   This shows that <!-- l. 510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
is invariant under the action of the Pauli operator <!-- l. 510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo><msubsup><mrow> <mi class='MathClass-op'>⊗</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>k</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>1</mn></mrow><mrow><mi>n</mi></mrow></msubsup><msup><mrow><mi>X</mi></mrow><mrow><msub><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>v</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>k</mi></mrow></msub></mrow></msup></mrow></math>.
Hence, <!-- l. 510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
is the <!-- l. 510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn></mrow></math>
eigenstate of all of the <!-- l. 510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>p</mi></math>
independent X stabilisers of the maximal CSS code <!-- l. 510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>S</mi><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
Similarly, we can compute the Z-X normal form of <!-- l. 510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
and show that it is the <!-- l. 510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn></mrow></math>
eigenstate of all <!-- l. 510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>q</mi></math>
independent Z stabilisers <!-- l. 510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo><msubsup><mrow> <mi class='MathClass-op'>⊗</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>k</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>1</mn></mrow><mrow><mi>n</mi></mrow></msubsup><msup><mrow><mi>Z</mi></mrow><mrow><msub><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>w</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>k</mi></mrow></msub></mrow></msup></mrow></math>.
This gives <!-- l. 510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>p</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>q</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>n</mi></mrow></math>
independent stabilisers for <!-- l. 510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
hence it is uniquely fixed by the FTST Theorem <a href='main_htmlch6.html#x9-137006r11'>6.2.11<!-- tex4ht:ref: thm:fundamental-stab  --></a>. Conversely, any
maximal CSS code fixes a state whose stabilisers are given by <!-- l. 510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mrow><mi>i</mi></mrow></msub></math>
and <!-- l. 510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mrow><mi>j</mi></mrow></msub></math>
as before, so they will be equal to a phase-free ZX diagram with X-Z normal
form given by <!-- l. 510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>,
or equivalently, with Z-X normal form given by <!-- l. 510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></math>.
                                                                   □
</p>
   </div>
<!-- l. 512 --><p class='indent'>   This proof gives us an evident way of translating the stabiliser
generators of a maximal CSS code into a ZX diagram. In fact, it gives
                                                                     

                                                                     
us two equivalent ways, using the Z-X normal form, which gives us a
generating set of X stabilisers, or the X-Z normal form, which gives us
the Z stabilisers. Interestingly, we only ever need to represent one
kind of stabilisers for a maximal CSS code diagrammatically, because
<!-- l. 512 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></math> is uniquely
fixed by <!-- l. 512 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
and vice-versa.
</p>
   <h4 class='subsectionHead' id='nonmaximal-css-codes-as-zx-encoder-maps'><span class='titlemark'>12.3.3   </span> <a id='x15-28600012.3.3'></a>Non-maximal CSS codes as ZX encoder maps</h4>
<!-- l. 514 --><p class='noindent'>For a non-maximal CSS code, we should end up with an encoder map from
<!-- l. 514 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> logical
qubits to <!-- l. 514 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
physical qubits. Since we already know how to turn CSS stabilisers
into phase-free diagrams, we can use the wire-bending trick from
Section <a href='#encoders-and-logical-operators'>12.2.3<!-- tex4ht:ref: sec:encoder  --></a> to treat logical operators as stabilisers on a bigger
<!-- l. 514 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>k</mi></mrow></math> qubit
state and therefore add them to the diagram as well. As an example,
lets return to the 7-qubit Steane code from Example <a href='#x15-283003r2'>12.3.2<!-- tex4ht:ref: ex:steane-css  --></a>. We will
switch to a more compact notation for writing its stabilisers, where
<!-- l. 515 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>X</mi></mrow><mrow><mi>i</mi></mrow></msub></math> (resp.
<!-- l. 515 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>Z</mi></mrow><mrow><mi>i</mi></mrow></msub></math>) corresponds to an
<!-- l. 515 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit operator acting
non-trivially on the <!-- l. 515 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>-th
qubit with a Pauli <!-- l. 515 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
(resp. <!-- l. 515 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>):
</p><table class='equation-star'><tr><td>
<!-- l. 516 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mtable class='aligned'><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>X</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>5</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>6</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>7</mn></mrow></msub></mtd><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>X</mi></mrow><mrow><mn>2</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>4</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>6</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>7</mn></mrow></msub></mtd><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>3</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>X</mi></mrow><mrow><mn>3</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>4</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>5</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>7</mn></mrow></msub></mtd><mtd columnalign='right'></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></mtd> <mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>Z</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>Z</mi></mrow><mrow><mn>5</mn></mrow></msub><msub><mrow><mi>Z</mi></mrow><mrow><mn>6</mn></mrow></msub><msub><mrow><mi>Z</mi></mrow><mrow><mn>7</mn></mrow></msub></mtd> <mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></mtd> <mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>Z</mi></mrow><mrow><mn>2</mn></mrow></msub><msub><mrow><mi>Z</mi></mrow><mrow><mn>4</mn></mrow></msub><msub><mrow><mi>Z</mi></mrow><mrow><mn>6</mn></mrow></msub><msub><mrow><mi>Z</mi></mrow><mrow><mn>7</mn></mrow></msub></mtd> <mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>3</mn></mrow></msub></mtd> <mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>Z</mi></mrow><mrow><mn>3</mn></mrow></msub><msub><mrow><mi>Z</mi></mrow><mrow><mn>4</mn></mrow></msub><msub><mrow><mi>Z</mi></mrow><mrow><mn>5</mn></mrow></msub><msub><mrow><mi>Z</mi></mrow><mrow><mn>7</mn></mrow></msub></mtd>
</mtr><mtr><mtd columnalign='right'></mtd>
   </mtr>                                                                 </mtable>
</mrow></math></td></tr></table>
<!-- l. 526 --><p class='indent'>   This CSS code is non-maximal, and encodes
<!-- l. 526 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>7</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>6</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
                                                                     

                                                                     
logical qubits. Hence we should fix 2 additional logical operators
<!-- l. 526 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>X</mi></mrow><mrow><mn>4</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>5</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>6</mn></mrow></msub></mrow></math>,
<!-- l. 526 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>Z</mi></mrow><mrow><mn>4</mn></mrow></msub><msub><mrow><mi>Z</mi></mrow><mrow><mn>5</mn></mrow></msub><msub><mrow><mi>Z</mi></mrow><mrow><mn>6</mn></mrow></msub></mrow></math>.
As we noted before, we only need one kind of stabiliser to build the
ZX diagram, so applying the recipe from the previous section to the
<!-- l. 526 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
stabilisers and logical operator, we obtain the following picture, where we label
the logical qubit 0 and the physical qubits 1-7. We can then put the logical qubit
on the left and rearrange some of the physical qubits to obtain the following:
</p><table class='equation-star'><tr><td>
<!-- l. 527 --><object data="svgs/steane-naive.svg" alt="diagram of steane-naive" class="svg-diagram"></object></td></tr></table>
<!-- l. 530 --><p class='indent'>   Note that, if we follow this recipe, we will always get identity spiders on the
inputs, which are redundant. If we simplify them away, we’ll always end up with
something in generalised parity form (for the X form of the encoder) or the
colour-reverse of generalised parity form (for the Z form of the encoder).
</p><table class='equation'><tr><td>
<!-- l. 531 --><p class='indent'>
</p><!-- l. 531 --><object id='x15-286001r17' data="svgs/eq-steane-is-gpf.svg" alt="diagram of eq:steane-is-gpf" class="svg-diagram"></object></td><td class='eq-no'>(12.17)</td></tr></table>
<!-- l. 534 --><p class='indent'>   As a result, we can always write a CSS encoder map in generalised parity
form using just its X-stabilisers and X-logical operators as follows:
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
                                                                     

                                                                     
     <!-- l. 536 --><p class='noindent'>Place an output X-spider on all <!-- l. 536 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
     outputs.
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 537 --><p class='noindent'>For each of the <!-- l. 537 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
     X-logical operator, add an input Z-spider connected to the output
     X-spiders of its support.
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 538 --><p class='noindent'>For each X-stabiliser generator, add an internal Z-spider connected to
     the output X-spiders of its support. </p></dd></dl>
<!-- l. 540 --><p class='noindent'>Equation (<a href='#x15-286001r17'>12.17<!-- tex4ht:ref: eq:steane-is-gpf  --></a>) gives the X-form of the Steane code encoder. If we used the
Z-stabilisers and logicals instead, we’ll obtain the Z-form. In the case of the
Steane code, this is the exact same picture, but with the colours reversed:
</p><table class='equation'><tr><td>
<!-- l. 541 --><p class='indent'>
</p><!-- l. 541 --><object id='x15-286005r18' data="svgs/eq-steane-self-dual.svg" alt="diagram of eq:steane-self-dual" class="svg-diagram"></object></td><td class='eq-no'>(12.18)</td></tr></table>
<!-- l. 544 --><p class='indent'>   This will not always be the case, and it comes from the fact that the Steane
code is <span class='cmbx-10x-x-109'>self-dual</span>. We’ll discuss self-dual codes more in Section <a href='#transversal-clifford-gates'>12.4.1.1<!-- tex4ht:ref: sec:transversal-clifford  --></a>.
</p>
   <div class='newtheorem'>
<!-- l. 545 --><p class='noindent'><span class='head'>
<a id='x15-286006r4'></a>
<span class='cmbx-10x-x-109'>Example 12.3.4.</span>  </span> Recall the <!-- l. 546 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>⟦</mi><mn>4</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mi>⟧</mi></mrow></math>
error detecting code from Example <a href='#x15-279006r5'>12.2.5<!-- tex4ht:ref: ex:422-code  --></a>: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 547 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mtable class='aligned'><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi></mtd><mtd columnalign='right'></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></mtd> <mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi></mtd>
</mtr><mtr><mtd columnalign='right'></mtd>
   </mtr>                                                                 </mtable>
</mrow></math></td></tr></table>
<!-- l. 554 --><p class='indent'>   This has two stabilisers on 4 qubits, so it encodes 2 logical qubits. Hence, in
order to fully specify the encoder map, we should fix two pairs of anti-commuting
logical operators which commute with the stabilisers and each other.
There are multiple solutions to this problem, so we will just choose one:
</p><table class='equation-star'><tr><td>
<!-- l. 555 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mtable class='aligned'><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi></mtd><mtd columnalign='right'></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></mtd> <mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></mtd> <mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>Z</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi></mtd>
</mtr><mtr><mtd columnalign='right'></mtd>
   </mtr>                                                                 </mtable>
</mrow></math></td></tr></table>
<!-- l. 564 --><p class='indent'>   These all have weight 2, so they will have even overlap with both
stabilisers (and hence commute with them). It is also easy to check that
<!-- l. 564 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></mrow></math>
and all other pairs of logicals commute. We can now use this
data to construct the X-form and Z-form of the encoder for the
<!-- l. 564 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>⟦</mi><mn>4</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mi>⟧</mi></mrow></math> code:
</p><table class='equation'><tr><td>
<!-- l. 565 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 565 --><object id='x15-286007r19' data="svgs/eq-422-encoder.svg" alt="diagram of eq:422-encoder" class="svg-diagram"></object></td><td class='eq-no'>(12.19)</td></tr></table>
   </div>
<!-- l. 568 --><p class='indent'>    So, we have seen how to turn any CSS code described by stabilisers and
logical operators into a phase-free ZX-diagram of its encoder. Conversely, we can
treat <span class='cmti-10x-x-109'>any </span>isometry described by a phase-free ZX diagram as a CSS code just by
computing its generalised parity form. Recall from Chapter <a href='main_htmlch4.html#cnot-circuits-and-phasefree-zxdiagrams'>4<!-- tex4ht:ref: ch:phasefree  --></a> that the
generalised parity form looks like this:
</p>
<div class='center'>
<!-- l. 572 --><p class='noindent'>
</p><!-- l. 573 --><p class='noindent'><object data="svgs/phase-free-nf-qec.svg" alt="diagram of phase-free-nf-qec" class="svg-diagram"></object> </p></div>
<!-- l. 576 --><p class='indent'>   Furthermore if <!-- l. 576 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>
is an isometry, we can conclude from Proposition <a href='main_htmlch4.html#x7-93023r9'>4.2.9<!-- tex4ht:ref: prop:unitary-reduced-is-parity  --></a> that
<!-- l. 576 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>j</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>,
giving us:
</p>
<div class='center'>
<!-- l. 578 --><p class='noindent'>
</p><!-- l. 579 --><p class='noindent'><object data="svgs/phase-free-nf-qec2.svg" alt="diagram of phase-free-nf-qec2" class="svg-diagram"></object> </p></div>
<!-- l. 582 --><p class='indent'>   From this picture, we can immediately read off the
<!-- l. 582 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>m</mi></math> X-stabilisers and
<!-- l. 582 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> X-logical operators
associated with <!-- l. 582 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>.
If do everything colour-reversed, we’ll get a different normal form for the
encoder:
</p>
                                                                     

                                                                     
<div class='center'>
<!-- l. 584 --><p class='noindent'>
</p><!-- l. 585 --><p class='noindent'><object data="svgs/phase-free-nf-qec3.svg" alt="diagram of phase-free-nf-qec3" class="svg-diagram"></object> </p></div>
<!-- l. 588 --><p class='indent'>   from which we can read off the Z-stabilisers and Z-logical operators. In
summary, we have given an efficient procedure for writing a phase-free isometry
from a CSS code with logical operators and for turning any phase-free isometry
into its associated CSS code and logical operators.
</p>
   <h4 class='subsectionHead' id='the-surface-code'><span class='titlemark'>12.3.4   </span> <a id='x15-28700012.3.4'></a>The surface code</h4>
<!-- l. 591 --><p class='noindent'>One particular family of CSS codes has been so well-studied in recent years that
it deserves some special attention. The <span class='cmbx-10x-x-109'>surface code </span>is a family of CSS codes
that encode a single logical qubit in a square (or rectangular) lattice of physical
qubits. Larger lattices define codes with a higher code distance. While they aren’t
the most memory-efficient codes we know about, surface codes have a number of
nice properties coming from this regular geometric structure. For one thing,
they can be implemented using only nearest-neighbour gates on a 2D
architecture, so there is never any need to perform swap gates or otherwise
break planarity.  A second nice feature is that even for surface codes
with very high code distances, we have efficient algorithms for decoding
error syndromes, as we’ll see in Section <a href='#decoding-errors-in-the-surface-code'>12.3.4.1<!-- tex4ht:ref: sec:surface-decoding  --></a> below. Finally, they
serve as a useful baseline for fault-tolerant computation, as we know
(at least in principle) how to implement all the ingredients needed to
implement universal quantum computation on surface-code-encoded qubits
in a fault-tolerant manner. In fact, fault-tolerant computation in the
surface code has one of the best <span class='cmbx-10x-x-109'>thresholds </span>we know about. That is,
they can tolerate quite a bit of noise at the hardware level while still
being able to suppress errors. More on that later. In this section, we will
use the slightly more compact, “rotated” version of the surface code.
Stabilisers are defined as follows. We start with a rectangular lattice with
<!-- l. 593 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>d</mi> <mo class='MathClass-bin' stretchy='false'>×</mo> <mi>e</mi></mrow></math> vertices,
corresponding to qubits. We aim to encode a single logical qubit, so we need to
fix <!-- l. 593 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>de</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
stabilisers. To do so, we first colour in the lattice in a chequerboard
pattern, where each red (darker) area corresponds to an
<!-- l. 593 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
stabiliser on all of its adjacent qubits, whereas each green (lighter) area corresponds
to a <!-- l. 593 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
stabiliser. Colouring the inside of the lattice in this way gives
<!-- l. 593 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>d</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>e</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> stabilisers. To get
all <!-- l. 595 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>de</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math> stabilisers, we
                                                                     

                                                                     
still need to fix <!-- l. 595 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>d</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>e</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn></mrow></math>
additional stabilisers. To get these, we introduce weight-2 stabilisers along the
boundaries at every other edge, which we depict as “blobs”. We colour these
blobs in the opposite colour to the nearest tile, obtaining the following picture:
</p><table class='equation'><tr><td>
<!-- l. 596 --><p class='indent'>
</p><!-- l. 596 --><object id='x15-287001r20' data="svgs/eq-surface9.svg" alt="diagram of eq:surface9" class="svg-diagram"></object></td><td class='eq-no'>(12.20)</td></tr></table>
<!-- l. 599 --><p class='indent'>   There are <!-- l. 599 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mo class='MathClass-open' stretchy='false'>(</mo><mi>d</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><mo class='MathClass-open' stretchy='false'>(</mo><mi>e</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
edges around the whole boundary, so adding a “blob” to every other edge gives
us <!-- l. 599 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mo class='MathClass-open' stretchy='false'>(</mo><mi>d</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><mo class='MathClass-open' stretchy='false'>(</mo><mi>e</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>d</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>e</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn></mrow></math>
more stabilisers as required. By design, all stabilisers of different types overlap
on two qubits, so they commute. Since we alternate edges, one pair of
opposite boundaries (in this case the left and right) will end up with
X-blobs and one pair (top and bottom) with Z-blobs. In the literature,
these are called <span class='cmti-10x-x-109'>X-boundaries </span>and <span class='cmti-10x-x-109'>Z-boundaries</span>, respectively. The logical
<!-- l. 600 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></math> operator consists
of a line of Pauli <!-- l. 600 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
operators connecting the two X-boundaries, whereas the logical
<!-- l. 600 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></math>
operator consists of a line connecting the two Z-boundaries: </p><table class='equation-star'><tr><td>
<!-- l. 601 --><object data="svgs/surface9-logical-X.svg" alt="diagram of surface9-logical-X" class="svg-diagram"></object></td></tr></table>
                                                                     

                                                                     
<!-- l. 604 --><p class='indent'>   Note that the specific choice of path between the boundaries is not important
and we are even allowed to cross tiles diagonally. However, it is important
that the path touches each area of the opposite colour an even number
of times. This ensures that the logical operator commutes with all of
the stabilisers. In the example above we could have equivalently chosen
<!-- l. 604 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>X</mi></mrow><mrow><mn>4</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>5</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>6</mn></mrow></msub></mrow></math> or
<!-- l. 604 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>X</mi></mrow><mrow><mn>5</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>6</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>7</mn></mrow></msub></mrow></math> for
<!-- l. 604 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></math>, but
not <!-- l. 604 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>X</mi></mrow><mrow><mn>7</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>8</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>5</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>6</mn></mrow></msub></mrow></math>,
because the latter touches a green tile 3 times. Using the stabilisers and the
logical operators for the surface code, we can apply the recipe from the previous
section to construct its encoder. In fact, we can represent the encoder using two
equivalent ZX diagrams, one based on the X-stabilisers and one on the
Z-stabilisers: </p><table class='equation'><tr><td>
<!-- l. 606 --><p class='indent'>
</p><!-- l. 606 --><object id='x15-287002r21' data="svgs/eq-surface-encoder.svg" alt="diagram of eq:surface-encoder" class="svg-diagram"></object></td><td class='eq-no'>(12.21)</td></tr></table>
<!-- l. 609 --><p class='indent'>   Note how the diagrams of the encoders have a direct visual relationship to the
picture (<a href='#x15-287001r20'>12.20<!-- tex4ht:ref: eq:surface9  --></a>): to draw the X-stabilisers, we put an X spider on every vertex,
place a Z spider in the centre of each red region in (<a href='#x15-287001r20'>12.20<!-- tex4ht:ref: eq:surface9  --></a>), and connect it to all
of the adjacent vertices. Finally, we “embed” the logical X operator by placing a
Z spider on the input and connecting it to each of the vertices where
<!-- l. 609 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></math> has
support. For the Z-stabilisers, we apply the same routine, reversing the roles of X
and Z. In the surface code, we can topologically deform a logical operator by
multiplying it by any stabiliser. We can perform the same calculation graphically
using strong complementarity. As we saw in the proof of Lemma <a href='main_htmlch4.html#x7-96004r4'>4.3.4<!-- tex4ht:ref: lem:subspace  --></a>, we can
treat spiders as bit-vectors, and by applying strong complementarity, we
can “add” the neighbourhood of one spider to that of another, modulo
2. Applying this concept to the surface code, we obtain for example:
</p><table class='equation'><tr><td>
<!-- l. 611 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 611 --><object id='x15-287003r22' data="svgs/eq-X-encoder-add.svg" alt="diagram of eq:X-encoder-add" class="svg-diagram"></object></td><td class='eq-no'>(12.22)</td></tr></table>
<!-- l. 614 --><p class='indent'>   This just amounts to changing the basis for the linear space
<!-- l. 614 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
represented by this normal form, which has the same effect as changing the
generators for the associated stabiliser group.
</p>
   <h5 class='subsubsectionHead' id='decoding-errors-in-the-surface-code'><span class='titlemark'>12.3.4.1   </span> <a id='x15-28800012.3.4.1'></a>Decoding errors in the surface code</h5>
<!-- l. 616 --><p class='noindent'>Aside from the fact that they can be implemented with nearest-neighbour operations
in a 2D architectures, surface codes are also popular because error syndromes can be
efficiently decoded by taking advantage of their geometric structure. Recall from
Section <a href='#detecting-and-correcting-quantum-errors'>12.2.2<!-- tex4ht:ref: sec:detect-and-correct  --></a> that the <span class='cmbx-10x-x-109'>decoding problem </span>for stabiliser codes refers to the
problem of mapping the outcome of a sydrome measurement to a Pauli correction
<!-- l. 616 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math> that
is most likely to recover our error-free state. There are many proposals for
fast decoders for the surface code. Here, we will sketch how one of the
simplest ones, based on <span class='cmbx-10x-x-109'>minimum weight perfect matching </span>works. First
note that since surface codes are CSS codes, we can identify Z-errors in
<!-- l. 617 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math> using
the outcomes of X stabiliser measurements, and vice-versa. Hence, we can treat
these two types of errors independently. Suppose a certain configuration of Z
errors occurs on our physical qubits. Much as we did in Section <a href='#detecting-and-correcting-quantum-errors'>12.2.2<!-- tex4ht:ref: sec:detect-and-correct  --></a>, we
can figure out where the error syndrome will be by “pushing” the error
through the Pauli projectors corresponding to X measurements, using the
<!-- l. 618 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>-copy
rule, and seeing which projectors end up with a
<!-- l. 618 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>:
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 619 --><object data="svgs/big-surface-proj.svg" alt="diagram of big-surface-proj" class="svg-diagram"></object></td></tr></table>
<!-- l. 622 --><p class='indent'>   This is the same thing as figuring out which stabilisers anti-commute with the given
error. If an even number of Z errors lie in the support of an X projector, a pair of
<!-- l. 622 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math> phases will cancel
out, yielding a <!-- l. 622 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
measurement outcome. Hence, the syndrome only reveals the places where an
odd number of errors overlap with a stabiliser. As a consequence, error
syndromes will always appear as the endpoints of a “path of errors” through the
lattice: </p><table class='equation'><tr><td>
<!-- l. 623 --><p class='indent'>
</p><!-- l. 623 --><object id='x15-288001r23' data="svgs/eq-error-path.svg" alt="diagram of eq:error-path" class="svg-diagram"></object></td><td class='eq-no'>(12.23)</td></tr></table>
<!-- l. 626 --><p class='indent'>   These paths will always either connect a pair of locations where the error
syndrome is 1, as we see above, or they will connect a single syndrome-1 location
to a boundary of the surface, as in this example: </p><table class='equation-star'><tr><td>
<!-- l. 627 --><object data="svgs/big-surface-proj-bound.svg" alt="diagram of big-surface-proj-bound" class="svg-diagram"></object></td></tr></table>
<!-- l. 630 --><p class='indent'>   Since Z boundaries don’t have any X stabiliser measurements, this
also works. Hence, if we get just two syndrome-1 outcomes far from the
                                                                     

                                                                     
boundary, the most likely place errors occurred were along the shortest path
between those two spots (assuming as we have been that errors occur
independently and with the same probability on every qubit, since a
longer path must have involved more errors occurring). If we get just one
syndrome-1 outcome, the most likely place errors occurred was along
the shortest path between that syndrome and the boundary without
non-commuting stabilisers. “Hang on!” you might say, “there can be
multiple shortest paths between points!” And you’d be right. However, all
of these paths are equivalent, up to stabilisers. For example, there are
3 shortest paths between the syndromes in (<a href='#x15-288001r23'>12.23<!-- tex4ht:ref: eq:error-path  --></a>). The 2 other ones
can be obtained from the one shown by multiplying by Z stabilisers:
</p><table class='equation'><tr><td>
<!-- l. 633 --><p class='indent'>
</p><!-- l. 633 --><object id='x15-288002r24' data="svgs/eq-error-path-mod.svg" alt="diagram of eq:error-path-mod" class="svg-diagram"></object></td><td class='eq-no'>(12.24)</td></tr></table>
<!-- l. 636 --><p class='indent'>   Here we started with the diagram (<a href='#x15-288001r23'>12.23<!-- tex4ht:ref: eq:error-path  --></a>), composed with one of the Z
stabilisers that is not shown explicitly in this Z-X normal form. Since stabilisers
don’t change the encoded state, correcting errors along any of these 3 paths (or
actually <span class='cmti-10x-x-109'>any </span>path between these endpoints) will have the same effect. The reason
this works is, as we showed for the logical embedding at the end of the previous
section, the stabilisers of the surface code relate topologically-equivalent
paths through the surface, provided they have the same end points. Of
course, this only tells us what to do if we see zero, one, or two syndrome-1
measurements. However, we can extend this to an algorithm that does a pretty
good job decoding any syndrome. First, we make a graph whose nodes
correspond to places where we observe a syndrome-1 outcome (and an
extra dummy node for the boundary). We label the edges with a weight
indicating the length of the shortest path between those locations, e.g.
</p><table class='equation'><tr><td>
<!-- l. 640 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 640 --><object id='x15-288003r25' data="svgs/eq-syndrome-graph.svg" alt="diagram of eq:syndrome-graph" class="svg-diagram"></object></td><td class='eq-no'>(12.25)</td></tr></table>
<!-- l. 643 --><p class='indent'>   A <span class='cmbx-10x-x-109'>perfect matching </span>is then a subset of the edges of this graph, where every
node (except the “dummy” node for the boundary) is adjacent to exactly 1 edge.
A <span class='cmbx-10x-x-109'>minimum weight perfect matching </span>(MWPM) is a perfect matching where
the sums of the weights on the chosen edges is minimal. An example of a MWPM
for the graph above is:
</p>
<div class='center'>
<!-- l. 645 --><p class='noindent'>
</p><!-- l. 646 --><p class='noindent'><object data="svgs/mwpm2.svg" alt="diagram of mwpm2" class="svg-diagram"></object> </p></div>
<!-- l. 649 --><p class='indent'>   The simplest minimum weight perfect matching decoder therefore proceeds as
follows. For the X stabiliser measurements, make a syndrome graph as in
equation (<a href='#x15-288003r25'>12.25<!-- tex4ht:ref: eq:syndrome-graph  --></a>) and compute its MWPM. Then, correct Z errors along the
paths indicated by the MWPM. After that, rinse and repeat for Z stabiliser
measurements and X errors. It is worth noting that this algorithm does not
always find the minimum weight error associated with a syndrome, but it often
gets pretty close, especially in the case where there aren’t too many syndrome-1
outcomes. It is also very fast, particularly if we are allowed to just approximate
the MWPM and/or compute in parallel. We will briefly discuss various
implementations of this algorithm and their performance in the References of this
chapter.
</p>
   <h4 class='subsectionHead' id='scalable-zx-notation-for-css-codes'><span class='titlemark'>12.3.5   </span> <a id='x15-28900012.3.5'></a>Scalable ZX notation for CSS codes</h4>
<!-- l. 652 --><p class='noindent'>As might be clear from diagrams like (<a href='#x15-286001r17'>12.17<!-- tex4ht:ref: eq:steane-is-gpf  --></a>), writing CSS encoder maps
explicitly can start to get unwieldy for large numbers of stabilisers or stabilisers
with relatively high weight. Later on, we will also want to prove some generalities
about all CSS codes, so it would be useful to come up with some notation for
writing a <span class='cmti-10x-x-109'>generic </span>CSS code as a ZX-diagram. Thankfully, the scalable ZX-calculus,
which was introduced in Section <a href='main_htmlch7.html#scalable-zx-notation'>7.2<!-- tex4ht:ref: sec:scalable-ZX  --></a>, can solve both of these problems. To see
how this works, we can start from the recipe given in the previous section for
building an encoder for a CSS code from its X-logical operators and
X-stabilisers. Suppose we represent this data as a pair of boolean matrices
<!-- l. 653 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub></math> and
<!-- l. 653 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub></math>,
                                                                     

                                                                     
whose columns correspond to each of the operators and whose
rows correspond to qubits, where a 1 indicates the presence of an
<!-- l. 653 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>. For example,
the matrices <!-- l. 653 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
associated with the Steane code are the following: </p><table class='equation-star'><tr><td>
<!-- l. 654 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mrow><mo fence='true' form='prefix'></mo><mrow><mtable class='aligned'><mtr><mtd columnalign='right'><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi></mtd><mtd columnalign='right'></mtd>
</mtr><mtr><mtd columnalign='right'></mtd>
   </mtr>                                                                 </mtable></mrow><mo fence='true' form='postfix'>}</mo></mrow><mspace class='quad' width='1em'></mspace> <mo class='MathClass-rel' stretchy='false'>⇝</mo><mspace class='quad' width='1em'></mspace><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo><msup><mrow>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr>  <!-- *\c@MaxMatrixCols c --></mtable>                                                                  </mrow><mo fence='true' form='postfix'>)</mo></mrow></mrow><mrow><mi>T</mi> </mrow></msup>
</mrow></math></td></tr></table>
   <table class='equation-star'><tr><td>
<!-- l. 666 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mrow><mo fence='true' form='prefix'></mo><mrow><mtable class='aligned'><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi></mtd><mtd columnalign='right'></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>3</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi></mtd>
</mtr><mtr><mtd columnalign='right'></mtd>
   </mtr>                                                                 </mtable></mrow><mo fence='true' form='postfix'>}</mo></mrow><mspace class='quad' width='1em'></mspace> <mo class='MathClass-rel' stretchy='false'>⇝</mo><mspace class='quad' width='1em'></mspace><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo><msup><mrow>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                  </mrow><mo fence='true' form='postfix'>)</mo></mrow></mrow><mrow><mi>T</mi> </mrow></msup>
</mrow></math></td></tr></table>
<!-- l. 682 --><p class='indent'>   Whereas in the previous section, we needed to say in words how to
build the encoder out of X operators, we can now do it succinctly as a
single diagram, which works for any CSS code described by the pair
<!-- l. 682 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>:
</p><table class='equation'><tr><td>
<!-- l. 683 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 683 --><object id='x15-289001r26' data="svgs/eq-encoder-scalable.svg" alt="diagram of eq:encoder-scalable" class="svg-diagram"></object></td><td class='eq-no'>(12.26)</td></tr></table>
<!-- l. 686 --><p class='indent'>   Inspecting this picture, we can indeed see that it is saying to introduce
<!-- l. 686 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
input spiders for the X-logicals, and connect them according to where
<!-- l. 686 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>’s appear, then
introduce <!-- l. 686 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>m</mi></math>
internal spiders for the X-stabilisers and again connect them to outputs according to
where <!-- l. 686 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>’s
appear. This gives us the X form for the encoder, but of course we should also be
able to construct a Z form by reversing the role of the two colours of spider. To
get the colour reverse of a matrix arrow, we can just reverse the direction and
take the transpose of the matrix: </p><table class='equation'><tr><td>
<!-- l. 688 --><p class='indent'>
</p><!-- l. 688 --><object id='x15-289002r27' data="svgs/eq-arrow-color-rev.svg" alt="diagram of eq:arrow-color-rev" class="svg-diagram"></object></td><td class='eq-no'>(12.27)</td></tr></table>
<!-- l. 692 --><p class='indent'>   Hence, if we equivalently present a CSS code as a pair of matrices
<!-- l. 692 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>L</mi></mrow><mrow><mi>Z</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>S</mi></mrow><mrow><mi>Z</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
describing the Z-logical operators and Z-stabilisers, respectively, we can write the
associated encoder map as: </p><table class='equation'><tr><td>
<!-- l. 693 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 693 --><object id='x15-289003r28' data="svgs/eq-encoder-scalable-Z.svg" alt="diagram of eq:encoder-scalable-Z" class="svg-diagram"></object></td><td class='eq-no'>(12.28)</td></tr></table>
<!-- l. 696 --><p class='indent'>   This not only gives us convenient notation for the encoder, but also for the
stabiliser measurements themselves. It was shown in Exercise <a href='main_htmlch6.html#x9-136022r7'>6.7<!-- tex4ht:ref: exer:zzz-xxx-meas  --></a> that the Pauli
projectors associated to all-X or all-Z Pauli stabiliser measurements take a
particularly simple form: </p><table class='equation-star'><tr><td>
<!-- l. 697 --><object data="svgs/pproj-zzz-s.svg" alt="diagram of pproj-zzz-s" class="svg-diagram"></object></td></tr></table>
<!-- l. 700 --><p class='indent'>   If <!-- l. 700 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>s</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>, the projector
on to a stabiliser <!-- l. 700 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>j</mi></mrow></msub></math>
consists of an isolated X-spider connected to Z-spiders on the support of the
<!-- l. 700 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>j</mi></mrow></msub></math>. If we
compose all of the projectors on to Z-stabilisers together and fuse spiders, we’ll
obtain this picture: </p><table class='equation'><tr><td>
<!-- l. 701 --><p class='indent'>
</p><!-- l. 701 --><object id='x15-289004r29' data="svgs/eq-z-stab-proj.svg" alt="diagram of eq:z-stab-proj" class="svg-diagram"></object></td><td class='eq-no'>(12.29)</td></tr></table>
<!-- l. 704 --><p class='indent'>   Similarly, if we project on to the 0 outcome with all of the X stabilisers, we’ll
obtain: </p><table class='equation'><tr><td>
<!-- l. 705 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 705 --><object id='x15-289005r30' data="svgs/eq-x-stab-proj.svg" alt="diagram of eq:x-stab-proj" class="svg-diagram"></object></td><td class='eq-no'>(12.30)</td></tr></table>
   <div class='newtheorem'>
<!-- l. 708 --><p class='noindent'><span class='head'>
<a id='x15-289006r9'></a>
<span class='cmbx-10x-x-109'>Exercise 12.9.</span>  </span> Show that for any <!-- l. 709 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>,
the following maps are always projectors, up to a scalar:
</p>
<div class='center'>
<!-- l. 711 --><p class='noindent'>
</p><!-- l. 712 --><p class='noindent'><object data="svgs/idempotent-forms.svg" alt="diagram of idempotent-forms" class="svg-diagram"></object> </p></div>
   </div>
<!-- l. 715 --><p class='indent'>    If we simply compose maps (<a href='#x15-289004r29'>12.29<!-- tex4ht:ref: eq:z-stab-proj  --></a>) and (<a href='#x15-289005r30'>12.30<!-- tex4ht:ref: eq:x-stab-proj  --></a>), we will get the projection onto the
stabiliser subspace <!-- l. 716 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>Stab</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
This is what happens if we measure all of the stabilisers and
get outcome 0. To represent other outcomes, we should place a
<!-- l. 716 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math> or a
<!-- l. 716 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math> on each
of the internal spiders of the Pauli projections. To do this for generic outcomes,
we need to extend the scalable notation a bit. Back when we introduced the
scalable notation, we interpreted a scalable spider labelled by a phase
<!-- l. 717 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math> as
<!-- l. 717 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> spiders, all with
the same phase <!-- l. 717 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math>
on them. However, we could just as well label a spider with a vector of different
phases <!-- l. 718 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>α</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>α</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>α</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
and define scalable spiders as: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 719 --><object data="svgs/scalable-z-vec-1.svg" alt="diagram of scalable-z-vec-1" class="svg-diagram"></object></td></tr></table>
<!-- l. 722 --><p class='indent'>   Of particular interest for us are vectors of
<!-- l. 722 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>s and
<!-- l. 722 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>s, i.e. vectors of
the form <!-- l. 722 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>π</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>b</mi></mrow><mrow><mn>1</mn></mrow></msub><mi>π</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>b</mi></mrow><mrow><mi>n</mi></mrow></msub><mi>π</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> for some
boolean vector <!-- l. 722 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo> <msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msubsup></mrow></math>.
Using this extended notation, a full stabiliser measurement for a CSS code with outcome
syndrome <!-- l. 723 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
can be written compactly as: </p><table class='equation'><tr><td>
<!-- l. 724 --><p class='indent'>
</p><!-- l. 724 --><object id='x15-289007r31' data="svgs/eq-css-syndrome-scalable.svg" alt="diagram of eq:css-syndrome-scalable" class="svg-diagram"></object></td><td class='eq-no'>(12.31)</td></tr></table>
<!-- l. 727 --><p class='indent'>   For a CSS code, we can assume without loss of generality that all of the X-logical
operators and X-stabilisers are linearly independent. In other words, we can assume the
block matrix <!-- l. 727 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub><mspace class='nbsp' width='0.33em'></mspace><mspace class='nbsp' width='0.33em'></mspace><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
is injective. Consequently, there exists some parity matrix
<!-- l. 727 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>J</mi></math> such
that: </p><table class='equation'><tr><td>
<!-- l. 728 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 728 --><object id='x15-289008r32' data="svgs/eq-encoder-one-sided-inverse.svg" alt="diagram of eq:encoder-one-sided-inverse" class="svg-diagram"></object></td><td class='eq-no'>(12.32)</td></tr></table>
<!-- l. 731 --><p class='indent'>   Since injective parity maps are always isometries, we have: </p><table class='equation'><tr><td>
<!-- l. 732 --><p class='indent'>
</p><!-- l. 732 --><object id='x15-289009r33' data="svgs/eq-encoder-isometry-strong.svg" alt="diagram of eq:encoder-isometry-strong" class="svg-diagram"></object></td><td class='eq-no'>(12.33)</td></tr></table>
<!-- l. 735 --><p class='indent'>   This implies that the encoder (<a href='#x15-289003r28'>12.28<!-- tex4ht:ref: eq:encoder-scalable-Z  --></a>) is an isometry, and is in fact a strictly
stronger condition.
</p>
   <div class='newtheorem'>
<!-- l. 736 --><p class='noindent'><span class='head'>
<a id='x15-289010r10'></a>
<span class='cmbx-10x-x-109'>Exercise* 12.10.</span>  </span>In Exercise <a href='#x15-281007r5'>12.5<!-- tex4ht:ref: exer:logical-operators-comm  --></a>, you were asked to show that for logical operators,
<!-- l. 737 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><msub><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mrow><mi>i</mi></mrow></msub></mrow><mo accent='true'>→</mo></mover></math> anti-commutes
with <!-- l. 737 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><msub><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mrow><mi>j</mi></mrow></msub></mrow><mo accent='true'>→</mo></mover></math> if and
only if <!-- l. 737 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>j</mi></mrow></math>.
We can express this condition in terms of boolean matrices by stating that
<!-- l. 737 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>L</mi></mrow><mrow><mi>Z</mi></mrow><mrow><mi>T</mi> </mrow></msubsup><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>. In
terms of scalable notation, this implies that: </p><table class='equation'><tr><td>
<!-- l. 738 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 738 --><object id='x15-289011r34' data="svgs/eq-logical-anticommute.svg" alt="diagram of eq:logical-anticommute" class="svg-diagram"></object></td><td class='eq-no'>(12.34)</td></tr></table>
<!-- l. 741 --><p class='indent'>   We also know that stabilisers should commute with logical operators
and with each other. In terms of matrices, we can express this as
<!-- l. 741 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>S</mi></mrow><mrow><mi>Z</mi></mrow><mrow><mi>T</mi> </mrow></msubsup><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msubsup><mrow><mi>S</mi></mrow><mrow><mi>Z</mi></mrow><mrow><mi>T</mi> </mrow></msubsup><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msubsup><mrow><mi>L</mi></mrow><mrow><mi>Z</mi></mrow><mrow><mi>T</mi> </mrow></msubsup><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>.
Pictorially: </p><table class='equation'><tr><td>
<!-- l. 742 --><p class='indent'>
</p><!-- l. 742 --><object id='x15-289012r35' data="svgs/eq-logical-commute.svg" alt="diagram of eq:logical-commute" class="svg-diagram"></object></td><td class='eq-no'>(12.35)</td></tr></table>
<!-- l. 745 --><p class='indent'>   Give a graphical derivation of (<a href='#x15-289011r34'>12.34<!-- tex4ht:ref: eq:logical-anticommute  --></a>) and (<a href='#x15-289012r35'>12.35<!-- tex4ht:ref: eq:logical-commute  --></a>) using just (<a href='#x15-289003r28'>12.28<!-- tex4ht:ref: eq:encoder-scalable-Z  --></a>), the
scalable ZX rules, and the fact that the encoder is an isometry. <span class='cmti-10x-x-109'>Hint: Start
by composing the Z-form of the encoder with its adjoint and applying
idempotence to remove one projector from the middle before applying</span>
(<a href='#x15-289003r28'>12.28<!-- tex4ht:ref: eq:encoder-scalable-Z  --></a>)<span class='cmti-10x-x-109'>.</span>
</p>
   </div>
<!-- l. 749 --><p class='indent'>     This gives us some nice tools for working with CSS codes generically, which
we’ll use several times when it comes to deriving fault-tolerant operations in
Section <a href='#faulttolerance'>12.4<!-- tex4ht:ref: sec:fault-tolerance  --></a>.
</p>
   <h3 class='sectionHead' id='faulttolerance'><span class='titlemark'>12.4   </span> <a id='x15-29000012.4'></a>Fault-tolerance</h3>
<!-- l. 778 --><p class='noindent'>If we want to perform quantum computations in a way that can withstand errors,
coming up with a good quantum error correcting code is only half the story. We also
need to figure out how to perform state preparations, gates, and measurements on
encoded qubits. Suppose that every time we performed a gate we had to decode our
<!-- l. 779 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> physical
qubits into <!-- l. 779 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
logical qubits, perform the gate, then re-encode. This seems like a lot of work
                                                                     

                                                                     
just to do one gate, but what is actually worse is that our logical state
will be completely unprotected between when we decode and re-encode
our qubits. We will run into similar problems with state preparations
and measurements. We saw half of a solution to this problem already in
Section <a href='#encoders-and-logical-operators'>12.2.3<!-- tex4ht:ref: sec:encoder  --></a> with Definition <a href='#x15-281001r9'>12.2.9<!-- tex4ht:ref: def:implement-logical  --></a>. If we want to perform a unitary gate
<!-- l. 780 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> on our logical qubits,
we can find some other <!-- l. 780 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math>
acting on the physical qubits, satisfying:
</p>
<div class='center'>
<!-- l. 782 --><p class='noindent'>
</p><!-- l. 783 --><p class='noindent'><object data="svgs/ftqc-U.svg" alt="diagram of ftqc-U" class="svg-diagram"></object> </p></div>
<!-- l. 786 --><p class='indent'>   Essentially the same idea applies to state preparations, except
there are no input wires, so we don’t need an encoder on the
RHS. That is, we can implement the preparation of a logical state
<!-- l. 786 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> by preparing some
physical state <!-- l. 786 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>ψ</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
satisfying:
</p>
<div class='center'>
<!-- l. 788 --><p class='noindent'>
</p><!-- l. 789 --><p class='noindent'><object data="svgs/ftqc-psi.svg" alt="diagram of ftqc-psi" class="svg-diagram"></object> </p></div>
<!-- l. 792 --><p class='indent'>   Of course, one could prepare <!-- l. 792 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>ψ</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
by preparing <!-- l. 792 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
then performing the encoder isometry as an actual quantum operation,
which we could implement using unitaries and ancillae. However,
as we’ll see later, there are various reasons we might want to prepare
<!-- l. 792 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>ψ</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
directly in a different way. Finally, implementing measurements on encoded
qubits is also a similar idea, but with a little twist accounting for the fact that
our physical measurement might have more outcomes than our logical one. While
we might in general want to implement arbitrary measurements on encoded
qubits, lets focus just on ONB measurements to make things a bit simpler. Let
<!-- l. 794 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>m</mi><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math> be a finite set of indices
for any <!-- l. 794 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>m</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℕ</mi></mrow></math>. We say a physical
ONB measurement <!-- l. 794 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>M</mi></mstyle></mrow><mo accent='true'>~</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mover accent='true'><mrow><mi>ϕ</mi></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>}</mo></mrow><mrow><mi>j</mi></mrow></msub></mrow></math>
on <!-- l. 794 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
                                                                     

                                                                     
qubits implements a logical ONB measurement
<!-- l. 794 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>M</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>}</mo></mrow><mrow><mi>i</mi></mrow></msub></mrow></math> on
<!-- l. 794 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> qubits if there
exists a function <!-- l. 794 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℓ</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <mo class='MathClass-open' stretchy='false'>[</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-rel' stretchy='false'>→</mo> <mo class='MathClass-open' stretchy='false'>[</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
where, for all states <!-- l. 794 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
we have: </p><table class='equation'><tr><td>
<!-- l. 795 --><p class='indent'>
</p><!-- l. 795 --><object id='x15-290001r36' data="svgs/eq-ft-meas.svg" alt="diagram of eq:ft-meas" class="svg-diagram"></object></td><td class='eq-no'>(12.36)</td></tr></table>
<!-- l. 798 --><p class='indent'>   This condition says that, for any logical state, the Born rule probabilities obtained from
measuring <!-- l. 798 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>M</mi></mstyle></math>
can be computed in terms of the probabilities of
<!-- l. 798 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mstyle mathvariant='script'><mi>M</mi></mstyle></mrow><mo accent='true'>~</mo></mover></math> measurements.
Usually the function <!-- l. 798 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℓ</mi></math>
is very simple, e.g. if <!-- l. 798 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>,
it could be simply computing the parity of boolean outcomes on the
<!-- l. 798 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
physical qubits. In Section <a href='#encoders-and-logical-operators'>12.2.3<!-- tex4ht:ref: sec:encoder  --></a>, we mentioned that we usually don’t actually
perform the encoder map on our quantum computer, but use it purely as a
mathematical object to relate the logical qubits to the physical ones. Now
we can see why that is the case. If we can find encoded states, gates,
and measurements, then we can simulate any logical computation on
<!-- l. 799 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> qubits using a physical
one on <!-- l. 799 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> qubits without
ever explicitly performing <!-- l. 799 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>.
Suppose we are interested in the results of a logical computation involving applying a sequence
of gates <!-- l. 800 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>U</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>U</mi></mrow><mrow><mi>t</mi></mrow></msub></mrow></math> to a state
<!-- l. 800 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> and measuring in
the logical ONB <!-- l. 800 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>}</mo></mrow><mrow><mi>i</mi></mrow></msub></math>.
Then we would like to sample from this distribution: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 801 --><object data="svgs/logical-to-physical.svg" alt="diagram of logical-to-physical" class="svg-diagram"></object></td></tr></table>
<!-- l. 804 --><p class='indent'>   Then, we can translate the logical measurement into a physical measurement
using (<a href='#x15-290001r36'>12.36<!-- tex4ht:ref: eq:ft-meas  --></a>): </p><table class='equation-star'><tr><td>
<!-- l. 805 --><object data="svgs/logical-to-physical1.svg" alt="diagram of logical-to-physical1" class="svg-diagram"></object></td></tr></table>
<!-- l. 808 --><p class='indent'>   We can keep pushing logical gates through the encoder to get physical ones:
</p><table class='equation-star'><tr><td>
<!-- l. 809 --><object data="svgs/logical-to-physical2.svg" alt="diagram of logical-to-physical2" class="svg-diagram"></object></td></tr></table>
<!-- l. 812 --><p class='indent'>   Finally, when we push the logical state through, the encoder is gone, and
we’re left with a fully encoded computation that simulates our logical
computation: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 813 --><object data="svgs/logical-to-physical3.svg" alt="diagram of logical-to-physical3" class="svg-diagram"></object></td></tr></table>
<!-- l. 816 --><p class='indent'>   Great! We’re doing everything on physical qubits encoded in our error
correcting code the whole time. We only forgot one thing: we need to do error
correction! That was of course the point of this whole exercise. If we are being
particularly conservative, we can do one or more rounds of error correction, i.e.
measuring all of the stabilisers and applying a Pauli correction, at each step of
the computation:
</p>
<div class='center'>
<!-- l. 818 --><p class='noindent'>
</p><!-- l. 819 --><p class='noindent'><object data="svgs/full-ft.svg" alt="diagram of full-ft" class="svg-diagram"></object> </p></div>
<!-- l. 822 --><p class='indent'>   We should also try to engineer our encoded operations, and the error correction
itself, in such a way that they avoid spreading errors uncontrollably. For example,
if <!-- l. 822 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></math>
involves multi-qubit gates, this turns a single error into multiple errors. In this
section, we will see how to implement (almost) everything we need for universal
computation in such a way that we can keep errors under control. This property
of encoded gates is what is known as <span class='cmti-10x-x-109'>fault tolerance</span>. There are several definitions
of fault tolerance in the literature, with various levels of mathematical rigour.
Here’s the one we will use. Note that we refer to a single collection of
<!-- l. 823 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
physical qubits encoded in an error correcting code as a <span class='cmbx-10x-x-109'>code block</span>.
</p>
   <div class='newtheorem'>
<!-- l. 824 --><p class='noindent'><span class='head'>
<a id='x15-290002r1'></a>
<span class='cmbx-10x-x-109'>Definition 12.4.1 </span>(Fault tolerance)<span class='cmbx-10x-x-109'>.</span>  </span> An operation <!-- l. 825 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>O</mi></mrow><mo accent='true'>~</mo></mover></math>
on a single code block is called <span class='cmbx-10x-x-109'>fault tolerant </span>if, whenever there are errors
on at most <!-- l. 825 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math>
qubits before applying <!-- l. 825 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>O</mi></mrow><mo accent='true'>~</mo></mover></math>,
                                                                     

                                                                     
and then <!-- l. 825 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math>
faults occur while performing <!-- l. 825 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>O</mi></mrow><mo accent='true'>~</mo></mover></math>,
there are errors on at most <!-- l. 825 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>u</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>v</mi></mrow></math>
qubits afterwards.
</p>
   </div>
<!-- l. 826 --><p class='indent'>    An example of an operation that doesn’t spread errors is a <span class='cmbx-10x-x-109'>transversal
gate</span>. For a single code block, transversal gates are simply tensor products of
single-qubit operations. An example of something that does spread errors is a
multi-qubit gate involving physical qubits in the same code block. For example,
a CNOT gate can spread Pauli X errors from its control to its target
qubit:
</p>
<div class='center'>
<!-- l. 829 --><p class='noindent'>
</p><!-- l. 830 --><p class='noindent'><object data="svgs/cnot-spread-x.svg" alt="diagram of cnot-spread-x" class="svg-diagram"></object> </p></div>
<!-- l. 833 --><p class='indent'>   In this case, there was originally 1 error on the physical qubits,
but afterwards there are 2. Note that we were not too specific
about what it means for a fault to occur during the performance of
<!-- l. 834 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>O</mi></mrow><mo accent='true'>~</mo></mover></math>.
What counts as a single fault depends on how we represent the operation
<!-- l. 834 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>O</mi></mrow><mo accent='true'>~</mo></mover></math> and how
we will choose to model potential errors that could happen while attempting to
perform <!-- l. 834 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>O</mi></mrow><mo accent='true'>~</mo></mover></math>,
i.e. the <span class='cmbx-10x-x-109'>error model </span>we are using. By their nature, error models are always a
simplification of what happens in reality. One of the simplest error models is the
<span class='cmbx-10x-x-109'>phenomenological error model </span>with Pauli errors. In this model, we decompose
<!-- l. 834 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>O</mi></mrow><mo accent='true'>~</mo></mover></math>
into basic gates and assume at each time step, a Pauli error could
occur on each qubit with some fixed (hopefully small) probability
<!-- l. 834 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>p</mi></math>.
Consider implementing a swap gate on our physical qubits with three CNOT
gates:
</p>
<div class='center'>
<!-- l. 837 --><p class='noindent'>
</p><!-- l. 838 --><p class='noindent'><object data="svgs/swap-ft.svg" alt="diagram of swap-ft" class="svg-diagram"></object> </p></div>
                                                                     

                                                                     
<!-- l. 841 --><p class='indent'>   The swap gate never multiplies Pauli errors. So, if
<!-- l. 841 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math> Pauli errors
occur at <!-- l. 841 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>t</mi></mrow><mrow><mn>0</mn></mrow></msub></math>, then
only <!-- l. 841 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math> errors will
come out at <!-- l. 841 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msub></math>.
However, if an error happens in the process of implementing
<!-- l. 841 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>O</mi></mrow><mo accent='true'>~</mo></mover></math>, e.g. an X error
on qubit 2 at <!-- l. 841 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msub></math>,
then it will propagate to X errors on qubits 2 and 5 at
<!-- l. 841 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msub></math>. In
some circumstances, this model is somewhat overly optimistic. For example, one
would expect that most physical implementations of 2-qubit gates can actually
lead to correlated errors on the qubits involved, while we just assume that an
error happens on each of the qubits independently with some fixed probability.
However, this will be good enough for our purposes of illustrating the basic
principles of constructing fault-tolerant implementations. For more elaborate and
realistic error models, we point to the References of this chapter. We’ll conclude
this section by noting that Definition <a href='#x15-290002r1'>12.4.1<!-- tex4ht:ref: def:fault-tolerant  --></a> extends to a slightly more
flexible notion of “not spreading errors” when multiple code blocks are
involved.
</p>
   <div class='newtheorem'>
<!-- l. 844 --><p class='noindent'><span class='head'>
<a id='x15-290003r2'></a>
<span class='cmbx-10x-x-109'>Definition 12.4.2 </span>(Multi-block fault tolerance)<span class='cmbx-10x-x-109'>.</span>  </span> An operation <!-- l. 845 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>O</mi></mrow><mo accent='true'>~</mo></mover></math>
on <!-- l. 845 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi></math>
code blocks is called <span class='cmbx-10x-x-109'>fault tolerant </span>if, whenever <!-- l. 845 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>u</mi></mrow><mrow><mi>b</mi></mrow></msub></mrow></math>
errors only occur within each code block, and <!-- l. 845 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math>
faults occur with performing <!-- l. 845 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>O</mi></mrow><mo accent='true'>~</mo></mover></math>,
then afterwards at most <!-- l. 845 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>u</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>v</mi></mrow></math>
errors occur in each code block.
</p>
   </div>
<!-- l. 846 --><p class='indent'>    This definition allows errors to propagate between the code blocks,
as long the number of errors appearing in a <span class='cmti-10x-x-109'>single </span>block after the
operation don’t exceed the total number of errors from before the
operation. Consider for example applying a CNOT gate between the
<!-- l. 847 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>-th qubit of one
codeblock and the <!-- l. 847 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>-th
qubit of another one: </p><table class='equation'><tr><td>
<!-- l. 848 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 848 --><object id='x15-290004r37' data="svgs/eq-trans-cnot.svg" alt="diagram of eq:trans-cnot" class="svg-diagram"></object></td><td class='eq-no'>(12.37)</td></tr></table>
<!-- l. 851 --><p class='indent'>   Then errors could indeed multiply:
</p>
<div class='center'>
<!-- l. 853 --><p class='noindent'>
</p><!-- l. 854 --><p class='noindent'><object data="svgs/trans-cnot-1.svg" alt="diagram of trans-cnot-1" class="svg-diagram"></object> </p></div>
<!-- l. 857 --><p class='indent'>   Even though there are a total of 4 errors after performing this tower of
CNOT gates, there are only 2 errors in each code block, which is the same as the
number of errors we started with. This is still okay for fault tolerance, as we can
then perform error correction independently on each code block. The map (<a href='#x15-290004r37'>12.37<!-- tex4ht:ref: eq:trans-cnot  --></a>)
is an example of a transversal, multi-block operation. We will look at these, and
transversal gates in general, in the next section. After that, we will turn to the
somewhat trickier issue of fault-tolerant stabiliser measurements. We call a recipe
for constructing a universal set of fault-tolerant operations in a given code or
code family a <span class='cmbx-10x-x-109'>fault-tolerant scheme</span>. It makes intuitive sense that
having a fault-tolerant scheme is A Good Thing if we want to get to the
end of a computation with a relatively low probability of suffering an
uncorrectable error. But we can make it more precise why this is the case
by discussing the <span class='cmbx-10x-x-109'>threshold </span>of a fault-tolerant scheme. While we can
never push the probability of a logical error occurring all the way to zero,
one could imagine having an infinite series of fault-tolerant simulations
<!-- l. 861 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>FT</mtext></mstyle></mrow><mrow><mi>l</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>C</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>}</mo></mrow><mrow><mi>l</mi><mo class='MathClass-rel' stretchy='false'>∈</mo><mi>ℕ</mi></mrow></msub></math> of a given
circuit <!-- l. 861 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math>,
each producing a better and better approximation of a logical circuit
<!-- l. 861 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math> on
physical hardware, at the cost of extra resources needed to do more and more
error correction. The main example of such a series would be an infinite family of
quantum error correcting codes with increasing distance, such as the surface
code, and recipes for implementing a universal family of fault-tolerant operations
<!-- l. 861 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>O</mi></mrow><mo accent='true'>~</mo></mover></math> on an
any code in that family.
</p>
   <div class='newtheorem'>
                                                                     

                                                                     
<!-- l. 862 --><p class='noindent'><span class='head'>
<a id='x15-290005r3'></a>
<span class='cmbx-10x-x-109'>Definition 12.4.3.</span>  </span> The <span class='cmbx-10x-x-109'>threshold </span>of a fault-tolerant scheme is a probability
<!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>p</mi></mrow><mrow><mi mathvariant='italic'>th</mi></mrow></msub></math>
such that for any circuit <!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math>,
if all physical operations produce a fault with probability <!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>p</mi> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <msub><mrow><mi>p</mi></mrow><mrow><mi mathvariant='italic'>th</mi></mrow></msub></mrow></math>,
the family of fault-tolerant simulations <!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>FT</mtext></mstyle></mrow><mrow><mi>l</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>C</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>}</mo></mrow><mrow><mi>l</mi><mo class='MathClass-rel' stretchy='false'>∈</mo><mi>ℕ</mi></mrow></msub></math>
has the property that for any <!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝜖</mi> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>0</mn></mrow></math>,
there exists some <!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>l</mi></math>
such that the output probabilities of <!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>FT</mtext></mstyle></mrow><mrow><mi>l</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>C</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
are <!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜖</mi></math>-close
to those of the ideal circuit <!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math>.
</p>
   </div>
<!-- l. 864 --><p class='indent'>    The notion of a threshold is an important one, and perhaps the most
important in fault-tolerant quantum computation. Performing encoded
operations and error correction involves more basic quantum operations, which of
course will produce more errors. However, under some critical hardware
error rate, a fault-tolerant scheme will start to suppress more errors than
it generates. This means that, if we can demonstrate a threshold, it is
possible (at least in principle), to perform arbitrarily large quantum
computations on noisy hardware. The <span class='cmbx-10x-x-109'>threshold theorem </span>states that, under
certain assumptions, <span class='cmti-10x-x-109'>any </span>universal set of fault-tolerant operations can
be turned into a family of fault-tolerant simulations with a threshold
<!-- l. 866 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi mathvariant='italic'>th</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>0</mn></mrow></math>,
and furthermore the overhead scales reasonably in the size of the circuit
<!-- l. 866 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math> and error
parameter <!-- l. 866 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜖</mi></math>.
Proving this theorem is complicated, so we will leave it to other resources that
have done this in detail (see the Reference), and we will proceed now to the
<span class='cmti-10x-x-109'>practical </span>construction of fault-tolerant operations in a given error-correcting
code.
</p>
   <h4 class='subsectionHead' id='faulttolerant-computation-with-transversal-gates'><span class='titlemark'>12.4.1   </span> <a id='x15-29100012.4.1'></a>Fault-tolerant computation with transversal gates</h4>
<!-- l. 868 --><p class='noindent'>Transversal unitary gates are the easiest kind of fault-tolerant operation to
understand, although for a given error correcting code, it can be highly
non-trivial to characterise the set of transversal gates that can be implemented in
that code.
</p>
                                                                     

                                                                     
   <div class='newtheorem'>
<!-- l. 869 --><p class='noindent'><span class='head'>
<a id='x15-291001r4'></a>
<span class='cmbx-10x-x-109'>Definition 12.4.4.</span>  </span>A <span class='cmbx-10x-x-109'>transversal implementation </span><!-- l. 870 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math>
of a logical unitary <!-- l. 870 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
on a single code block is a gate of the form <!-- l. 870 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>U</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mo>…</mo> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <msub><mrow><mi>U</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></math>
where the <!-- l. 870 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mi>i</mi></mrow></msub></math>
are all single-qubit unitaries. A transversal implementation of a logical unitary
acting on multiple code blocks consists of <!-- l. 870 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
unitaries each acting only on the <!-- l. 870 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>-th
qubit of each code block, for <!-- l. 870 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi></mrow></math>.
</p>
   </div>
<!-- l. 871 --><p class='indent'>    An example of a transversal unitary on multiple code blocks is the
transversal CNOT we saw in (<a href='#x15-290004r37'>12.37<!-- tex4ht:ref: eq:trans-cnot  --></a>). It is easy to check that transversal gates
satisfy the fault-tolerance conditions laid out in Definitions <a href='#x15-290002r1'>12.4.1<!-- tex4ht:ref: def:fault-tolerant  --></a> and <a href='#x15-290003r2'>12.4.2<!-- tex4ht:ref: def:mq-fault-tolerant  --></a>.
So, if we can find a universal set of transversal gates, life is good! Unfortunately,
there is this little nugget:
</p>
   <div class='newtheorem'>
<!-- l. 873 --><p class='noindent'><span class='head'>
<a id='x15-291002r5'></a>
<span class='cmbx-10x-x-109'>Theorem 12.4.5 </span>(<span class='cmbx-10x-x-109'>Eastin-Knill</span>)<span class='cmbx-10x-x-109'>.</span>  </span> For any error-correcting code capable
of  detecting  an  arbitrary  single-qubit  error,  the  set  of  logical  unitaries
<!-- l. 874 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
with                   a                   transversal                   implementation
<!-- l. 874 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math>
is finite. In particular, no non-trivial error-correcting code has a universal
set of transversal gates.
</p>
   </div>
<!-- l. 875 --><p class='indent'>    The proof of this theorem uses some tricks from Lie theory
which are a bit technical for our purposes, so we won’t reproduce it
here (see the References). Very roughly, the proof shows that the
error-detection property of the code forces the group of distinct unitaries
<!-- l. 876 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> with
transversal implementations to be discrete: there is no way to “nudge”
<!-- l. 876 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
a small distance in any direction, while keeping
                                                                     

                                                                     
<!-- l. 876 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math>
transversal. But then the group of all logical unitaries must also be compact, and
any discrete subgroup of a compact group is finite. If that explanation didn’t
do much for you, don’t worry. The main thing you should get is that
Theorem <a href='#x15-291002r5'>12.4.5<!-- tex4ht:ref: thm:eastin-knill  --></a> is Bad News if we were hoping to do all of our fault-tolerant
computation with transversal gates. However, many codes still have lots of useful
transversal gates. Also, as we’ll see in Section <a href='#magic-state-distillation'>12.5<!-- tex4ht:ref: sec:magic-state-distillation  --></a>, we can still achieve universal
computation fault-tolerantly, but we’ll need to go beyond transversal unitaries to
find a bit of extra magic.
</p>
   <h5 class='subsubsectionHead' id='transversal-clifford-gates'><span class='titlemark'>12.4.1.1   </span> <a id='x15-29200012.4.1.1'></a>Transversal Clifford gates</h5>
<!-- l. 879 --><p class='noindent'>Transversal Clifford gates are usually the easiest fault-tolerant operations to
understand for stabiliser codes. In the general case, we can use stabiliser theory
to find the transversal gates of a stabiliser code and compute how they act on
logical qubits.
</p>
   <div class='newtheorem'>
<!-- l. 882 --><p class='noindent'><span class='head'>
<a id='x15-292001r11'></a>
<span class='cmbx-10x-x-109'>Exercise 12.11.</span>  </span> Let <!-- l. 883 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>
be a Clifford encoder of a stabiliser code <!-- l. 883 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>S</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><msub><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
and <!-- l. 883 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math>
a Clifford unitary. We will show that if we can push stabilisers through
<!-- l. 884 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math>,
meaning that for all <!-- l. 884 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo><mstyle mathvariant='script'><mi>S</mi></mstyle></mrow></math>
there exists <!-- l. 884 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>T</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo><mstyle mathvariant='script'><mi>S</mi></mstyle></mrow></math>
such that <!-- l. 884 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover><mover accent='true'><mrow><mi>T</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>,
that then there exists some Clifford unitary <!-- l. 884 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>,
such that <!-- l. 884 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math>
implements <!-- l. 884 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>:
</p>
<div class='center'>
<!-- l. 886 --><p class='noindent'>
</p><!-- l. 887 --><p class='noindent'><object data="svgs/ftqc-U.svg" alt="diagram of ftqc-U" class="svg-diagram"></object> </p></div>
<!-- l. 890 --><p class='indent'>
                                                                     

                                                                     
   </p><dl class='enumerate'><dt class='enumerate'>
a) </dt><dd class='enumerate'>
   <!-- l. 891 --><p class='noindent'>Let <!-- l. 891 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mrow><mi>i</mi></mrow></msub></math>
   and <!-- l. 891 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mrow><mi>i</mi></mrow></msub></math>
   be the <!-- l. 891 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
   implementations of the logical Paulis <!-- l. 891 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>Z</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>Z</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></math>
   and <!-- l. 891 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>X</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>X</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></math>
   (i.e. <!-- l. 891 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>E</mi><msub><mrow><mi>Z</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mrow><mi>i</mi></mrow></msub><mi>E</mi></mrow></math>).
   Show, using the the result of Exercise <a href='#x15-281008r6'>12.6<!-- tex4ht:ref: exer:stabiliser-commutation  --></a>, that <!-- l. 891 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math>
   maps each <!-- l. 891 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mrow><mi>i</mi></mrow></msub></math>
   and <!-- l. 891 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mrow><mi>i</mi></mrow></msub></math>
   to a non-trivial product of the <!-- l. 891 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mrow><mi>i</mi></mrow></msub></math>
   and <!-- l. 891 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mrow><mi>i</mi></mrow></msub></math>.
   <span class='cmti-10x-x-109'>Hint: Doing it for the </span><!-- l. 892 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math><span class='cmti-10x-x-109'>’s
   and </span><!-- l. 892 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math><span class='cmti-10x-x-109'>’s
   is analogous. Note that </span><!-- l. 892 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
   <span class='cmti-10x-x-109'>is a maximal commutative stabiliser group that must be mapped under
   conjugation by </span><!-- l. 892 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math>
   <span class='cmti-10x-x-109'>to another maximal commutative stabiliser group, and furthermore by
   assumption </span><!-- l. 892 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math>
   <span class='cmti-10x-x-109'>maps all the stabilisers </span><!-- l. 892 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mi>i</mi></mrow></msub></math>
   <span class='cmti-10x-x-109'>to a product of stabilisers.</span>
   </p></dd><dt class='enumerate'>
b) </dt><dd class='enumerate'>
   <!-- l. 893 --><p class='noindent'>We now know that <!-- l. 893 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover><msub><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mi>i</mi></mrow></msub><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></mrow></math>
   for some product of logical Pauli operators <!-- l. 893 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></math>.
   As <!-- l. 893 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></math>
   is a product of logicals, there is then some Pauli <!-- l. 893 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></math>
   that gets mapped by <!-- l. 893 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>
   to <!-- l. 893 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></math>.
   Similarly, there is some <!-- l. 893 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>j</mi></mrow></msub></math>
   such that <!-- l. 893 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>E</mi><msub><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mi>j</mi></mrow></msub><mi>E</mi></mrow></math>
   where <!-- l. 893 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mi>j</mi></mrow></msub></math>
   is such that <!-- l. 893 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover><msub><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mi>j</mi></mrow></msub><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></mrow></math>.
   Let <!-- l. 893 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
   be the Clifford satisfying <!-- l. 893 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi><msub><mrow><mi>Z</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>P</mi></mrow><mrow><mi>i</mi></mrow></msub><mi>U</mi></mrow></math>
   and <!-- l. 893 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi><msub><mrow><mi>X</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>Q</mi></mrow><mrow><mi>j</mi></mrow></msub><mi>U</mi></mrow></math>.
   Show then that
                                                                     

                                                                     
   <!-- tex4ht:inline --></p><!-- l. 894 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow>
              <mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi mathvariant='italic'>EU</mi><msub><mrow><mi>Z</mi></mrow><mrow>
<mi>i</mi></mrow></msub><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msub><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mrow><mi>i</mi></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>E</mi><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>→</mo></mover><mspace class='quad' width='1em'></mspace><mstyle class='text'><mtext>and</mtext></mstyle><mspace class='quad' width='1em'></mspace><msup><mrow><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi mathvariant='italic'>EU</mi><msub><mrow><mi>X</mi></mrow><mrow>
<mi>j</mi></mrow></msub><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msub><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mrow><mi>j</mi></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>E</mi><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>→</mo></mover>
</mrow></math>
   <!-- l. 895 --><p class='nopar'>
   </p></dd><dt class='enumerate'>
c) </dt><dd class='enumerate'>
   <!-- l. 896 --><p class='noindent'>Conclude that hence <!-- l. 896 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>EU</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover><mi>E</mi></mrow></math>.
   </p></dd></dl>
   </div>
<!-- l. 910 --><p class='indent'>    Note that the converse is in fact also true: if
<!-- l. 911 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>EU</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover><mi>E</mi></mrow></math>, then
<!-- l. 911 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math> must
send stabilisers to stabilisers, but proving that is a little tricky.
</p>
   <div class='newtheorem'>
<!-- l. 912 --><p class='noindent'><span class='head'>
<a id='x15-292005r12'></a>
<span class='cmbx-10x-x-109'>Exercise* 12.12.</span>  </span>Prove the converse to Exercise <a href='#x15-292001r11'>12.11<!-- tex4ht:ref: exer:stabiliser-push  --></a>.
</p>
   </div>
<!-- l. 914 --><p class='indent'>      In particular, as soon as we have a Clifford unitary
<!-- l. 928 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math>
that has the “stabiliser pushing” property, we can compute
<!-- l. 928 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> just by looking at
how <!-- l. 928 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math> acts on the
logical operators <!-- l. 928 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>i</mi></mrow></msub></mrow></math>.
We can perform all the computations involving stabiliser groups efficiently, e.g. using
the symplectic matrix representation from Section <a href='main_htmlch6.html#cliffords-as-symplectic-matrices'>6.4.4<!-- tex4ht:ref: sec:symplectic  --></a>. Hence, a naïve way to
find all the transversal Clifford gates in a code is to just enumerate every local
Clifford <!-- l. 928 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math>
and check if it sends all the generators of the stabiliser group to
stabilisers. Of course, there are exponentially many local Clifford
operations, so it may not be practical to enumerate them all for large
<!-- l. 929 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>.
However, there are many results that show that some families of codes always
                                                                     

                                                                     
have certain transversal Clifford gates. To start, the definitions of the logical
<!-- l. 930 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math> and
<!-- l. 930 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math> operators (<a href='#x15-281005r11'>12.11<!-- tex4ht:ref: eq:logical-x  --></a>)
and (<a href='#x15-281006r12'>12.12<!-- tex4ht:ref: eq:logical-z  --></a>) essentially say that any stabiliser code has transversal implementations of all
the logical <!-- l. 930 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
and <!-- l. 930 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
operators: </p><table class='equation-star'><tr><td>
<!-- l. 931 --><object data="svgs/logical-ops.svg" alt="diagram of logical-ops" class="svg-diagram"></object></td></tr></table>
   <table class='equation-star'><tr><td>
<!-- l. 934 --><object data="svgs/logical-ops1.svg" alt="diagram of logical-ops1" class="svg-diagram"></object></td></tr></table>
<!-- l. 937 --><p class='indent'>   A bit less trivially, one of the most well-known results about transversality
says that CNOT gates are transversal for CSS codes. In its simplest version, this
means that applying a CNOT gate transversally across all physical qubits
of two identical codeblocks has the effect of applying a CNOT across
all logical qubits. We can formalise this using the scalable notation as
follows.
</p>
   <div class='newtheorem'>
<!-- l. 938 --><p class='noindent'><span class='head'>
<a id='x15-292006r6'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Theorem 12.4.6.</span>  </span> CNOT gates are transversal for CSS codes. That is:
</p><table class='equation'><tr><td>
<!-- l. 940 --><p class='indent'>
</p><!-- l. 940 --><object id='x15-292007r38' data="svgs/eq-trans-cnot-css.svg" alt="diagram of eq:trans-cnot-css" class="svg-diagram"></object></td><td class='eq-no'>(12.38)</td></tr></table>
   </div>
<!-- l. 943 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 946 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>We begin with the right-hand side of (<a href='#x15-292007r38'>12.38<!-- tex4ht:ref: eq:trans-cnot-css  --></a>) and rewrite the encoder
of the second code block into Z-form:
</p>
<div class='center'>
<!-- l. 948 --><p class='noindent'>
</p><!-- l. 949 --><p class='noindent'><object data="svgs/trans-cnot-pf0-v2.svg" alt="diagram of trans-cnot-pf0-v2" class="svg-diagram"></object> </p></div>
<!-- l. 952 --><p class='indent'>   We can then push the CNOT through the encoders using strong
complementarity and the scalable ZX rules:
</p>
<div class='center'>
<!-- l. 954 --><p class='noindent'>
</p><!-- l. 955 --><p class='noindent'><object data="svgs/trans-cnot-pf-v2.svg" alt="diagram of trans-cnot-pf-v2" class="svg-diagram"></object> </p></div>
<!-- l. 958 --><p class='indent'>   then apply equations (<a href='#x15-289011r34'>12.34<!-- tex4ht:ref: eq:logical-anticommute  --></a>) and (<a href='#x15-289012r35'>12.35<!-- tex4ht:ref: eq:logical-commute  --></a>):
</p>
                                                                     

                                                                     
<div class='center'>
<!-- l. 960 --><p class='noindent'>
</p><!-- l. 961 --><p class='noindent'><object data="svgs/trans-cnot-pf-v2-1.svg" alt="diagram of trans-cnot-pf-v2-1" class="svg-diagram"></object> </p></div>
<!-- l. 964 --><p class='indent'>   Rewriting the second encoder back into X-form yields the left-hand side of
(<a href='#x15-292007r38'>12.38<!-- tex4ht:ref: eq:trans-cnot-css  --></a>).                                                                                       □
</p>
   </div>
<!-- l. 966 --><p class='indent'>   All CSS codes have transversal CNOT gates. However, it might not be so
convenient to implement a CNOT between each qubit in the code block. For
example, as the surface code is a CSS code, we know it has a transversal CNOT,
which looks like this:
</p>
<div class='center'>
<!-- l. 968 --><p class='noindent'>
</p><!-- l. 969 --><p class='noindent'><object data="svgs/surface-trans-cnot.svg" alt="diagram of surface-trans-cnot" class="svg-diagram"></object> </p></div>
<!-- l. 972 --><p class='indent'>   Note however, that implementing it would ruin the nice 2D structure which
makes the surface code so attractive for some hardware platforms. We’ll see in
Section <a href='#lattice-surgery'>12.4.3<!-- tex4ht:ref: sec:lattice-surgery  --></a> that there is another way to implement 2-qubit gates in the
surface code and friends without destroying planarity.  Not all CSS codes admit
transversal H gates, but quite a few do. To see what conditions we need,
let’s start with a transversal H and see what happens when we push
it into the encoder. First, we can introduce a scalable H gate to mean
<!-- l. 974 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
copies of the H gate:
</p>
<div class='center'>
<!-- l. 976 --><p class='noindent'>
</p><!-- l. 977 --><p class='noindent'><object data="svgs/bold-h.svg" alt="diagram of bold-h" class="svg-diagram"></object> </p></div>
<!-- l. 980 --><p class='indent'>   Then the usual colour change rules work just like they would for the normal
H gate, but we also get an additional rule. Using (<a href='#x15-289002r27'>12.27<!-- tex4ht:ref: eq:arrow-color-rev  --></a>), we can push a scalable
H gate through an arrow as follows: </p><table class='equation'><tr><td>
<!-- l. 981 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 981 --><object id='x15-292008r39' data="svgs/h-arrow.svg" alt="diagram of h-arrow" class="svg-diagram"></object></td><td class='eq-no'>(12.39)</td></tr></table>
<!-- l. 984 --><p class='indent'>   Using this new rule, we can introduce H gates on all of the physical qubits of
the encoder in Z-form and push it to the left: </p><table class='equation'><tr><td>
<!-- l. 985 --><p class='indent'>
</p><!-- l. 985 --><object id='x15-292009r40' data="svgs/eq-trans-h0.svg" alt="diagram of eq:trans-h0" class="svg-diagram"></object></td><td class='eq-no'>(12.40)</td></tr></table>
<!-- l. 988 --><p class='indent'>   The RHS almost looks like a layer of Hadamard gates followed by the
X-form of the encoder, but not quite. The X-form should be labelled by
<!-- l. 988 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub></math> and
<!-- l. 988 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub></math>, not
<!-- l. 988 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>L</mi></mrow><mrow><mi>Z</mi></mrow></msub></math> and
<!-- l. 988 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mi>Z</mi></mrow></msub></math>. We could therefore
consider codes where <!-- l. 988 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>L</mi></mrow><mrow><mi>Z</mi></mrow></msub></mrow></math>
and <!-- l. 988 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>S</mi></mrow><mrow><mi>Z</mi></mrow></msub></mrow></math>
and we’d be done. However, it turns out that is stricter than we need, so
we’ll consider codes where just the X-stabilisers and Z-stabilisers are the
same.
</p>
   <div class='newtheorem'>
<!-- l. 989 --><p class='noindent'><span class='head'>
<a id='x15-292010r7'></a>
<span class='cmbx-10x-x-109'>Definition 12.4.7.</span>  </span> A CSS code is <span class='cmbx-10x-x-109'>self-dual </span>if <!-- l. 990 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>S</mi></mrow><mrow><mi>Z</mi></mrow></msub></mrow></math>.
</p>
   </div>
                                                                     

                                                                     
<!-- l. 991 --><p class='indent'>    Examples of self-dual CSS codes are the
<!-- l. 992 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>⟦</mi><mn>4</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mi>⟧</mi></mrow></math> code
from Example <a href='#x15-279006r5'>12.2.5<!-- tex4ht:ref: ex:422-code  --></a> and the Steane code. Continuing from (<a href='#x15-292009r40'>12.40<!-- tex4ht:ref: eq:trans-h0  --></a>) with
a self-dual code, we can see that we almost get to the form we need:
</p><table class='equation'><tr><td>
<!-- l. 994 --><p class='indent'>
</p><!-- l. 994 --><object id='x15-292011r41' data="svgs/eq-trans-h1.svg" alt="diagram of eq:trans-h1" class="svg-diagram"></object></td><td class='eq-no'>(12.41)</td></tr></table>
<!-- l. 997 --><p class='indent'>   but the logical operators on the RHS are still the wrong type to get an
encoder in X-form. The trick now is to realise that even though the X-logical and
Z-logical operators might still be different in a self-dual CSS code, they always
generate the same subspace together with the stabilisers. Hence, we can prove the
following proposition.
</p>
   <div class='newtheorem'>
<!-- l. 999 --><p class='noindent'><span class='head'>
<a id='x15-292012r8'></a>
<span class='cmbx-10x-x-109'>Proposition 12.4.8.</span>  </span> For  any  self-dual  CSS  code,  there  exist  matrices
<!-- l. 1000 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>M</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>N</mi></mrow></math>
such that <!-- l. 1000 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>L</mi></mrow><mrow><mi>Z</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub><mi>M</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub><mi>N</mi></mrow></math>.
</p>
   </div>
<!-- l. 1001 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 1003 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Suppose <!-- l. 1003 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>S</mi></mrow><mrow><mi>Z</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub></mrow></math>
consists of <!-- l. 1003 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>m</mi></math>
independent stabilisers, then the whole CSS code has <!-- l. 1003 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi>m</mi></mrow></math>
stabilisers. It must then have <!-- l. 1003 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn><mi>m</mi></mrow></math>
                                                                     

                                                                     
X-logical operators. Hence, the columns of <!-- l. 1003 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub></math>
and <!-- l. 1003 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub></math>
together consist of <!-- l. 1003 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn><mi>m</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>m</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>m</mi></mrow></math>
independent vectors in <!-- l. 1003 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>cols</mtext></mstyle><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>S</mi></mrow><mrow><mi>Z</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></mrow></math>.
Since <!-- l. 1003 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>cols</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>S</mi></mrow><mrow><mi>Z</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
is <!-- l. 1003 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>m</mi></math>-dimensional,
that means they span the whole space. But then, <!-- l. 1003 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>S</mi></mrow><mrow><mi>Z</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub></mrow></math>,
so each column of <!-- l. 1003 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>L</mi></mrow><mrow><mi>Z</mi></mrow></msub></math>
is in <!-- l. 1003 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>cols</mtext></mstyle><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext class='textrm' mathvariant='normal'>cols</mtext></mstyle><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>S</mi></mrow><mrow><mi>Z</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></mrow></math>.
Hence, we can write each column of <!-- l. 1003 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>L</mi></mrow><mrow><mi>Z</mi></mrow></msub></math>
as a linear combination of columns from <!-- l. 1003 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub></math>
and <!-- l. 1003 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub></math>,
i.e. we can find matrices <!-- l. 1003 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>M</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>N</mi></mrow></math>
such that <!-- l. 1003 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>L</mi></mrow><mrow><mi>Z</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub><mi>M</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub><mi>N</mi></mrow></math>.
                                                                   □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 1005 --><p class='noindent'><span class='head'>
<a id='x15-292013r13'></a>
<span class='cmbx-10x-x-109'>Exercise 12.13.</span>  </span> Show using the scalable rules from Section <a href='main_htmlch7.html#scalable-zx-notation'>7.2<!-- tex4ht:ref: sec:scalable-ZX  --></a> and Proposition <a href='#x15-292012r8'>12.4.8<!-- tex4ht:ref: prop:self-dual-logicals  --></a>
that, for a self-dual code, we have for some matrix <!-- l. 1006 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>:
</p>
<div class='center'>
<!-- l. 1008 --><p class='noindent'>
</p><!-- l. 1009 --><p class='noindent'><object data="svgs/self-dual-logicals.svg" alt="diagram of self-dual-logicals" class="svg-diagram"></object> </p></div>
<!-- l. 1012 --><p class='noindent'><span class='cmti-10x-x-109'>Hint: Recall Proposition </span><a href='main_htmlch7.html#x10-163007r2'><span class='cmti-10x-x-109'>7.2.2</span><!-- tex4ht:ref: prop:scalable-addition  --></a><span class='cmti-10x-x-109'>.</span>
</p>
   </div>
<!-- l. 1013 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 1033 --><p class='noindent'><span class='head'>
<a id='x15-292014r9'></a>
<span class='cmbx-10x-x-109'>Theorem 12.4.9.</span>  </span> H gates are transversal for self-dual CSS codes. That is, for
any self-dual CSS code, there exists a CNOT circuit with parity matrix
                                                                     

                                                                     
<!-- l. 1034 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math> such
that: </p><table class='equation'><tr><td>
<!-- l. 1035 --><p class='indent'>
</p><!-- l. 1035 --><object id='x15-292015r42' data="svgs/eq-trans-h-css.svg" alt="diagram of eq:trans-h-css" class="svg-diagram"></object></td><td class='eq-no'>(12.42)</td></tr></table>
   </div>
<!-- l. 1038 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 1040 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Starting from the RHS of (<a href='#x15-292015r42'>12.42<!-- tex4ht:ref: eq:trans-h-css  --></a>), we can switch to the Z-form of the
encoder and apply the derivation in (<a href='#x15-292011r41'>12.41<!-- tex4ht:ref: eq:trans-h1  --></a>) and Exercise <a href='#x15-292013r13'>12.13<!-- tex4ht:ref: exer:self-dual-logicals  --></a>:
</p>
<div class='center'>
<!-- l. 1042 --><p class='noindent'>
</p><!-- l. 1043 --><p class='noindent'><object data="svgs/trans-h2.svg" alt="diagram of trans-h2" class="svg-diagram"></object> </p></div>
<!-- l. 1046 --><p class='indent'>   <!-- l. 1046 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math> is
the parity matrix of a CNOT circuit if and only if it is invertible
(Proposition <a href='main_htmlch4.html#x7-94003r13'>4.2.13<!-- tex4ht:ref: prop:parity-to-CNOTs  --></a>). This follows immediately from the fact that the map above
is an isometry, and hence in particular is non-singular.                         □
</p>
   </div>
<!-- l. 1048 --><p class='indent'>   This means applying a transversal Hadamard at the physical level is not
necessarily the same thing as applying a transversal Hadamard at the logical
level. However, it always does something non-trivial to our logical qubits,
consisting of a layer of Hadamard gates followed by some (possibly trivial)
CNOT circuit. In the case of the Steane code, the logical operators are identical,
so applying H to every physical qubit is the same as applying H to the single
logical qubit:
                                                                     

                                                                     
</p>
<div class='center'>
<!-- l. 1050 --><p class='noindent'>
</p><!-- l. 1051 --><p class='noindent'><object data="svgs/steane-transversal-h2.svg" alt="diagram of steane-transversal-h2" class="svg-diagram"></object> </p></div>
<!-- l. 1054 --><p class='indent'>   However, the <!-- l. 1054 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>⟦</mi><mn>4</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mi>⟧</mi></mrow></math>
code from Example <a href='#x15-286006r4'>12.3.4<!-- tex4ht:ref: ex:422-code-encoder  --></a> has X-logical operators and Z-logical operators that
differ by a logical swap:
</p>
<div class='center'>
<!-- l. 1056 --><p class='noindent'>
</p><!-- l. 1057 --><p class='noindent'><object data="svgs/422-trans-h.svg" alt="diagram of 422-trans-h" class="svg-diagram"></object> </p></div>
<!-- l. 1060 --><p class='indent'>   In this case, the parity matrix from Theorem <a href='#x15-292014r9'>12.4.9<!-- tex4ht:ref: thm:trans-h-css  --></a> is </p><table class='equation-star'><tr><td>
<!-- l. 1061 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mi>M</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                       </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 1064 --><p class='indent'>   corresponding to a swap gate (or equivalently, 3 CNOTs).
Note that the surface code <span class='cmti-10x-x-109'>almost </span>has a transversal
<!-- l. 1065 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math> gate. When
we apply <!-- l. 1065 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>
everywhere on the X-form of the encoder, we get the following:
</p>
<div class='center'>
<!-- l. 1067 --><p class='noindent'>
</p><!-- l. 1068 --><p class='noindent'><object data="svgs/surface-trans-h.svg" alt="diagram of surface-trans-h" class="svg-diagram"></object> </p></div>
                                                                     

                                                                     
<!-- l. 1071 --><p class='indent'>   We almost get back to where we started, except the encoder has “rotated
<!-- l. 1071 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>9</mn><msup><mrow><mn>0</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>∘</mo></mrow></msup></mrow></math>”, which
follows from applying the colour-reverse of equation (<a href='#x15-287002r21'>12.21<!-- tex4ht:ref: eq:surface-encoder  --></a>). Technically this is a
different error-correcting code. But of course this new code has all the same
properties as before, since it is just a permutation of the physical qubits. As long
as we keep track of where the qubits are, this is “close enough” to a transversal
<!-- l. 1071 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math> for
many purposes. We could at this point complete the Clifford story and give the
conditions for a CSS code to have transversal S gates. Rather than working this out
explicitly, we will go first to the harder case of transversal T gates, which as we will
explain in Remark <a href='#x15-293010r13'>12.4.13<!-- tex4ht:ref: rem:l-even  --></a>, generalises readily to a characterisation of transversal
<!-- l. 1072 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo>  <mfrac><mrow><mi>π</mi></mrow>
<mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>ℓ</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup></mrow></mfrac><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> gates for
all <!-- l. 1072 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℓ</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>1</mn></mrow></math>.
</p>
   <h5 class='subsubsectionHead' id='transversal-t-gates'><span class='titlemark'>12.4.1.2   </span> <a id='x15-29300012.4.1.2'></a>Transversal T gates</h5>
<!-- l. 1074 --><p class='noindent'>We now turn to the somewhat thornier question of when stabiliser codes admit
transversal <span class='cmti-10x-x-109'>non-Clifford </span>gates. For the sake of simplicity, we will start with
<!-- l. 1074 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates,
but in fact the story will be much the same in the next section when we
talk about all diagonal gates on the third level of the Clifford hierarchy.
Once we pass to non-Clifford gates, we can’t expect to be able to just
conjugate each of the generators of the stabiliser group and get Paulis
again. Hence, we no longer have such an easy way to check if a given
operation on physical qubits preserves the codespace. Anyway, we still have
the ZX-calculus at our disposal, so let’s be brave. Just like we did with
transversal Hadamards, we can start with a transversal application of
<!-- l. 1075 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates on the physical qubits and try to push it through the encoder
of a CSS code. If it comes out as some non-trivial unitary on the
<!-- l. 1075 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
logical qubits, we’re golden. Since we’ve left Clifford-land, we don’t expect
life to be that easy, but we will just start and see where we get stuck.
We begin by applying strong complementarity and the scalable rules:
</p><table class='equation'><tr><td>
<!-- l. 1076 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 1076 --><object id='x15-293001r43' data="svgs/eq-trans-t-push.svg" alt="diagram of eq:trans-t-push" class="svg-diagram"></object></td><td class='eq-no'>(12.43)</td></tr></table>
<!-- l. 1079 --><p class='indent'>   This gets us pretty far, but we still have that pesky
<!-- l. 1079 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub></math>
connecting our phase gadgets to some wires that don’t correspond to logical
qubits. In order to preserve the codespace, we want to end up with some phase
gadgets just supported on the logical qubits. Just like in the case of Hadamards,
this could act differently on the logical space from the physical space, so we don’t
know <span class='cmti-10x-x-109'>a priori </span>what this action is. We will start with the simplest case, where
<!-- l. 1080 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>T</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>n</mi></mrow></msup></math> on the physical
qubits acts as <!-- l. 1080 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>T</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>k</mi></mrow></msup></math>
on the logical qubits. That is, we want to satisfy this equation: </p><table class='equation'><tr><td>
<!-- l. 1081 --><p class='indent'>
</p><!-- l. 1081 --><object id='x15-293002r44' data="svgs/eq-t-only-logical.svg" alt="diagram of eq:t-only-logical" class="svg-diagram"></object></td><td class='eq-no'>(12.44)</td></tr></table>
<!-- l. 1084 --><p class='indent'>   The reason it is easier to use <!-- l. 1084 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>T</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></math>
and not <!-- l. 1084 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
is we can now move everything to one side and we’ll only have
<!-- l. 1084 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math> phase
gadgets: </p><table class='equation-star'><tr><td>
<!-- l. 1085 --><object data="svgs/t-only-logical-2-simp.svg" alt="diagram of t-only-logical-2-simp" class="svg-diagram"></object></td></tr></table>
                                                                     

                                                                     
<!-- l. 1088 --><p class='indent'>   Now, we can “zip up” this equation into a single matrix over a register of
<!-- l. 1088 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>m</mi></mrow></math>
qubits: </p><table class='equation'><tr><td>
<!-- l. 1089 --><p class='indent'>
</p><!-- l. 1089 --><object id='x15-293003r45' data="svgs/eq-t-only-logical-zip.svg" alt="diagram of eq:t-only-logical-zip" class="svg-diagram"></object></td><td class='eq-no'>(12.45)</td></tr></table>
<!-- l. 1092 --><p class='indent'>   Thanks to Section <a href='main_htmlch11.html#spider-nests-as-strongly-even-matrices'>11.2.1<!-- tex4ht:ref: sec:spider-nest-triortho  --></a>, we know that a configuration of
<!-- l. 1092 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math> phase
gadgets equals the identity if and only if its associated matrix is strongly 3-even
(Definition <a href='main_htmlch11.html#x14-251008r2'>11.2.2<!-- tex4ht:ref: def:3-even-strong  --></a>). Hence, we are ready to characterise when CSS codes have
transversal <!-- l. 1092 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates.
</p>
   <div class='newtheorem'>
<!-- l. 1093 --><p class='noindent'><span class='head'>
<a id='x15-293004r10'></a>
<span class='cmbx-10x-x-109'>Definition 12.4.10.</span>  </span> A CSS code <!-- l. 1094 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
is called <span class='cmbx-10x-x-109'>triorthogonal </span>if the following matrix is 3-even: </p><table class='equation'><tr><td>
<!-- l. 1095 --><p class='indent'>
</p><!-- l. 1095 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='label' id='x15-293005r46'></mstyle><!-- endlabel --><mi>M</mi> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>   <mi>I</mi>   </mtd><mtd class='array-td' columnalign='center'>  <mn>0</mn>   </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi> </mrow> </msub> </mtd> <mtd class='array-td' columnalign='center'> <msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi> </mrow> </msub></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                         </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td><td class='eq-no'>(12.46)</td></tr></table>
<!-- l. 1101 --><p class='indent'>   and a code is called <span class='cmbx-10x-x-109'>strongly triorthogonal </span>if the matrix above is strongly
3-even.
                                                                     

                                                                     
</p>
   </div>
<!-- l. 1102 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 1103 --><p class='noindent'><span class='head'>
<a id='x15-293006r11'></a>
<span class='cmbx-10x-x-109'>Theorem 12.4.11.</span>  </span> A CSS code <!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
admits a transversal <!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
in the sense that: </p><table class='equation'><tr><td>
<!-- l. 1105 --><p class='indent'>
</p><!-- l. 1105 --><object id='x15-293007r47' data="svgs/eq-trans-t-simp.svg" alt="diagram of eq:trans-t-simp" class="svg-diagram"></object></td><td class='eq-no'>(12.47)</td></tr></table>
<!-- l. 1108 --><p class='indent'>   if and only if it is strongly triorthogonal.
</p>
   </div>
<!-- l. 1109 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 1111 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>First  assume  the  CSS  code  is  strongly  triorthogonal.  From  the
calculations above, this is equivalent to equation (<a href='#x15-293002r44'>12.44<!-- tex4ht:ref: eq:t-only-logical  --></a>). Hence, following
calculation (<a href='#x15-293001r43'>12.43<!-- tex4ht:ref: eq:trans-t-push  --></a>), we have:
</p>
<div class='center'>
<!-- l. 1113 --><p class='noindent'>
</p><!-- l. 1114 --><p class='noindent'><object data="svgs/trans-t-pf1-simp.svg" alt="diagram of trans-t-pf1-simp" class="svg-diagram"></object> </p></div>
                                                                     

                                                                     
<!-- l. 1117 --><p class='indent'>   Conversely, if <!-- l. 1117 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
satisfies Eq. (<a href='#x15-293007r47'>12.47<!-- tex4ht:ref: eq:trans-t-simp  --></a>), then:
</p>
<div class='center'>
<!-- l. 1119 --><p class='noindent'>
</p><!-- l. 1120 --><p class='noindent'><object data="svgs/trans-t-conv.svg" alt="diagram of trans-t-conv" class="svg-diagram"></object> </p></div>
<!-- l. 1123 --><p class='indent'>   We can then apply Eq. (<a href='#x15-289009r33'>12.33<!-- tex4ht:ref: eq:encoder-isometry-strong  --></a>) to cancel most of the encoder from both
sides:
</p>
<div class='center'>
<!-- l. 1125 --><p class='noindent'>
</p><!-- l. 1126 --><p class='noindent'><object data="svgs/trans-t-conv-1.svg" alt="diagram of trans-t-conv-1" class="svg-diagram"></object> </p></div>
<!-- l. 1129 --><p class='indent'>   Note that the right-hand side consists of a diagonal unitary applied to
<!-- l. 1129 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext class='MathClass-rel' stretchy='false'>|+…+⟩</mtext></mrow></math>, but diagonal unitaries
send the state <!-- l. 1129 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext class='MathClass-rel' stretchy='false'>|+…+⟩</mtext></mrow></math>
to itself if and only if they are the identity. Hence, we can conclude
<!-- l. 1129 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>
from Definition <a href='#x15-293004r10'>12.4.10<!-- tex4ht:ref: def:triortho-code  --></a> is strongly 3-even and hence
<!-- l. 1129 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> is
strongly triorthogonal.                                                                   □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 1131 --><p class='noindent'><span class='head'>
<a id='x15-293008r14'></a>
<span class='cmbx-10x-x-109'>Exercise 12.14.</span>  </span> Show that triorthogonal codes implement a transversal
<!-- l. 1132 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gate, possibly up to a diagonal Clifford map on the outputs. That is, for some
<!-- l. 1132 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>:
</p>
<div class='center'>
<!-- l. 1134 --><p class='noindent'>
</p><!-- l. 1135 --><p class='noindent'><object data="svgs/trans-t-cliff.svg" alt="diagram of trans-t-cliff" class="svg-diagram"></object> </p></div>
                                                                     

                                                                     
<!-- l. 1138 --><p class='noindent'><span class='cmti-10x-x-109'>Hint: Use equation </span>(<a href='#x15-289008r32'>12.32<!-- tex4ht:ref: eq:encoder-one-sided-inverse  --></a>) <span class='cmti-10x-x-109'>to move a diagonal Clifford map on the logical side to
the physical side.</span>
</p>
   </div>
<!-- l. 1139 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 1140 --><p class='noindent'><span class='head'>
<a id='x15-293009r12'></a>
<span class='cmbx-10x-x-109'>Example 12.4.12.</span>  </span> The degree-1 monomial
<!-- l. 1141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>∈</mo><mstyle class='text'><mtext>RM</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>5</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> gives
the following strongly 3-even matrix: </p><table class='equation-star'><tr><td>
<!-- l. 1142 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow>
<mrow><mo fence='true' form='prefix'>(</mo><mrow> <mtable align='axis' class='array' columnlines='solid none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>                                                 <mn>1</mn>                                                 </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr><mtr class='array-row'><mtd class='array-td' columnalign='center'>
    <mn>0</mn>                                               </mtd>                                <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd>
</mtr>  <mtr class='array-row'><mtd class='array-td' columnalign='center'>                                                 <mn>0</mn>                                                 </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr><mtr class='array-row'><mtd class='array-td' columnalign='center'><mn>0</mn> </mtd><mtd class='array-td' columnalign='center'><mn>0</mn> </mtd><mtd class='array-td' columnalign='center'><mn>0</mn> </mtd><mtd class='array-td' columnalign='center'><mn>0</mn> </mtd><mtd class='array-td' columnalign='center'><mn>1</mn> </mtd><mtd class='array-td' columnalign='center'><mn>1</mn> </mtd><mtd class='array-td' columnalign='center'><mn>1</mn> </mtd><mtd class='array-td' columnalign='center'><mn>1</mn> </mtd><mtd class='array-td' columnalign='center'><mn>0</mn> </mtd><mtd class='array-td' columnalign='center'><mn>0</mn> </mtd><mtd class='array-td' columnalign='center'><mn>0</mn> </mtd><mtd class='array-td' columnalign='center'><mn>0</mn> </mtd><mtd class='array-td' columnalign='center'><mn>1</mn> </mtd><mtd class='array-td' columnalign='center'><mn>1</mn> </mtd><mtd class='array-td' columnalign='center'><mn>1</mn> </mtd><mtd class='array-td' columnalign='center'><mn>1</mn></mtd>
</mtr>  <mtr class='array-row'><mtd class='array-td' columnalign='center'>                                                 <mn>0</mn>                                                 </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr><!-- c|ccccccccccccccc --></mtable></mrow><mo fence='true' form='postfix'>)</mo></mrow></mrow><mrow><mi>T</mi> </mrow></msup>
</mrow></math></td></tr></table>
<!-- l. 1153 --><p class='indent'>   The matrices <!-- l. 1153 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
on the right define a <!-- l. 1153 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>⟦</mi><mn>15</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>3</mn><mi>⟧</mi></mrow></math>
quantum Reed-Muller code. This is, by definition, a strongly triorthogonal
code, so applying <!-- l. 1153 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>T</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>⊗</mo><mn>15</mn></mrow></msup></math>
on the physical qubits results in a logical <!-- l. 1153 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>T</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></math>.
This property will be used to perform a protocol called <span class='cmbx-10x-x-109'>magic state distillation</span>
in Section <a href='#magic-state-distillation'>12.5<!-- tex4ht:ref: sec:magic-state-distillation  --></a>.
</p>
   </div>
<!-- l. 1154 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 1155 --><p class='noindent'><span class='head'>
<a id='x15-293010r13'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Remark 12.4.13.</span>  </span> Note that almost the exact same argument as above can
be given for transversal <!-- l. 1156 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo>  <mfrac><mrow><mi>π</mi></mrow>
<mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>ℓ</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup></mrow></mfrac><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
gates for any <!-- l. 1156 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℓ</mi> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>1</mn></mrow></math>.
We can define strongly <!-- l. 1156 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℓ</mi></math>-even
matrices as those whose columns sum to <!-- l. 1156 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>0</mn><mspace width='0.3em'></mspace><mi mathvariant='italic'>mod</mi><mspace width='0.3em'></mspace><msup><mrow><mn>2</mn></mrow><mrow><mi>ℓ</mi></mrow></msup></mrow></math>,
pairs of columns sum to <!-- l. 1156 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>0</mn><mspace width='0.3em'></mspace><mi mathvariant='italic'>mod</mi><mspace width='0.3em'></mspace><msup><mrow><mn>2</mn></mrow><mrow><mi>ℓ</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup></mrow></math>,
and so on up to groups of <!-- l. 1156 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℓ</mi></math>
columns summing to <!-- l. 1156 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>0</mn><mspace width='0.3em'></mspace><mi mathvariant='italic'>mod</mi><mspace width='0.3em'></mspace><mn>2</mn></mrow></math>.
Following essentially the same reasoning as Section <a href='main_htmlch11.html#spider-nests-as-strongly-even-matrices'>11.2.1<!-- tex4ht:ref: sec:spider-nest-triortho  --></a>, we can conclude
that
</p>
<div class='center'>
<!-- l. 1158 --><p class='noindent'>
</p><!-- l. 1159 --><p class='noindent'><object data="svgs/ell-even.svg" alt="diagram of ell-even" class="svg-diagram"></object> </p></div>
<!-- l. 1162 --><p class='indent'>   for any strongly <!-- l. 1162 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℓ</mi></math>-even
matrix <!-- l. 1162 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>.
Hence, any CSS code whose matrix </p><table class='equation-star'><tr><td>
<!-- l. 1163 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mi>M</mi> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>   <mi>I</mi>   </mtd><mtd class='array-td' columnalign='center'>  <mn>0</mn>   </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi> </mrow> </msub> </mtd> <mtd class='array-td' columnalign='center'> <msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi> </mrow> </msub></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                         </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 1169 --><p class='indent'>   is strongly <!-- l. 1169 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℓ</mi></math>-even
has a transversal <!-- l. 1169 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo>  <mfrac><mrow><mi>π</mi></mrow>
<mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>ℓ</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup></mrow></mfrac><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
gate. Furthermore, we can generalise Exercise <a href='#x15-293008r14'>12.14<!-- tex4ht:ref: exer:triortho  --></a> to show that if
<!-- l. 1169 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math> is only
<!-- l. 1169 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℓ</mi></math>-even rather than
strongly <!-- l. 1169 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℓ</mi></math>-even, it is
transversal up to a <!-- l. 1169 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>ℓ</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>2</mn></mrow></msup></math>
phase gadget. In particular, if the matrix
<!-- l. 1169 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math> is 2-even, the code
has transversal <!-- l. 1169 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
gates up to Paulis, and hence it can implement a logical
                                                                     

                                                                     
<!-- l. 1169 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
transversally.
</p>
   </div>
<!-- l. 1170 --><p class='indent'>
</p>
   <h5 class='subsubsectionHead' id='transversal-clifford-hierarchy-gates'><span class='titlemark'>12.4.1.3   </span> <a id='x15-29400012.4.1.3'></a>Transversal Clifford hierarchy gates</h5>
<!-- l. 1172 --><p class='noindent'>We can generalise from characterising transversal
<!-- l. 1172 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> or
<!-- l. 1172 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>T</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></math> gates to
transversal implementations of more general unitaries in the third level of the Clifford
hierarchy. Recall from Section <a href='main_htmlch6.html#the-clifford-hierarchy'>6.5<!-- tex4ht:ref: sec:clifford-hierarchy  --></a> that the third level of the Clifford hierarchy
<!-- l. 1172 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>C</mi></mstyle></mrow><mrow><mn>3</mn></mrow></msub></math> consists of all the
unitary maps <!-- l. 1172 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
with the property that, for all Pauli strings
<!-- l. 1172 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math>,
<!-- l. 1172 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></mrow></math> is
Clifford. While it seems to be a difficult problem to characterise <span class='cmti-10x-x-109'>all </span>transversal gates
in <!-- l. 1173 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>C</mi></mstyle></mrow><mrow><mn>3</mn></mrow></msub></math>,
it is much easier if we just focus on the diagonal unitaries
<!-- l. 1173 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mstyle mathvariant='script'><mi>D</mi></mstyle></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>⊂</mo><msub><mrow><mstyle mathvariant='script'><mi>C</mi></mstyle></mrow><mrow><mn>3</mn></mrow></msub></mrow></math>. As noted also in
Section <a href='main_htmlch6.html#the-clifford-hierarchy'>6.5<!-- tex4ht:ref: sec:clifford-hierarchy  --></a>, <!-- l. 1173 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>D</mi></mstyle></mrow><mrow><mn>3</mn></mrow></msub></math> forms a group
which is generated by the <!-- l. 1173 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
phase gadgets. Consequently, an arbitrary unitary in
<!-- l. 1173 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>D</mi></mstyle></mrow><mrow><mn>3</mn></mrow></msub></math> can
be written as </p><table class='equation'><tr><td>
<!-- l. 1174 --><p class='indent'>
</p><!-- l. 1174 --><object id='x15-294001r48' data="svgs/eq-d-m.svg" alt="diagram of eq:d-m" class="svg-diagram"></object></td><td class='eq-no'>(12.48)</td></tr></table>
<!-- l. 1177 --><p class='indent'>   for some boolean matrix <!-- l. 1177 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>.
We can also capture what it means to be a transversal unitary on
<!-- l. 1178 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> qubits in
                                                                     

                                                                     
<!-- l. 1178 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>D</mi></mstyle></mrow><mrow><mn>3</mn></mrow></msub></math>. These consist
precisely of some power <!-- l. 1178 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>T</mi></mrow><mrow><mi>p</mi></mrow></msup></math>
on each qubit. Hence, a transversal gate in
<!-- l. 1178 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>D</mi></mstyle></mrow><mrow><mn>3</mn></mrow></msub></math> is of the
form <!-- l. 1178 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mi>P</mi> </mrow></msub></math> for
some matrix <!-- l. 1178 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>P</mi></math>
where each row contains exactly one 1. Such a matrix represents a
<!-- l. 1178 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gate on the
<!-- l. 1178 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>-th qubit by
containing the <!-- l. 1178 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>-th
unit vector as a row. We can then represent higher powers
<!-- l. 1178 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>T</mi></mrow><mrow><mi>p</mi></mrow></msup></math> as
repeated rows.
</p>
   <div class='newtheorem'>
<!-- l. 1179 --><p class='noindent'><span class='head'>
<a id='x15-294002r14'></a>
<span class='cmbx-10x-x-109'>Example 12.4.14.</span>  </span>The following is a transversal application of powers of
<!-- l. 1180 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> and its associated
<!-- l. 1180 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>P</mi></math>-matrix:
</p><table class='equation-star'><tr><td>
<!-- l. 1181 --><object data="svgs/t-powers.svg" alt="diagram of t-powers" class="svg-diagram"></object></td></tr></table>
   </div>
<!-- l. 1184 --><p class='indent'>    From here, the story goes much like in the previous section. Rather than focusing just on
<!-- l. 1185 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>T</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>n</mi></mrow></msup></math>, we can start with
any transversal <!-- l. 1185 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>D</mi></mstyle></mrow><mrow><mn>3</mn></mrow></msub></math>
unitary and try to push it past the encoder: </p><table class='equation'><tr><td>
<!-- l. 1186 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 1186 --><object id='x15-294003r49' data="svgs/eq-gen-trans-t-push.svg" alt="diagram of eq:gen-trans-t-push" class="svg-diagram"></object></td><td class='eq-no'>(12.49)</td></tr></table>
<!-- l. 1189 --><p class='indent'>   Now, in order to preserve the codespace, the resulting diagonal unitary
should be supported only on the logical qubits. That is, for some
<!-- l. 1189 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>, we
should have: </p><table class='equation-star'><tr><td>
<!-- l. 1190 --><object data="svgs/t-only-logical.svg" alt="diagram of t-only-logical" class="svg-diagram"></object></td></tr></table>
<!-- l. 1193 --><p class='indent'>   As in the previous section, it is convenient to use
<!-- l. 1193 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
phase gadgets on the right-hand side, but note that, since
<!-- l. 1193 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>
can now be arbitrary, this generates the same set of unitaries as
<!-- l. 1193 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math> phase
gadgets. Moving everything to one side, we get: </p><table class='equation-star'><tr><td>
<!-- l. 1194 --><object data="svgs/t-only-logical-2.svg" alt="diagram of t-only-logical-2" class="svg-diagram"></object></td></tr></table>
                                                                     

                                                                     
<!-- l. 1197 --><p class='indent'>   ...or equivalently, in “zipped up” form: </p><table class='equation'><tr><td>
<!-- l. 1198 --><p class='indent'>
</p><!-- l. 1198 --><object id='x15-294004r50' data="svgs/eq-gen-t-only-logical-2.svg" alt="diagram of eq:gen-t-only-logical-2" class="svg-diagram"></object></td><td class='eq-no'>(12.50)</td></tr></table>
<!-- l. 1201 --><p class='indent'>   Hence, we can now state a generalised version of Theorem <a href='#x15-293006r11'>12.4.11<!-- tex4ht:ref: thm:char-trans-t  --></a>.
</p>
   <div class='newtheorem'>
<!-- l. 1202 --><p class='noindent'><span class='head'>
<a id='x15-294005r15'></a>
<span class='cmbx-10x-x-109'>Theorem 12.4.15.</span>  </span> A CSS code with X-logical operators and X-stabilisers
<!-- l. 1203 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub></math> and
<!-- l. 1203 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub></math>
admits a transversal implementation of a logical gate </p><table class='equation-star'><tr><td>
<!-- l. 1204 --><object data="svgs/d-h-dag.svg" alt="diagram of d-h-dag" class="svg-diagram"></object></td></tr></table>
<!-- l. 1207 --><p class='indent'>   if and only if there exists a matrix
<!-- l. 1207 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>P</mi></math>
whose rows are unit vectors, such that the matrix </p><table class='equation'><tr><td>
<!-- l. 1208 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 1208 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='label' id='x15-294006r51'></mstyle><!-- endlabel --><mi>M</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mrow><mo fence='true' form='prefix'>(</mo><mrow> <mtable align='axis' class='array' columnlines='solid' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>                                                 <mi>H</mi>                                         </mtd><mtd class='array-td' columnalign='center'>  <mn>0</mn>   </mtd></mtr>  <mtr class='array-row'><mtd class='array-td' columnalign='center'> 
      <mi mathvariant='italic'>PL</mi>                                              </mtd>                                            <mtd class='array-td' columnalign='center'> <mi mathvariant='italic'>PS</mi> </mtd></mtr> <!-- c|c --></mtable></mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td><td class='eq-no'>(12.51)</td></tr></table>
<!-- l. 1214 --><p class='indent'>   is strongly 3-even.
</p>
   </div>
<!-- l. 1215 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 1216 --><p class='noindent'><span class='head'>
<a id='x15-294007r15'></a>
<span class='cmbx-10x-x-109'>Exercise 12.15.</span>  </span> Generalise the proof of Theorem <a href='#x15-293006r11'>12.4.11<!-- tex4ht:ref: thm:char-trans-t  --></a> to a proof of
Theorem <a href='#x15-294005r15'>12.4.15<!-- tex4ht:ref: thm:gen-char-trans-t  --></a>.
</p>
   </div>
<!-- l. 1218 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 1219 --><p class='noindent'><span class='head'>
<a id='x15-294008r16'></a>
<span class='cmbx-10x-x-109'>Example 12.4.16.</span>  </span> The constant polynomial
<!-- l. 1220 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn> <mo class='MathClass-rel' stretchy='false'>∈</mo><mstyle class='text'><mtext>RM</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>4</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> gives
us a strongly 3-even matrix whose columns are all the 4-bitstrings. If we partition
the matrix as follows: </p><table class='equation'><tr><td>
<!-- l. 1221 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 1221 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='label' id='x15-294009r52'></mstyle><!-- endlabel --><msup><mrow><mrow><mo fence='true' form='prefix'>(</mo><mrow> <mtable align='axis' class='array' columnlines='none none none none none none none solid none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>                                                 <mn>0</mn>                                                 </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr><mtr class='array-row'><mtd class='array-td' columnalign='center'><mn>0</mn> </mtd><mtd class='array-td' columnalign='center'><mn>0</mn> </mtd><mtd class='array-td' columnalign='center'><mn>1</mn> </mtd><mtd class='array-td' columnalign='center'><mn>1</mn> </mtd><mtd class='array-td' columnalign='center'><mn>0</mn> </mtd><mtd class='array-td' columnalign='center'><mn>0</mn> </mtd><mtd class='array-td' columnalign='center'><mn>1</mn> </mtd><mtd class='array-td' columnalign='center'><mn>1</mn> </mtd><mtd class='array-td' columnalign='center'><mn>0</mn> </mtd><mtd class='array-td' columnalign='center'><mn>0</mn> </mtd><mtd class='array-td' columnalign='center'><mn>1</mn> </mtd><mtd class='array-td' columnalign='center'><mn>1</mn> </mtd><mtd class='array-td' columnalign='center'><mn>0</mn> </mtd><mtd class='array-td' columnalign='center'><mn>0</mn> </mtd><mtd class='array-td' columnalign='center'><mn>1</mn> </mtd><mtd class='array-td' columnalign='center'><mn>1</mn></mtd>
</mtr>  <mtr class='array-row'><mtd class='array-td' columnalign='center'>                                                 <mn>0</mn>                                                 </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr><mtr class='array-row'><mtd class='array-td' columnalign='center'>
    <mn>0</mn>                                               </mtd>                                <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr><!-- cccccccc|cccccccc --></mtable></mrow><mo fence='true' form='postfix'>)</mo></mrow></mrow><mrow><mi>T</mi> </mrow></msup>
</mrow></math></td><td class='eq-no'>(12.52)</td></tr></table>
<!-- l. 1231 --><p class='indent'>   then this gives a matrix of the form (<a href='#x15-294006r51'>12.51<!-- tex4ht:ref: eq:gen-char-trans-t  --></a>) with
<!-- l. 1231 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>, with
<!-- l. 1232 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
defining the X-logical operators and X-stabilisers of an
<!-- l. 1232 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>⟦</mi><mn>8</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>3</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mi>⟧</mi></mrow></math> CSS
code, which is sometimes called the “smallest interesting colour code” (see the
References for why). It has three X-logical operators and 1 X-stabiliser:
</p><table class='equation-star'><tr><td>
<!-- l. 1233 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mtable class='aligned'><mtr><mtd columnalign='right'><mover accent='true'><mrow><msub><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mrow><mn>1</mn></mrow></msub></mrow><mo accent='true'>→</mo></mover></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi></mtd>   <mtd columnalign='right'></mtd>
</mtr><mtr><mtd columnalign='right'><mover accent='true'><mrow><msub><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mrow><mn>2</mn></mrow></msub></mrow><mo accent='true'>→</mo></mover></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi></mtd>
</mtr><mtr><mtd columnalign='right'><mover accent='true'><mrow><msub><mrow><mstyle mathvariant='script'><mi>X</mi></mstyle></mrow><mrow><mn>3</mn></mrow></msub></mrow><mo accent='true'>→</mo></mover></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>I</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi></mtd>
</mtr><mtr><mtd columnalign='right'><mover accent='true'><mrow><msub><mrow><mi>X</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow><mo accent='true'>→</mo></mover></mtd><mtd columnalign='left'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>X</mi></mtd>
</mtr><mtr><mtd columnalign='right'></mtd>
   </mtr>                                                                 </mtable>
</mrow></math></td></tr></table>
<!-- l. 1249 --><p class='indent'>   We can draw this encoder as a cube, with the X-logical operators connecting
to 3 adjacent faces and the X-stabiliser connecting to everything:
</p>
<div class='center'>
<!-- l. 1251 --><p class='noindent'>
</p><!-- l. 1252 --><p class='noindent'><object data="svgs/sicc-cube-nonums.svg" alt="diagram of sicc-cube-nonums" class="svg-diagram"></object> </p></div>
<!-- l. 1255 --><p class='indent'>   In the upper left corner of the matrix (<a href='#x15-294009r52'>12.52<!-- tex4ht:ref: eq:sicc-matrix  --></a>), we see the phase gadgets
of a CCZ gate as in equation (<a href='main_htmlch10.html#x13-224005r6'>10.6<!-- tex4ht:ref: eq:CCZ-decomposed  --></a>), hence this code admits a logical
<!-- l. 1255 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>CCZ</mtext></mstyle></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext class='textrm' mathvariant='normal'>CCZ</mtext></mstyle></mrow></math>, implemented
via <!-- l. 1255 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>8</mn></math>
physical <!-- l. 1255 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
                                                                     

                                                                     
gates:
</p>
<div class='center'>
<!-- l. 1257 --><p class='noindent'>
</p><!-- l. 1258 --><p class='noindent'><object data="svgs/sicc-transversal.svg" alt="diagram of sicc-transversal" class="svg-diagram"></object> </p></div>
   </div>
<!-- l. 1261 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 1262 --><p class='noindent'><span class='head'>
<a id='x15-294010r17'></a>
<span class='cmbx-10x-x-109'>Remark 12.4.17.</span>  </span>While Theorem <a href='#x15-294005r15'>12.4.15<!-- tex4ht:ref: thm:gen-char-trans-t  --></a> gives a complete characterisation
for the transversal <!-- l. 1263 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>D</mi></mstyle></mrow><mrow><mn>3</mn></mrow></msub></math>
gates in a CSS code, it is not obvious from the statement whether it can
be used to efficiently find such gates. However, it turns out that this is
possible.  In  fact,  there  are  three  related  problems:  (1)  for  fixed  logical
<!-- l. 1263 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>D</mi></mrow><mrow><mi>H</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msubsup></math>
find transversal gates <!-- l. 1263 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mi>P</mi> </mrow></msub></math>,
(2) for fixed <!-- l. 1263 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mi>P</mi> </mrow></msub></math>
find <!-- l. 1263 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>D</mi></mrow><mrow><mi>H</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msubsup></math>,
and (3) compute a generating set of all logical gates and their associated
transversal implementations. All three of these problems can be posed as a
system of linear equations over the ring <!-- l. 1263 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>ℤ</mi></mrow><mrow><mn>8</mn></mrow></msub></math>,
and can be solved in polynomial time using a generalisation of Gaussian
elimination that works over more general kinds of rings. We will say a bit
more about this in the References.
</p>
   </div>
<!-- l. 1264 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='faulttolerant-pauli-measurements'><span class='titlemark'>12.4.2   </span> <a id='x15-29500012.4.2'></a>Fault-tolerant Pauli measurements</h4>
<!-- l. 1268 --><p class='noindent'>In order to do error correction, we should be able to do stabiliser measurements
on our physical qubits. Since any non-trivial stabiliser generator will have
support on multiple qubits, these will in general be entangling operations
involving multiple physical qubits, so it is not immediately obvious we can
                                                                     

                                                                     
perform such measurements fault-tolerantly. Before we think about a
fault-tolerant implementation of a Pauli measurement, we should think
about how we would even implement a generic Pauli measurement in the
first place. For the first part of this section, we will focus on measuring
<!-- l. 1269 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mo>…</mo> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi></mrow></math>, but
everything we say below will apply to measuring any Pauli string just by
conjugating by the appropriate local Cliffords:
</p>
<div class='center'>
<!-- l. 1271 --><p class='noindent'>
</p><!-- l. 1272 --><p class='noindent'><object data="svgs/pproj-to-zzz.svg" alt="diagram of pproj-to-zzz" class="svg-diagram"></object> </p></div>
<!-- l. 1275 --><p class='indent'>   It could be that our hardware natively implements multi-qubit
<!-- l. 1275 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
measurements, however at the time of writing, this is not possible (or at least
quite challenging) on most quantum hardware platforms. Even if it were possible
to implement high-weight Pauli measurements on physical qubits, we might not
want to, as it could introduce errors on many qubits at once. Hence, the
first thing we should do is decompose this measurement into more basic
operations like basic gates and single-qubit demolition measurements. This is
particularly nice in ZX, because it just amounts to coming up with a
good way to unfuse the big spider in the projector. One such unfusion is:
</p><table class='equation'><tr><td>
<!-- l. 1277 --><p class='indent'>
</p><!-- l. 1277 --><object id='x15-295001r53' data="svgs/eq-zzz-unfuse.svg" alt="diagram of eq:zzz-unfuse" class="svg-diagram"></object></td><td class='eq-no'>(12.53)</td></tr></table>
<!-- l. 1280 --><p class='indent'>   We can now interpret the right-hand side as preparing an ancilla in the
<!-- l. 1280 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state,
applying a series of CNOT gates, then measuring the ancilla in the Z basis. In
terms of not spreading errors on the physical qubits, this is actually pretty good.
Z-errors will just commute through, whereas X-errors will copy on to the ancilla
and flip the measurement outcome:
</p>
                                                                     

                                                                     
<div class='center'>
<!-- l. 1283 --><p class='noindent'>
</p><!-- l. 1284 --><p class='noindent'><object data="svgs/naive-meas-error.svg" alt="diagram of naive-meas-error" class="svg-diagram"></object> </p></div>
<!-- l. 1287 --><p class='indent'>   ...which is what they are supposed to do! The problem comes from errors that
might occur on the ancilla qubit while implementing the measurement. If an X
error occurs on the ancilla, the whole measurement will report the wrong
outcome:
</p>
<div class='center'>
<!-- l. 1290 --><p class='noindent'>
</p><!-- l. 1291 --><p class='noindent'><object data="svgs/naive-meas-x-error.svg" alt="diagram of naive-meas-x-error" class="svg-diagram"></object> </p></div>
<!-- l. 1294 --><p class='indent'>   This is bad of course, because doing error correction depends on being able to
report the results of syndrome measurements reliably. However, this kind of error
is not fatal. As long as the error rate is not too high, we can increase the
reliability of our stabiliser measurements just by repeating the measurement
multiple times and reporting whatever outcome we got the majority of the
time. The worse thing that can happen is Z-errors, i.e. “phase flips”
occurring on the ancilla, because these can propagate out to errors on data
qubits:
</p>
<div class='center'>
<!-- l. 1297 --><p class='noindent'>
</p><!-- l. 1298 --><p class='noindent'><object data="svgs/naive-meas-z-error.svg" alt="diagram of naive-meas-z-error" class="svg-diagram"></object> </p></div>
<!-- l. 1301 --><p class='indent'>   Worse still, it doesn’t change the measurement outcome, so this measurement
has introduced a new, undetected multi-qubit error. We hence see that in the
naïve implementation of a multi-qubit Z measurement, a single fault causes
multiple errors on the data qubits. Hence, it doesn’t satisfy the fault-tolerant
criterion from Definition <a href='#x15-290002r1'>12.4.1<!-- tex4ht:ref: def:fault-tolerant  --></a>. To solve this problem, we need to come up with
a “better unfusion” of this Pauli measurement. One pretty good solution is,
rather than unfusing the X-spider sequentially, we unfuse it in parallel:
</p><table class='equation'><tr><td>
<!-- l. 1303 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 1303 --><object id='x15-295002r54' data="svgs/eq-shor-ec.svg" alt="diagram of eq:shor-ec" class="svg-diagram"></object></td><td class='eq-no'>(12.54)</td></tr></table>
<!-- l. 1306 --><p class='indent'>   where <!-- l. 1306 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>s</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>s</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>s</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>s</mi></mrow><mrow><mn>4</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>s</mi></mrow></math>.
Now, rather than having a single ancilla prepared in the
<!-- l. 1307 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state, we have
<!-- l. 1307 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>w</mi></math> ancillae for a Pauli
measurement of weight <!-- l. 1307 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>w</mi></math>
prepared in a generalised GHZ state, with respect to the X basis:
<!-- l. 1307 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>+</mo><msup><mrow><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow><mrow><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>w</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>−</mo><msup><mrow><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow><mrow><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>w</mi></mrow></msup></mrow></math>.
Especially in the context of fault-tolerance, this is often
called a <span class='cmbx-10x-x-109'>cat state</span>. Then, we perform a CNOT between the
<!-- l. 1307 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>-th data qubit
and the <!-- l. 1307 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>-th
qubit of the cat state and measure each of the ancilla qubits in the Z basis. The
XOR of all the measurement outcomes then gives the result of the syndome
measurement. This implementation of a multi-qubit measurement is called a
<span class='cmbx-10x-x-109'>Shor fault-tolerant measurement</span>. For the sake of concreteness, we have
shown the 4-qubit Shor measurement, but this generalises in the obvious way to
Pauli measurements of higher weight. There are a few things to say about Shor
measurements. First, notice how in the process of unfusing spiders, we can turn
one measurement into multiple measurements. Second, we have now
fixed the problem that our naïve implementation had: single Z errors in
the RHS of (<a href='#x15-295002r54'>12.54<!-- tex4ht:ref: eq:shor-ec  --></a>) now result only in single errors on the data qubits,
e.g.
</p>
<div class='center'>
<!-- l. 1310 --><p class='noindent'>
</p><!-- l. 1311 --><p class='noindent'><object data="svgs/shor-one-error.svg" alt="diagram of shor-one-error" class="svg-diagram"></object> </p></div>
<!-- l. 1314 --><p class='indent'>   However, this doesn’t fully solve the problem yet: it has shifted the difficulty of fault-tolerantly
measuring <!-- l. 1314 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mo>…</mo> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi></mrow></math>
to fault-tolerantly preparing cat states. If we assume that our basic operations
are single-qubit preparations and measurements, as well as basic 2-qubit gates
like CNOT, then we can prepare cat states using some ladder of CNOTs like this:
</p><table class='equation'><tr><td>
                                                                     

                                                                     
<!-- l. 1316 --><p class='indent'>
</p><!-- l. 1316 --><object id='x15-295003r55' data="svgs/eq-cat-state-prep.svg" alt="diagram of eq:cat-state-prep" class="svg-diagram"></object></td><td class='eq-no'>(12.55)</td></tr></table>
<!-- l. 1319 --><p class='indent'>   There are many basic circuits that can prepare a cat state, but they all have
one thing in common: there is always some location where a single error in the
preparation can propagate out to multiple errors on the cat state, and hence the
measurement (<a href='#x15-295002r54'>12.54<!-- tex4ht:ref: eq:shor-ec  --></a>). For example:
</p>
<div class='center'>
<!-- l. 1321 --><p class='noindent'>
</p><!-- l. 1322 --><p class='noindent'><object data="svgs/cat-state-error-prop.svg" alt="diagram of cat-state-error-prop" class="svg-diagram"></object> </p></div>
<!-- l. 1325 --><p class='indent'>   To solve this issue, we can perform some rudimentary error detection or
correction on the cat state. The first thing to note is that, because of
the orientation of CNOT gates, X errors will only possibly mess up the
measurement outcome, but never otherwise effect the data qubits. As
mentioned before, we can mitigate this by simply repeating the measurement
and taking the outcome we get the majority of the time. Hence, we can
focus just on Z errors. For a cat state prepared as in (<a href='#x15-295003r55'>12.55<!-- tex4ht:ref: eq:cat-state-prep  --></a>), the only
place a single Z error during preparation can result in 2 errors on the
cat state is the one shown above. We can therefore detect this error by
measuring any stabiliser of the cat state that anti-commutes with this error.
<!-- l. 1326 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>X</mi></mrow></math> will
work:
</p>
<div class='center'>
<!-- l. 1328 --><p class='noindent'>
</p><!-- l. 1329 --><p class='noindent'><object data="svgs/cat-state-error-detect.svg" alt="diagram of cat-state-error-detect" class="svg-diagram"></object> </p></div>
                                                                     

                                                                     
<!-- l. 1332 --><p class='indent'>   If we get outcome <!-- l. 1332 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>t</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>,
we can just throw out the cat state and try again. This is called a
<span class='cmbx-10x-x-109'>repeat-until-success </span>strategy for state preparation. But then, what if this
nested error-detection measurement propagates errors? Do we need to do
error-detection on it? Is it Turtles All the Way Down? Thankfully no.
Due to the direction of the CNOT gates, there is no way for this nested
measurement to propagate additional Z errors into the cat state. This nested
measurement could indeed cause more bit errors into the cat state, but as
in the case of our naïve measurement, bit errors on the ancillae are
not a bit deal. They can lead to an erroneous syndrome, which can be
mitigated by repeated measurements, but crucially they won’t cause any
additional errors on the data qubits. There exist several refinements to the
idea behind Shor measurements, which consist of preparing (possibly
elaborate) ancilla states, performing some transversal CNOTs and doing
single-qubit measurements. One that is particularly nice to analyse in
the scalable ZX-calculus is the <span class='cmbx-10x-x-109'>Steane fault-tolerant measurement</span>
protocol. This protocol works for any CSS code, and allows one to extract
syndrome information for all the stabilisers of a single kind (X or Z)
at once. First, it relies on being able to reliably prepare the encoded
<!-- l. 1335 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo>…</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> and
<!-- l. 1335 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext class='MathClass-rel' stretchy='false'>|+…+⟩</mtext></mrow></math>
states associated with a CSS code. We can see what these look like by plugging
the all-0 and all-plus logical states into the CSS encoder: </p><table class='equation'><tr><td>
<!-- l. 1336 --><p class='indent'>
</p><!-- l. 1336 --><object id='x15-295004r56' data="svgs/eq-z0-codeword.svg" alt="diagram of eq:z0-codeword" class="svg-diagram"></object></td><td class='eq-no'>(12.56)</td></tr></table>
   <table class='equation'><tr><td>
<!-- l. 1339 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 1339 --><object id='x15-295005r57' data="svgs/eq-x0-codeword.svg" alt="diagram of eq:x0-codeword" class="svg-diagram"></object></td><td class='eq-no'>(12.57)</td></tr></table>
<!-- l. 1342 --><p class='indent'>   Now, suppose we start with an ancilla system prepared in the encoded
<!-- l. 1342 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo>…</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state,
perform a transversal CNOT between the ancilla and a block of our CSS code,
then measure all the qubits of the ancilla system. Here is what we’ll get:
</p><table class='equation'><tr><td>
<!-- l. 1343 --><p class='indent'>
</p><!-- l. 1343 --><object id='x15-295006r58' data="svgs/eq-steane-ec1.svg" alt="diagram of eq:steane-ec1" class="svg-diagram"></object></td><td class='eq-no'>(12.58)</td></tr></table>
<!-- l. 1346 --><p class='indent'>   We can reduce this further once we know how the arrow acts on the
<!-- l. 1346 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>π</mi></mrow></math>
effect corresponding to our measurement outcome
<!-- l. 1346 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math> arising from
doing a Z-measurement on all the physical qubits. First, note that an X-spider labelled by
<!-- l. 1346 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>π</mi></mrow></math> corresponds to the
computational basis state <!-- l. 1346 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
We already know that map described by parity matrix
<!-- l. 1346 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math> sends a
state <!-- l. 1346 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> to
the state <!-- l. 1346 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>A</mi><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
Hence:
</p>
<div class='center'>
<!-- l. 1348 --><p class='noindent'>
</p><!-- l. 1349 --><p class='noindent'><object data="svgs/scalable-vec-arrow.svg" alt="diagram of scalable-vec-arrow" class="svg-diagram"></object> </p></div>
<!-- l. 1352 --><p class='indent'>   Applying the colour-change rule for the arrow (<a href='main_htmlch7.html#x10-162009r36'>7.36<!-- tex4ht:ref: eq:h-arrow  --></a>), we get:
</p>
                                                                     

                                                                     
<div class='center'>
<!-- l. 1354 --><p class='noindent'>
</p><!-- l. 1355 --><p class='noindent'><object data="svgs/scalable-vec-arrow-z.svg" alt="diagram of scalable-vec-arrow-z" class="svg-diagram"></object> </p></div>
<!-- l. 1358 --><p class='indent'>   Continuing from (<a href='#x15-295006r58'>12.58<!-- tex4ht:ref: eq:steane-ec1  --></a>), we have:
</p>
<div class='center'>
<!-- l. 1360 --><p class='noindent'>
</p><!-- l. 1361 --><p class='noindent'><object data="svgs/steane-ec2.svg" alt="diagram of steane-ec2" class="svg-diagram"></object> </p></div>
<!-- l. 1364 --><p class='indent'>   We now have a protocol for measuring all of the X-stabilisers at once. We
apply the fault-tolerant circuit on the left-hand side above, obtain an outcome
<!-- l. 1364 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math>,
then compute the X part of the error syndrome as
<!-- l. 1364 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <msubsup><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow><mrow><mi>T</mi> </mrow></msubsup><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>.
Similarly, we can measure the Z part of the syndrome, by reversing all the
colours:
</p>
<div class='center'>
<!-- l. 1367 --><p class='noindent'>
</p><!-- l. 1368 --><p class='noindent'><object data="svgs/steane-ec3.svg" alt="diagram of steane-ec3" class="svg-diagram"></object> </p></div>
<!-- l. 1371 --><p class='indent'>   Thus we obtain the Z part of the error syndrome as
<!-- l. 1371 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>t</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <msubsup><mrow><mi>S</mi></mrow><mrow><mi>Z</mi></mrow><mrow><mi>T</mi> </mrow></msubsup><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>.
Performing these two protocols in sequence therefore gives us a full round of
syndrome extraction:
</p>
<div class='center'>
<!-- l. 1373 --><p class='noindent'>
</p><!-- l. 1374 --><p class='noindent'><object data="svgs/steane-ec4.svg" alt="diagram of steane-ec4" class="svg-diagram"></object> </p></div>
<!-- l. 1377 --><p class='indent'>   Assuming we have fault-tolerant protocols to prepare the two ancilla states,
everything else in sight is fault-tolerant. There are a handful of ways to do
this. For example, to prepare the encoded all-0 state, one can start with
<!-- l. 1377 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><msup><mrow><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow><mrow><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>n</mi></mrow></msup></mrow></math> and do several
rounds of <!-- l. 1377 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub></math>
                                                                     

                                                                     
measurements using some other fault-tolerant protocol, such as the Shor method.
One could also attempt to detect errors that occured during preparation
with an extra layer of error detection or do some sort of “distillation”
procedure akin to the magic state distillation we will discuss in Section <a href='#magic-state-distillation'>12.5<!-- tex4ht:ref: sec:magic-state-distillation  --></a>.
One limitation of the Steane method is it only works for CSS codes.
The following exercise describes a procedure that works for all stabiliser
codes.
</p>
   <div class='newtheorem'>
<!-- l. 1379 --><p class='noindent'><span class='head'>
<a id='x15-295007r16'></a>
<span class='cmbx-10x-x-109'>Exercise* 12.16.</span>  </span>Consider the following “logical Bell state”, prepared on
two blocks of an <!-- l. 1380 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>⟦n</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>k</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi mathvariant='italic'>d⟧</mi></mrow></math>
stabiliser code with encoder <!-- l. 1380 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>:
</p>
<div class='center'>
<!-- l. 1382 --><p class='noindent'>
</p><!-- l. 1383 --><p class='noindent'><object data="svgs/logical-bell.svg" alt="diagram of logical-bell" class="svg-diagram"></object> </p></div>
<!-- l. 1386 --><p class='indent'>   The <span class='cmbx-10x-x-109'>Knill fault-tolerant measurement </span>protocol measures the full error
syndrome by performing a multi-qubit Bell meausurement between our data and
one code block of this state:
</p>
<div class='center'>
<!-- l. 1388 --><p class='noindent'>
</p><!-- l. 1389 --><p class='noindent'><object data="svgs/knill-ec.svg" alt="diagram of knill-ec" class="svg-diagram"></object> </p></div>
<!-- l. 1392 --><p class='indent'>   Show that this acts the same on the quantum state as measuring all of the stabilisers,
and show how the syndrome can be computed from the measurement outcome
<!-- l. 1392 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. <span class='cmti-10x-x-109'>Hint: use the
representation of </span><!-- l. 1393 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>
<span class='cmti-10x-x-109'>as </span><!-- l. 1393 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo>…</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math><span class='cmti-10x-x-109'>,
relate </span><!-- l. 1393 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>U</mi></mrow><mrow><mi>T</mi> </mrow></msup></math> <span class='cmti-10x-x-109'>to</span>
<!-- l. 1393 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></math> <span class='cmti-10x-x-109'>(they
are related by a Pauli string, depending on which stabilisers are self-transposed),
and show how to represent the outcome of a syndrome measurement in terms of</span>
<!-- l. 1393 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></math> <span class='cmti-10x-x-109'>and</span>
<!-- l. 1393 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math><span class='cmti-10x-x-109'>.</span>
                                                                     

                                                                     
</p>
   </div>
<!-- l. 1394 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='lattice-surgery'><span class='titlemark'>12.4.3   </span> <a id='x15-29600012.4.3'></a>Lattice surgery</h4>
<!-- l. 1406 --><p class='noindent'>As we mentioned in Section <a href='#transversal-clifford-gates'>12.4.1.1<!-- tex4ht:ref: sec:transversal-clifford  --></a>, the transversal CNOT gate might not be
the most convenient way to implement multi-qubit operations in the
surface code, because it breaks the 2D planar structure. It would be
nice if there was a way to implement multi-qubit operations between
neighbouring patches of surface code that only touch the boundaries of the code
patches, hence not requiring lots of non-local gates, which might be hard
to implement on platforms where qubits are embedded in the plane.
This is where lattice surgery comes in. This is a particular technique
for implementing multi-qubit operations in the surface code (or CSS
codes with similar structure) fault-tolerantly. Unlike the transversal gates
we considered before, these operations are not unitaries. The first class
of operation splits a logical qubit into two, and comes in two varieties:
</p><table class='equation-star'><tr><td>
<!-- l. 1409 --><object data="svgs/zsplit.svg" alt="diagram of zsplit" class="svg-diagram"></object></td></tr></table>
<!-- l. 1412 --><p class='indent'>   As these are both isometries, they can be performed deterministically.
However, the dual operation that merges two logical qubits into one is
non-deterministic: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 1413 --><object data="svgs/zmerge.svg" alt="diagram of zmerge" class="svg-diagram"></object></td></tr></table>
<!-- l. 1416 --><p class='indent'>   In other words, each of these operations is a degenerate measurement that
projects the 4D space of two logical qubits onto a 2D space, which we can then
treat as a single logical qubit. These operations can be combined to produce
multi-qubit operations such as a CNOT on the logical level:
</p>
<div class='center'>
<!-- l. 1419 --><p class='noindent'>
</p><!-- l. 1420 --><p class='noindent'><object data="svgs/merge-split-cnot.svg" alt="diagram of merge-split-cnot" class="svg-diagram"></object> </p></div>
<!-- l. 1423 --><p class='indent'>   up to a possible Pauli error, which can be corrected for in subsequent
operations. If one is additionally able to prepare single logical qubits in a handful
of fixed states, and can use merge operations to obtain arbitrary single-qubit
gates, and hence a universal model of computation. This explains how lattice
surgery works on the logical level. To explain what is happening at the physical
level, we can push these operations through the encoder. However, unlike
previous examples, these operations can actually change the code we
are using to encode our logical qubits. The surface code works for any
<!-- l. 1424 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>d</mi> <mo class='MathClass-bin' stretchy='false'>×</mo> <mi>e</mi></mrow></math> grid of qubits,
and has distance <!-- l. 1424 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>min</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>d</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>e</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
To explain the split and merge operations, we will use not
one encoder but a whole family of encoders of the form
<!-- l. 1425 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>E</mi></mrow><mrow><mi>d</mi><mo class='MathClass-bin' stretchy='false'>×</mo><mi>e</mi></mrow></msub></math> which embed
a single logical qubit into a grid of the appropriate size. Then, the physical operations
operations <!-- l. 1425 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle class='text'><mtext class='textrm' mathvariant='normal'>SPLIT</mtext></mstyle></math>
and <!-- l. 1425 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>MERGE</mtext></mstyle></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow><mrow><mi>k</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn></mrow></msub></math>
should commute with this family of encoders as follows: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 1426 --><object data="svgs/lattice-surgery-split.svg" alt="diagram of lattice-surgery-split" class="svg-diagram"></object></td></tr></table>
   <table class='equation-star'><tr><td>
<!-- l. 1429 --><object data="svgs/lattice-surgery-merge.svg" alt="diagram of lattice-surgery-merge" class="svg-diagram"></object></td></tr></table>
<!-- l. 1432 --><p class='indent'>   We’ll demonstrate these operations concretely on
<!-- l. 1432 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>3</mn> <mo class='MathClass-bin' stretchy='false'>×</mo> <mn>3</mn></mrow></math>
surface code patches, but in fact the same derivation will work for surface code
patches of any size. Let’s start with the Z-split, which is performed on a
<!-- l. 1432 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>d</mi> <mo class='MathClass-bin' stretchy='false'>×</mo> <mn>2</mn><mi>e</mi></mrow></math> patch of surface
code by performing <!-- l. 1432 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>X</mi></mrow></math>
measurements down the <!-- l. 1432 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>e</mi></math>-th
column as if this were the rightmost X boundary of a
<!-- l. 1432 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>d</mi> <mo class='MathClass-bin' stretchy='false'>×</mo> <mi>e</mi></mrow></math>
surface code patch. This will have the overall effect of splitting the
patch in twain. For this derivation, it will be most convenient to
use the X-form of the encoder. To perform the split itself, we do
<!-- l. 1433 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>X</mi></mrow></math>
measurements down the 3rd column as if this were the right boundary of a
<!-- l. 1433 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>3</mn> <mo class='MathClass-bin' stretchy='false'>×</mo> <mn>3</mn></mrow></math> surface
code patch. In this case, there is only one XX measurement to do. We can then use the
<!-- l. 1433 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>-copy rule
to push the <!-- l. 1433 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>jπ</mi></mrow></math>
phase coming from the measurement outcome on to the outputs:
</p>
<div class='center'>
<!-- l. 1435 --><p class='noindent'>
                                                                     

                                                                     
</p><!-- l. 1436 --><p class='noindent'><object data="svgs/X-split-meas-ec.svg" alt="diagram of X-split-meas-ec" class="svg-diagram"></object> </p></div>
<!-- l. 1439 --><p class='indent'>   Note we write <!-- l. 1439 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover class='overset'><mrow> <mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>e.c.</mtext></mstyle></mrow></mover></math>
to mean the two diagrams are equal up to “error correction”, i.e. Pauli
operators applied just on the outputs. These can be treated as errors on the
physical qubits and corrected later, so we will disregard them in our
calculation. Using the complementarity rule (c), we see that the existing
<!-- l. 1441 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>X</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>⊗</mo><mn>4</mn></mrow></msup></math> stabiliser
becomes a pair of <!-- l. 1441 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>X</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>⊗</mo><mn>2</mn></mrow></msup></math>
stabilisers. This can then be translated into a Z-copy followed by two encoders by
unfusing the bottom spider: </p><table class='equation-star'><tr><td>
<!-- l. 1442 --><object data="svgs/X-split-Z-1.svg" alt="diagram of X-split-Z-1" class="svg-diagram"></object></td></tr></table>
<!-- l. 1445 --><p class='indent'>   Next we do an X-merge by performing
<!-- l. 1445 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
stabiliser measurements along the boundary between two vertically-stacked
surface code patches, as if these were stabilisers of one big
<!-- l. 1445 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>6</mn> <mo class='MathClass-bin' stretchy='false'>×</mo> <mn>3</mn></mrow></math> patch. We can
eliminate the <!-- l. 1445 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
phases from the encoder by error correction, but this time we pick up a phase of
<!-- l. 1445 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>kπ</mi></mrow></math> where
<!-- l. 1445 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>j</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>j</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math> on the input (or
more generally <!-- l. 1445 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>j</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo><mo>…</mo> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>j</mi></mrow><mrow><mi>q</mi></mrow></msub></mrow></math>
for bigger patches). We can then use the “deformation” trick from equation
(<a href='#x15-287003r22'>12.22<!-- tex4ht:ref: eq:X-encoder-add  --></a>) to move the two logical operators on top of each other and apply strong
complementarity: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 1446 --><object data="svgs/X-merge-Z.svg" alt="diagram of X-merge-Z" class="svg-diagram"></object></td></tr></table>
   <table class='equation-star'><tr><td>
<!-- l. 1449 --><object data="svgs/X-merge-Z1.svg" alt="diagram of X-merge-Z1" class="svg-diagram"></object></td></tr></table>
<!-- l. 1452 --><p class='indent'>   Note that the applications of the spider law, complementarity, strong complementarity,
and <!-- l. 1452 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>-copy
rules in these two derivations extend naturally to larger surface code sizes. Also
note that reversing the colours of these two derivations and rotating
<!-- l. 1452 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>9</mn><msup><mrow><mn>0</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>∘</mo></mrow></msup></mrow></math> gives
recipes for remaining two operations of X-split and Z-merge, using the
Z-representation of the surface code embedding rather than the X-representation.
This gives us a nice 2D way to build CNOT gates, as well as more general
multi-qubit operations described by phase-free ZX diagrams, using just local
measurements in the surface code. We already noted in Section <a href='#transversal-clifford-gates'>12.4.1.1<!-- tex4ht:ref: sec:transversal-clifford  --></a> that we
nearly have transversal Hadamards in the surface code, as long as we
are willing to account for the fact that our surface might get rotated
<!-- l. 1453 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>9</mn><msup><mrow><mn>0</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>∘</mo></mrow></msup></mrow></math>. If we
only had T gates, we would have a universal set of gates which can be
conveniently performed on surface-code-encoded qubits. We can check that the
surface code is not a triorthogonal code, so it definitely doesn’t have a
transversal T gate. More generally, due to the Eastin-Knill theorem <a href='#x15-291002r5'>12.4.5<!-- tex4ht:ref: thm:eastin-knill  --></a>, we
know it doesn’t have any universal set of transversal one-qubit gates. So,
we need a different idea. This is where magic state distillation comes
in.
</p>
                                                                     

                                                                     
   <h3 class='sectionHead' id='magic-state-distillation'><span class='titlemark'>12.5   </span> <a id='x15-29700012.5'></a>Magic state distillation</h3>
<!-- l. 1457 --><p class='noindent'>We saw all the way back in Section <a href='main_htmlch3.html#magic-state-injection'>3.3.1<!-- tex4ht:ref: sec:magic-state-injection  --></a> that if we have access to states of the
form: </p><table class='equation-star'><tr><td>
<!-- l. 1458 --><object data="svgs/magic-state-injection-zx.svg" alt="diagram of magic-state-injection-zx" class="svg-diagram"></object></td></tr></table>
<!-- l. 1461 --><p class='indent'>   then we can do magic state injection using just CNOT, S, and a Pauli
measurement:
</p>
<div class='center'>
<!-- l. 1463 --><p class='noindent'>
</p><!-- l. 1464 --><p class='noindent'><object data="svgs/magic-state-injection-zx.svg" alt="diagram of magic-state-injection-zx" class="svg-diagram"></object> </p></div>
<!-- l. 1467 --><p class='indent'>   In fact, with lattice surgery in the surface code, we can do this even more
directly, since we can just MERGE the magic state right in:
</p>
<div class='center'>
<!-- l. 1469 --><p class='noindent'>
</p><!-- l. 1470 --><p class='noindent'><object data="svgs/magic-state-merge.svg" alt="diagram of magic-state-merge" class="svg-diagram"></object> </p></div>
<!-- l. 1473 --><p class='indent'>   In the case of the surface code, we don’t have a transversal S gate to perform
the classical correction. However, if we do state injection for S we only need to do
a Pauli correction:
</p>
<div class='center'>
<!-- l. 1475 --><p class='noindent'>
</p><!-- l. 1476 --><p class='noindent'><object data="svgs/magic-state-merge-s.svg" alt="diagram of magic-state-merge-s" class="svg-diagram"></object> </p></div>
                                                                     

                                                                     
<!-- l. 1479 --><p class='indent'>   Paulis are just logical operators, so they are always transversal
in any error correcting code. Even better, if we have an
<!-- l. 1479 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>S</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state
and access to H and CNOT, we can use it to catalyse as many S gates as we
want, following Section <a href='main_htmlch11.html#catalysis'>11.4<!-- tex4ht:ref: sec:catalysis  --></a>:
</p>
<div class='center'>
<!-- l. 1481 --><p class='noindent'>
</p><!-- l. 1482 --><p class='noindent'><object data="svgs/catalyse-s.svg" alt="diagram of catalyse-s" class="svg-diagram"></object> </p></div>
<!-- l. 1485 --><p class='indent'>   Thus, all we need to boost the surface code (and actually quite a wide
family of stabiliser codes) to computational universality is access to one
<!-- l. 1485 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>S</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state and lots of
<!-- l. 1485 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> states. In fact, as
soon as we have <!-- l. 1485 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states, we can build <!-- l. 1485 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>S</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states, at least probabilistically, so all we really need is enough
<!-- l. 1485 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> states.
That is what makes these states so magic. We found a code with a transversal
<!-- l. 1486 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gate
(Example <a href='#x15-293009r12'>12.4.12<!-- tex4ht:ref: ex:rm-15-1-3  --></a>) and one with a transversal CCZ (Example <a href='#x15-294008r16'>12.4.16<!-- tex4ht:ref: ex:smallest-interesting-cc  --></a>), but these
codes are actually not that good. They are not high distance, and they can’t perform
some other useful gates transversally. However, even though these codes are not any
good for doing <span class='cmti-10x-x-109'>all </span>of our quantum computation, they can help us prepare magic states
<!-- l. 1486 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> (and
later <!-- l. 1486 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mstyle class='text'><mtext>CCZ</mtext></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>)
using a technique called <span class='cmbx-10x-x-109'>magic state distillation</span>. Magic state
distillation works by taking many noisy copies of a state and turning
them into one less noisy one. To do this, we first form the encoded
<!-- l. 1487 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext class='MathClass-rel' stretchy='false'>|+⟩</mtext></mrow></math> state, then
apply a noisy <!-- l. 1487 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gate to each of our qubits using a bunch of noisy
<!-- l. 1487 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> states and
magic state injection, then decode back to a 1-qubit state to produce a less noisy
<!-- l. 1487 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> magic state.
To convince ourselves this could work, let’s start with an idealised case where we want to
produce a <!-- l. 1488 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
magic state on a single qubit and we have access to two things:
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 1490 --><p class='noindent'>perfect, noiseless Clifford operations, and
                                                                     

                                                                     
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 1491 --><p class='noindent'>a procedure that produces a “good” magic state <!-- l. 1491 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     with probability <!-- l. 1491 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow></msub></mrow></math>
     and an erroneous magic state <!-- l. 1491 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     with probability <!-- l. 1491 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow></msub></math>.
     </p></dd></dl>
<!-- l. 1493 --><p class='noindent'>We’ll see how to get something approximating these assumptions on our actual hardware
later, but this simple case will be enough to get the main idea. Now, let’s start with
an <!-- l. 1494 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
state, which we prepare using our “perfect” Clifford operations, and encode it
with some error correcting code with a transversal T gate, such as the
<!-- l. 1494 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>⟦</mi><mn>15</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>3</mn><mi>⟧</mi></mrow></math> code from
Example <a href='#x15-293009r12'>12.4.12<!-- tex4ht:ref: ex:rm-15-1-3  --></a>. We can then do magic state injections on all 15 of the physical
qubits using 15 (possibily erroneous) magic states. We can then decode back to a
single qubit using the decoder described in Section <a href='#the-decoder'>12.2.4<!-- tex4ht:ref: sec:decoder  --></a>, post-selected onto
syndrome <!-- l. 1494 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover></math>:
</p><table class='equation'><tr><td>
<!-- l. 1495 --><p class='indent'>
</p><!-- l. 1495 --><object id='x15-297003r59' data="svgs/eq-magic-state-distill.svg" alt="diagram of eq:magic-state-distill" class="svg-diagram"></object></td><td class='eq-no'>(12.59)</td></tr></table>
<!-- l. 1498 --><p class='indent'>   If no errors occurred in this process, we will indeed always get a syndrome
<!-- l. 1498 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover></math>
which is what we want. If instead we get a non-zero syndrome
<!-- l. 1498 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>s</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>≠</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover></mrow></math>, then
we throw away the resulting state away and try again. Note that since we are
assuming that all Clifford operations are perfect and noiseless, that the
only way we could get a non-zero error is because of some fault in the
<!-- l. 1498 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states. Hence if we indeed got a syndrome of
<!-- l. 1499 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover></math>, then the resulting
‘distilled’ <!-- l. 1499 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state only
contains an error if the noisy <!-- l. 1499 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
introduced some undetected error. Since the code has distance
                                                                     

                                                                     
three, at least three magic states needed to get an error. If we
assume the errors occur independently, this probability is at most
<!-- l. 1500 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mrow><mo fence='true' form='prefix'>(</mo><mfrac linethickness='0.0pt'><mrow><mn>15</mn></mrow>
 <mrow><mn>3</mn></mrow></mfrac><mo fence='true' form='postfix'>)</mo></mrow> <msubsup><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow><mrow><mn>3</mn></mrow></msubsup></mrow></math>
(ignoring the much less likely scenario of getting more than 3 errors).
In fact, even distance-3 codes can detect <span class='cmti-10x-x-109'>some </span>3-qubit errors, so the
probability can actually be a bit lower than that. For the case of the
<!-- l. 1500 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>⟦</mi><mn>15</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>3</mn><mi>⟧</mi></mrow></math>,
there are just 35 undetectable triplets of errors, and so the probability is
<!-- l. 1500 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>35</mn><msubsup><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow><mrow><mn>3</mn></mrow></msubsup></mrow></math>. Hence, while we
started with 15 <!-- l. 1500 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> states
that have probability <!-- l. 1500 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow></msub></math>
of getting an error, we ended up with 1
<!-- l. 1500 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state with probability
<!-- l. 1500 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>35</mn><msubsup><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow><mrow><mn>3</mn></mrow></msubsup></mrow></math> of having an error.
Hence, as long as <!-- l. 1500 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>35</mn><msubsup><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow><mrow><mn>3</mn></mrow></msubsup></mrow></math>,
we have made progress. In fact, for reasonably small
<!-- l. 1500 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow></msub></math>,
we have made a LOT of progress. Let’s do some calculations
to see how much we have accomplished. First, note that
<!-- l. 1501 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>35</mn><msup><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow></msub></mrow><mrow><mn>3</mn></mrow></msup></mrow></math> when
<!-- l. 1501 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><msqrt><mrow><mn>35</mn></mrow></msqrt> <mo class='MathClass-rel' stretchy='false'>≈</mo> <mn>0.17</mn></mrow></math>. So even if we
start with <!-- l. 1501 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states that have an error rate of up to 17% we can use this
protocol to improve them. But let’s suppose we start with
<!-- l. 1501 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn><msup><mrow><mn>0</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>2</mn></mrow></msup></mrow></math>, a 1%
error rate. There are already many quantum devices that are below this error
rate. We see that after a single successful round distillation, we have
<!-- l. 1501 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>3.5</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mn>1</mn><msup><mrow><mn>0</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>5</mn></mrow></msup></mrow></math>. If
this isn’t good enough, we just take 15 of these better states and use
them in another round of distillation. After a second round we have
<!-- l. 1501 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>≈</mo> <mn>1.5</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mn>1</mn><msup><mrow><mn>0</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>12</mn></mrow></msup></mrow></math>. A third
round gives <!-- l. 1501 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mn>3</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>≈</mo> <mn>1.18</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mn>1</mn><msup><mrow><mn>0</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>34</mn></mrow></msup></mrow></math>.
This is already a much better error rate then we would ever need to do any realistic
computation. So, doing successive rounds of magic state distillation exponentially
suppresses the probability of an error. However, it also has an exponential cost in
noisy <!-- l. 1502 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states. For example, doing three rounds of this 15-to-1 protocol requires at least
<!-- l. 1502 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>15</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mn>15</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mn>15</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>3375</mn></mrow></math> noisy
<!-- l. 1502 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states. However, we haven’t yet accounted for the states we have to throw
away when the protocol fails. Our protocol aborts when we get a
non-trivial syndrome. By far the most likely reason to get a non-trivial
syndrome is when we see 1 error. The probability of this happening is
<!-- l. 1503 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>15</mn><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow></msub></mrow></math>.
                                                                     

                                                                     
So in the first layer of distillation, when we have
<!-- l. 1503 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0.01</mn></mrow></math>, the probability the
protocol fails is <!-- l. 1503 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>15</mn><mi>%</mi></mrow></math>.
To get the actual cost estimate, we hence need to multiply the
cost of running the protocol once by the estimated number of
runs we need to get a successful run. For the first layer this is
<!-- l. 1503 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>15</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>0.15</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>≈</mo> <mn>17</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mn>6</mn></mrow></math>. Hence, the
expected <!-- l. 1503 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> cost
to produce one <!-- l. 1503 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
state of error <!-- l. 1503 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>3.5</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mn>1</mn><msup><mrow><mn>0</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>5</mn></mrow></msup></mrow></math>
is <!-- l. 1503 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>17</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mn>6</mn></mrow></math> instead
of <!-- l. 1503 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>15</mn></mrow></math>.
By the time we get to the second and third layers, the probability of getting an
error is already so small that the expected cost is very close to 15. Multiplying
<!-- l. 1503 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>17</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mn>6</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mn>15</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mn>15</mn></mrow></math>, we see we can distill
a very, very good <!-- l. 1503 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
state for an expected cost of around 4000 noisy ones. Inserting some magic into
our computation sure seems to come at a cost. But while this is expensive, it is
not totally crazy. This was one of the first protocols for doing magic state
distillation, and its possible to bring this cost down quite a bit by finding better
codes and protocols. In the next section, we will show a state-of-the-art
distillation protocol using almost all of the ingredients we’ve covered in this
book so far, but before we get there, let’s revisit the two simplifying
assumptions we made at the start. The first was that we can do perfect,
noiseless Clifford operations. Of course, nothing in quantum-computing
land is noiseless, but if we have a family of error correcting codes of
increasing distance with fault-tolerant implementations of all Clifford
operations, we can perform Cliffords with arbitrary low levels of noise. To
benefit from this, we can do magic state distillation <span class='cmti-10x-x-109'>inside </span>of another code
<!-- l. 1505 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>E</mi></mrow><mrow><mi>c</mi></mrow></msub></math>
that has high-distance and fault-tolerant implementations
of Clifford gates. Rather than starting with 15 physical
<!-- l. 1505 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> states and
performing a round of distillation using physical gates and measurements, we prepare 15
noisy <span class='cmti-10x-x-109'>logical </span><!-- l. 1505 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 1506 --><object data="svgs/logical-t-state.svg" alt="diagram of logical-t-state" class="svg-diagram"></object></td></tr></table>
<!-- l. 1509 --><p class='indent'>   and then perform the whole protocol (<a href='#x15-297003r59'>12.59<!-- tex4ht:ref: eq:magic-state-distill  --></a>) encoded within
<!-- l. 1509 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>E</mi></mrow><mrow><mi>c</mi></mrow></msub></math>. Since
<!-- l. 1510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>E</mi></mrow><mrow><mi>c</mi></mrow></msub></math> doesn’t have
transversal <!-- l. 1510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates,
we can’t prepare <!-- l. 1510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>T</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
fault-tolerantly, but we can still prepare possibly faulty
<!-- l. 1510 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>T</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states, which we then distill to get better ones. Generally to make this
procedure as efficient as possible, we want to pick an ‘ambient’ code
<!-- l. 1511 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>E</mi></mrow><mrow><mi>c</mi></mrow></msub></math>
whose probability of producing a logical error during the distillation protocol is
just a bit lower than the logical error of the produced distilled states. This
makes the Clifford operations ‘just good enough’ so that we can treat
them as perfect, while not being overkill by using an overly expensive
code.
</p>
   <div class='newtheorem'>
<!-- l. 1512 --><p class='noindent'><span class='head'>
<a id='x15-297004r1'></a>
<span class='cmbx-10x-x-109'>Remark 12.5.1.</span>  </span>    The    surface    code    doesn’t    have    transversal
<!-- l. 1513 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
gates,  so  we  don’t  know  yet  that  it  implements  the  full  Clifford
group.  Nevertheless,  we  can  still  perform  the  analogous  protocol  to
(<a href='#x15-297003r59'>12.59<!-- tex4ht:ref: eq:magic-state-distill  --></a>)  using   only   CNOT,   H,   and   Paulis   in   order   to   distill   an
<!-- l. 1513 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>S</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
state.                                                                                        As
we already remarked at the end of Section <a href='#lattice-surgery'>12.4.3<!-- tex4ht:ref: sec:lattice-surgery  --></a>, once we have one good
<!-- l. 1513 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>S</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
state,    we    can    use    it    to    catalyse    as    many    fault-tolerant
<!-- l. 1513 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
gates as we need, and hence the full Clifford group.
</p>
   </div>
<!-- l. 1514 --><p class='indent'>    The second assumption was that the only kind of error we get is getting
<!-- l. 1515 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> instead of
                                                                     

                                                                     
<!-- l. 1515 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> with some
probability <!-- l. 1515 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow></msub></math>.
Of course, many kinds of errors could happen when trying to prepare
<!-- l. 1515 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>T</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, not just those that
make a logical error of <!-- l. 1515 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>Z</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>T</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mstyle mathvariant='script'><mi>Z</mi></mstyle></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>T</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
However, there is a nice trick, called <span class='cmbx-10x-x-109'>twirling</span>, which we can use to project all
the other kinds of errors that might happen down to either “no error” or a
<!-- l. 1516 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math> error. Start
with a <!-- l. 1516 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>T</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
state subject to arbitrary noise, and then with 50% probability, apply a logical
unitary <!-- l. 1516 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>S</mi></mrow><mo accent='true'>~</mo></mover><mover accent='true'><mrow><mi>X</mi></mrow><mo accent='true'>~</mo></mover></mrow></math>.
After we do this, we can treat the resulting state as either staying the same
(<!-- l. 1516 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> is an eigenstate
of <!-- l. 1516 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>SX</mi></mrow></math> after all)
or flipping to <!-- l. 1516 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
with some small probability. It probably seems rather counter-intuitive that this
works. The best way to understand this is in the language of quantum mixed
states and channels from Section* <a href='main_htmlch2.html#quantum-mixed-states-and-channels'>2.7.1<!-- tex4ht:ref: sec:channels  --></a>. We leave the details as a starred
exercise:
</p>
   <div class='newtheorem'>
<!-- l. 1517 --><p class='noindent'><span class='head'>
<a id='x15-297005r17'></a>
<span class='cmbx-10x-x-109'>Exercise* 12.17.</span>  </span>In this exercise we will find out why we may assume that the error in
preparing a <!-- l. 1518 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
is only a <!-- l. 1518 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>,
and nothing else.
   </p><dl class='enumerate'><dt class='enumerate'>
a) </dt><dd class='enumerate'>
   <!-- l. 1520 --><p class='noindent'>Show that <!-- l. 1520 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
   and <!-- l. 1520 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
   are eigenstates of the operator <!-- l. 1520 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>SX</mi></mrow></math>.
   </p></dd><dt class='enumerate'>
b) </dt><dd class='enumerate'>
   <!-- l. 1521 --><p class='noindent'>Let <!-- l. 1521 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='normal'>Φ</mi></math>
   be the quantum channel acting on a qubit density matrix <!-- l. 1521 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ρ</mi></math>
   via <!-- l. 1521 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='normal'>Φ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>ρ</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mi>ρ</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>SX</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>ρ</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>SX</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></mrow></math>.
   Show that <!-- l. 1521 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>T</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
   and <!-- l. 1521 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>T</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>Z</mi></mrow></math>
   are fixed points of <!-- l. 1521 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='normal'>Φ</mi></math>
                                                                     

                                                                     
   and that it sends <!-- l. 1521 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>T</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>Z</mi></mrow></math>
   and <!-- l. 1521 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>T</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
   to zero.
   </p></dd><dt class='enumerate'>
c) </dt><dd class='enumerate'>
   <!-- l. 1522 --><p class='noindent'>Conclude that <!-- l. 1522 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='normal'>Φ</mi></math>
   is a projector to the space spanned by <!-- l. 1522 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>T</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
   and <!-- l. 1522 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>T</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>Z</mi></mrow></math>.
   </p></dd><dt class='enumerate'>
d) </dt><dd class='enumerate'>
   <!-- l. 1523 --><p class='noindent'>Argue then that for every density matrix <!-- l. 1523 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ρ</mi></math>
   we have a probability <!-- l. 1523 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow></msub></math>
   such that <!-- l. 1523 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='normal'>Φ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>ρ</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>T</mi><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow></msub><mi>Z</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>T</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>Z</mi></mrow></math>.
   </p></dd></dl>
<!-- l. 1525 --><p class='noindent'>We see then that the resulting mixed state is a convex combination of the pure states
<!-- l. 1525 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> and
<!-- l. 1525 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, which behaves
identically to a perfect <!-- l. 1525 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
state that gets a <!-- l. 1525 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>-flip
with probability <!-- l. 1525 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow></msub></math>.
</p>
   </div>
<!-- l. 1526 --><p class='indent'>    In summary, we have managed to convince ourselves that magic state
distillation works, even starting from fairly realistic assumptions about what we
can do on a real quantum computer. However, 4000-to-1 is still pretty expensive,
so let’s see if we can bring that cost down.
</p>
   <h4 class='subsectionHead' id='ccz-distillation-and-catalysis'><span class='titlemark'>12.5.1   </span> <a id='x15-29800012.5.1'></a>CCZ distillation and catalysis</h4>
<!-- l. 1529 --><p class='noindent'>We can use magic state distillation to build other kinds of non-Clifford states as
well. A particularly handy one is the CCZ magic state: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 1530 --><object data="svgs/ccz-magic-state.svg" alt="diagram of ccz-magic-state" class="svg-diagram"></object></td></tr></table>
<!-- l. 1533 --><p class='indent'>   In this section, we’ll build a distillation protocol for it based on the
<!-- l. 1533 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>⟦</mi><mn>8</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>3</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mi>⟧</mi></mrow></math>
code given in Example <a href='#x15-294008r16'>12.4.16<!-- tex4ht:ref: ex:smallest-interesting-cc  --></a>. In this code we can use 8
<!-- l. 1533 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates
to implement a CCZ gate:
</p>
<div class='center'>
<!-- l. 1535 --><p class='noindent'>
</p><!-- l. 1536 --><p class='noindent'><object data="svgs/sicc-transversal.svg" alt="diagram of sicc-transversal" class="svg-diagram"></object> </p></div>
<!-- l. 1539 --><p class='indent'>   Using this property, we can start with an encoded
<!-- l. 1539 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext class='MathClass-rel' stretchy='false'>|+++⟩</mtext></mrow></math>
state and apply transversal T gates to end up with a
<!-- l. 1539 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mstyle class='text'><mtext>CCZ</mtext></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> magic
state. This in turn can be used to inject a CCZ gate at will using the procedure
described in Exercise <a href='main_htmlch10.html#x13-228015r5'>10.5<!-- tex4ht:ref: exer:CCZ-injection  --></a> using just Clifford operations. We can use this
<!-- l. 1540 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>⟦</mi><mn>8</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>3</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mi>⟧</mi></mrow></math> code to distil a
<!-- l. 1540 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mstyle class='text'><mtext>CCZ</mtext></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> with a lower error
probability than the input <!-- l. 1540 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states using the repeat-until-success approach we described above. Because the code is
distance <!-- l. 1540 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>2</mn></math>,
it can detect up to one error. As there is just one
<!-- l. 1540 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
stabiliser with support on all 8 qubits, we know that any combination of two
errors leads to a trivial syndrome and hence will not be detectable, so that any
pair of two errors will lead to the protocol failing. An input error probability of
<!-- l. 1540 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn></mrow></msub></math> for the
<!-- l. 1540 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates hence gets boosted
to <!-- l. 1540 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mrow><mo fence='true' form='prefix'>(</mo><mfrac linethickness='0.0pt'><mrow><mn>8</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac><mo fence='true' form='postfix'>)</mo></mrow><msup><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn></mrow></msub></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>28</mn><msup><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn></mrow></msub></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>. This procedure then
has a threshold of <!-- l. 1540 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>28</mn> <mo class='MathClass-rel' stretchy='false'>≈</mo> <mn>0.036</mn></mrow></math>,
or <!-- l. 1540 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>3.6</mn><mi>%</mi></mrow></math> for
improving the error in the CCZ. Note that this protocol is not directly stackable: it takes in
<!-- l. 1541 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> magic states,
but outputs a <!-- l. 1541 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mstyle class='text'><mtext>CCZ</mtext></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
magic state. For this reason (and another one we will see soon), this distillation
                                                                     

                                                                     
protocol is mostly used as a final stage, where we already have relatively high-quality
<!-- l. 1542 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states, and we wish to convert them into a still higher quality
<!-- l. 1542 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mstyle class='text'><mtext>CCZ</mtext></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. Suppose for instance
that we start with <!-- l. 1543 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> states
with an error rate of <!-- l. 1543 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn><msup><mrow><mn>0</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>3</mn></mrow></msup></mrow></math>
(current machines get pretty close to being able to prepare states with this
precision). Then one round of the 15-to-1 distillation described above gives us
<!-- l. 1543 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>35</mn><msup><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn></mrow></msub></mrow><mrow><mn>3</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>3.5</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mn>1</mn><msup><mrow><mn>0</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>8</mn></mrow></msup></mrow></math>. Using
these states in our CCZ distillation protocol gives us a CCZ gate which has an error
probability of <!-- l. 1543 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>28</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo><msup><mrow> <msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn></mrow></msub></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>3.43</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mn>1</mn><msup><mrow><mn>0</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>14</mn></mrow></msup></mrow></math>.
That is: we can expect to do about 30 trillion CCZ gates before
we encounter one that is faulty. The cost for this is only about
<!-- l. 1544 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>15</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mn>8</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>120</mn></mrow></math> noisy
<!-- l. 1544 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> states per distilled CCZ.
Instead of using the <!-- l. 1545 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mstyle class='text'><mtext>CCZ</mtext></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
magic states to implement a CCZ gate, we can also use them to implement
<!-- l. 1545 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates.
As we saw in Section <a href='main_htmlch11.html#catalysis'>11.4<!-- tex4ht:ref: sec:catalysis  --></a>, a CCZ gate can be converted back into two separate
<!-- l. 1546 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states using <span class='cmti-10x-x-109'>catalysis</span>. If we do that with the CCZs produced
by this protocol, this then gives us a pipeline to convert 8
<!-- l. 1547 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates into one better CCZ, which is then converted into
<!-- l. 1547 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>2</mn></math>
<!-- l. 1547 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates.
This is then effectively an 8-to-2 protocol with an error improvement of
<!-- l. 1547 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>→</mo> <mn>28</mn><msup><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>e</mi></mrow></msub></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>.
But there is an important detail here we shouldn’t forget: when
the protocol fails, i.e. more than one error happens so that we get
a CCZ with an error, then when we convert this CCZ into two
<!-- l. 1548 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states, both of these states will potentially inherit this error.
Hence, when we do this we will get <span class='cmti-10x-x-109'>correlated </span>errors. If these
<!-- l. 1548 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates are
directly used in the final computation we wish to execute, this is not a problem since
there we would consider any single error already catastrophic, so the probability
of a double error being higher doesn’t affect the overall success probability of the
computation. However, if we were to reuse these potentially “damaged”
<!-- l. 1548 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states in another round of distillation, we might get a much higher
chance of the protocol failing, and hence not get as good a quality of
<!-- l. 1548 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states out of it as we would expect. Despite these problems, the fact that we can
                                                                     

                                                                     
distil at a rate of 8-to-2 is clearly a lot higher than 15-to-1, and as such this
catalysis-based protocol, or variations of it, form part of some of the best-performing
proposals for magic state distillation out there. In particular, as it takes 120
<!-- l. 1549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> for one CCZ, catalysing
this back into 2 <!-- l. 1549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>’s gives
an effective rate of 60 <!-- l. 1549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states with error <!-- l. 1549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn><msup><mrow><mn>0</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>3</mn></mrow></msup></mrow></math>
getting converted into 1 <!-- l. 1549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
state with error <!-- l. 1549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>3.43</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mn>1</mn><msup><mrow><mn>0</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>14</mn></mrow></msup></mrow></math>.
</p>
   <h3 class='sectionHead' id='summary-what-to-remember9'><span class='titlemark'>12.6   </span> <a id='x15-29900012.6'></a>Summary: What to remember</h3>
<!-- l. 1552 --><p class='noindent'>
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 1552 --><p class='noindent'>A <span class='cmti-10x-x-109'>quantum error correcting code </span>is a subspace of <!-- l. 1552 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
     space. It lets us detect and correct errors by performing measurements
     to see if we have left the subspace.
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 1553 --><p class='noindent'><span class='cmti-10x-x-109'>Stabiliser codes </span>are a family of quantum error correcting codes we
     can efficiently represent and manipulate using stabiliser theory
     and/or the Clifford ZX-calculus. They are subspaces of the form:
     </p><table class='equation-star'><tr><td>
     <!-- l. 1554 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                       <mstyle class='text'><mtext>Stab</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>{</mo><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='nbsp' width='0.33em'></mspace><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mi class='MathClass-op'>∀</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo><mstyle mathvariant='script'><mi>S</mi></mstyle><mo class='MathClass-close' stretchy='false'>}</mo>
</mrow></math></td></tr></table>
     <!-- l. 1557 --><p class='noindent'>for a stabiliser group <!-- l. 1557 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>S</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
                                                                     

                                                                     
     <!-- l. 1558 --><p class='noindent'>An <!-- l. 1558 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>⟦n</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>k</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi mathvariant='italic'>d⟧</mi></mrow></math>
     stabiliser code encodes <!-- l. 1558 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
     logical qubits in <!-- l. 1558 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
     physical qubits and can detect any Pauli error of weight <!-- l. 1558 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>d</mi></mrow></math>
     and correct any error of weight <!-- l. 1558 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math>
     where <!-- l. 1558 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi>t</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>d</mi></mrow></math>.
     </p></dd><dt class='enumerate'>
  4.. </dt><dd class='enumerate'>
     <!-- l. 1559 --><p class='noindent'>We can relate logical qubits to physical qubits via an isometry called
     the <span class='cmti-10x-x-109'>encoder map</span>:
</p>
     <div class='center'>
<!-- l. 1561 --><p class='noindent'>
</p><!-- l. 1562 --><p class='noindent'><object data="svgs/embedding.svg" alt="diagram of embedding" class="svg-diagram"></object> </p></div>
     <!-- l. 1565 --><p class='noindent'>This requires picking <span class='cmti-10x-x-109'>logical Pauli operators </span>in addition to the stabiliser of
     the code in order to fully determine the encoder (Section <a href='#encoders-and-logical-operators'>12.2.3<!-- tex4ht:ref: sec:encoder  --></a>).
     </p></dd><dt class='enumerate'>
  5.. </dt><dd class='enumerate'>
     <!-- l. 1566 --><p class='noindent'>For <span class='cmti-10x-x-109'>CSS codes</span>, the encoder can always be written in one of two simple
     equivalent forms: the X-form and the Z-form. Using the scalable
     ZX-calculus, these are: </p><table class='equation-star'><tr><td>
     <!-- l. 1567 --><object data="svgs/encoder-scalable.svg" alt="diagram of encoder-scalable" class="svg-diagram"></object></td></tr></table>
     <!-- l. 1570 --><p class='noindent'>where the columns of <!-- l. 1570 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>L</mi></mrow><mrow><mi>X</mi></mrow></msub></math>
     and <!-- l. 1570 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mi>X</mi></mrow></msub></math>
     represent X-logical operators and X-stabilisers, respectively, and similarly the columns
     of <!-- l. 1570 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>L</mi></mrow><mrow><mi>Z</mi></mrow></msub></math>
                                                                     

                                                                     
     and <!-- l. 1570 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mi>Z</mi></mrow></msub></math>
     represent Z-logical operators and Z-stabilisers (Section <a href='#scalable-zx-notation-for-css-codes'>12.3.5<!-- tex4ht:ref: sec:scalable-css  --></a>).
     </p></dd><dt class='enumerate'>
  6.. </dt><dd class='enumerate'>
     <!-- l. 1571 --><p class='noindent'>The <span class='cmti-10x-x-109'>surface code </span>is a well-studied family of codes, with many nice
     properties such as high levels of noise resistance, efficient decoding, and
     the ability to implement it using just 2D nearest-neighbour gates
     (Section <a href='#the-surface-code'>12.3.4<!-- tex4ht:ref: sec:surface-code  --></a>). </p><table class='equation-star'><tr><td>
     <!-- l. 1572 --><object data="svgs/surface9.svg" alt="diagram of surface9" class="svg-diagram"></object></td></tr></table>
     </dd><dt class='enumerate'>
  7.. </dt><dd class='enumerate'>
     <!-- l. 1575 --><p class='noindent'>We can do entangling operations between qubits encoded in the surface
     code using <span class='cmti-10x-x-109'>lattice surgery </span>(Section <a href='#lattice-surgery'>12.4.3<!-- tex4ht:ref: sec:lattice-surgery  --></a>), which logically encodes the <span class='cmti-10x-x-109'>split</span>
     and <span class='cmti-10x-x-109'>merge </span>operations: </p><table class='equation-star'><tr><td>
     <!-- l. 1576 --><object data="svgs/zsplit-1.svg" alt="diagram of zsplit-1" class="svg-diagram"></object></td></tr></table>
     <table class='equation-star'><tr><td>
                                                                     

                                                                     
     <!-- l. 1579 --><object data="svgs/zmerge-1.svg" alt="diagram of zmerge-1" class="svg-diagram"></object></td></tr></table>
     </dd><dt class='enumerate'>
  8.. </dt><dd class='enumerate'>
     <!-- l. 1582 --><p class='noindent'>In order to achieve <span class='cmti-10x-x-109'>fault tolerance</span>, we must find ways to implement error
     correction, as well as the building blocks of universal quantum computation
     (e.g. state preparation, unitaries, and measurements) on encoded qubits
     without spreading errors (Section <a href='#faulttolerance'>12.4<!-- tex4ht:ref: sec:fault-tolerance  --></a>).
     </p></dd><dt class='enumerate'>
  9.. </dt><dd class='enumerate'>
     <!-- l. 1583 --><p class='noindent'><span class='cmti-10x-x-109'>Transversal </span>unitary operations are fault tolerant because they only involve
     tensor products of operations on one qubit from each code block. However,
     no single code admits a universal set of transversal gates, due to the
     Eastin-Knill theorem.
     </p></dd><dt class='enumerate'>
 10.. </dt><dd class='enumerate'>
     <!-- l. 1584 --><p class='noindent'>CNOT gates are transversal for CSS codes and H gates are transversal for
     self-dual CSS codes (Theorems <a href='#x15-292006r6'>12.4.6<!-- tex4ht:ref: thm:trans-cnot-css  --></a> and <a href='#x15-292014r9'>12.4.9<!-- tex4ht:ref: thm:trans-h-css  --></a>): </p><table class='equation-star'><tr><td>
     <!-- l. 1585 --><object data="svgs/trans-cnot-scalable.svg" alt="diagram of trans-cnot-scalable" class="svg-diagram"></object></td></tr></table>
     </dd><dt class='enumerate'>
 11.. </dt><dd class='enumerate'>
                                                                     

                                                                     
     <!-- l. 1588 --><p class='noindent'><span class='cmti-10x-x-109'>Strongly triorthogonal </span>codes have transversal T gates (Theorem <a href='#x15-293006r11'>12.4.11<!-- tex4ht:ref: thm:char-trans-t  --></a>):
</p>
     <div class='center'>
<!-- l. 1590 --><p class='noindent'>
</p><!-- l. 1591 --><p class='noindent'><object data="svgs/trans-t-simp.svg" alt="diagram of trans-t-simp" class="svg-diagram"></object> </p></div>
     <!-- l. 1594 --><p class='noindent'>and triorthogonal codes have transversal T gates up to a (possibly
     non-transversal) Clifford unitary on the physical qubits.
     </p></dd><dt class='enumerate'>
 12.. </dt><dd class='enumerate'>
     <!-- l. 1595 --><p class='noindent'>Fault-tolerant syndrome-extraction protocols perform stabiliser
     measurements without spreading errors on the data qubits (Section <a href='#faulttolerant-pauli-measurements'>12.4.2<!-- tex4ht:ref: sec:ft-meas  --></a>).
     Many of these protocols, like Shor’s, can be seen as “unfusing” the Pauli
     projector:
</p>
     <div class='center'>
<!-- l. 1597 --><p class='noindent'>
</p><!-- l. 1598 --><p class='noindent'><object data="svgs/zzz-unfuse-parallel.svg" alt="diagram of zzz-unfuse-parallel" class="svg-diagram"></object> </p></div>
     </dd><dt class='enumerate'>
 13.. </dt><dd class='enumerate'>
     <!-- l. 1601 --><p class='noindent'>Magic state distillation lets us turn many noisy copies of a magic state into
     fewer, less-noisy copies:
</p>
     <div class='center'>
<!-- l. 1603 --><p class='noindent'>
</p><!-- l. 1604 --><p class='noindent'><object data="svgs/magic-state-distill.svg" alt="diagram of magic-state-distill" class="svg-diagram"></object> </p></div>
     <!-- l. 1607 --><p class='noindent'>This can be very costly, requiring thousands of noisy
     <!-- l. 1607 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     states to distil a very clean one (Section <a href='#magic-state-distillation'>12.5<!-- tex4ht:ref: sec:magic-state-distillation  --></a>). We can distill not just
     <!-- l. 1607 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     states, but also CCZ magic states.
                                                                     

                                                                     
     </p></dd><dt class='enumerate'>
 14.. </dt><dd class='enumerate'>
     <!-- l. 1608 --><p class='noindent'>Using a high-distance code with transversal Clifford operations, such as the
     surface code, along with magic state distillation, is a promising method
     for implementing universal fault-tolerant quantum computation.
     </p></dd></dl>
<!-- l. 1610 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='references-and-further-reading9'><span class='titlemark'>12.7   </span> <a id='x15-30000012.7'></a>References and Further Reading</h3>
<!-- l. 1611 --><p class='noindent'><span class='paragraphHead' id='origins-of-quantum-error-correction'><a id='x15-301000'></a><span class='cmbx-10x-x-109'>Origins of quantum error correction</span></span>
   All the core ideas of quantum error correction—quantum codes, fault-tolerant
computations, the treshold theorem, stabiliser theory—originated in a flurry of
activity between 1995 and 1999, with especially significant contributions by Shor,
Steane, Gottesman and Kitaev. Many ideas were discovered independently by
several people at the same. The original idea of quantum error correction was
introduced independently by [<a href='main_htmlli3.html#XPhysRevA.52.R2493'>211</a>] and [<a href='main_htmlli3.html#XPhysRevLett.77.793'>216</a>]. General conditions that any (not
necessarily stabiliser) code must satisfy to correct errors were independently
found in [<a href='main_htmlli3.html#XPhysRevA.54.3824'>27</a>] and [<a href='main_htmlli3.html#XPhysRevA.55.900'>156</a>] and are now sometimes called the <span class='cmti-10x-x-109'>Knill-LaFlamme
conditions</span>. The “History and further reading” section of Chapter 10 of [<a href='main_htmlli3.html#XNielsenChuang'>188</a>]
provides many more references to the early developments in quantum error
correction.
</p>
<!-- l. 1613 --><p class='noindent'><span class='paragraphHead' id='origin-of-some-quantum-codes'><a id='x15-302000'></a><span class='cmbx-10x-x-109'>Origin of some quantum codes</span></span>
   The 9-qubit Shor code was discovered by, well, Shor [<a href='main_htmlli3.html#XPhysRevA.52.R2493'>211</a>] and the
7-qubit Steane code by, you guessed it, Steane [<a href='main_htmlli3.html#XPhysRevLett.77.793'>216</a>]. The 5-qubit code
was discovered independently (again) by both [<a href='main_htmlli3.html#XPhysRevA.54.3824'>27</a>] and [<a href='main_htmlli3.html#XPhysRevLett.77.198'>161</a>]. Stabiliser
theory and the idea of stabiliser codes was introduced by [<a href='main_htmlli3.html#Xgottesman1997stabilizer'>112</a>]. The idea
to combine a pair of orthogonal classical codes into a single quantum
code was discovered independently by [<a href='main_htmlli3.html#XPhysRevA.54.1098'>45</a>] and [<a href='main_htmlli3.html#XPhysRevA.54.4741'>217</a>] and hence these
are named Calderbank-Shor-Steane (CSS) codes in their honour. The
<!-- l. 1613 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>⟦</mi><mn>8</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>3</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mi>⟧</mi></mrow></math>
‘smallest interesting colour code’ was described as such by [<a href='main_htmlli3.html#XCampbell2016ColourCode'>46</a>], where Campbell
shows that this code has a transversal CCZ gate (note that the 7-qubit
Steane code is the <span class='cmti-10x-x-109'>smallest </span>non-trivial colour code, but since it has no
non-Clifford transversal gates it was not interesting according to that
post).
                                                                     

                                                                     
</p>
<!-- l. 1614 --><p class='noindent'><span class='paragraphHead' id='fault-tolerance'><a id='x15-303000'></a><span class='cmbx-10x-x-109'>Fault tolerance</span></span>
   An early statement and proof of a fault-tolerant threshold theorem goes back
to [<a href='main_htmlli3.html#Xshor1996fault'>212</a>]. This was improved upon by many other groups, including [<a href='main_htmlli3.html#Xaharonov1997fault'>5</a>], [<a href='main_htmlli3.html#Xknill1998resilient'>157</a>],
[<a href='main_htmlli3.html#Xkitaev2003fault'>153</a>], and [<a href='main_htmlli3.html#Xaliferis2005quantum'>8</a>] under various assumptions and error models. Shor’s protocol for
fault-tolerant stabiliser measurements is from [<a href='main_htmlli3.html#Xshor1996fault'>212</a>], Steane’s from [<a href='main_htmlli3.html#Xsteane1997active'>218</a>], and
Knill’s from [<a href='main_htmlli3.html#Xknill2005quantum'>155</a>].
</p>
<!-- l. 1615 --><p class='noindent'><span class='paragraphHead' id='transversal-gates'><a id='x15-304000'></a><span class='cmbx-10x-x-109'>Transversal gates</span></span>
   A characterisation of when a stabiliser code has a transversal Hadamard,
<!-- l. 1615 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> or
CNOT gate was given in for instance the thesis of [<a href='main_htmlli3.html#Xgottesman1997stabilizer'>112</a>]. There he in fact shows
that if a stabiliser code has a transversal CNOT, then it <span class='cmti-10x-x-109'>must </span>be a CSS code.
The characterisation of transversal diagonal gates from the Clifford hierarchy is
based on [<a href='main_htmlli3.html#XWebster_2023'>235</a>], though the ZX version we present here is from [<a href='main_htmlli3.html#Xkissinger2024scalable'>149</a>]. In [<a href='main_htmlli3.html#XWebster_2023'>235</a>]
they also give an efficient algorithm for finding codes with transversal diagonal
gates.
</p>
<!-- l. 1616 --><p class='noindent'><span class='paragraphHead' id='surface-codes'><a id='x15-305000'></a><span class='cmbx-10x-x-109'>Surface codes</span></span>
   The surface code was introduced by [<a href='main_htmlli3.html#Xbravyi1998quantum'>38</a>], based on the slightly older
<span class='cmti-10x-x-109'>toric code </span>of Kitaev [<a href='main_htmlli3.html#Xkitaev1997quantum'>152</a>, <a href='main_htmlli3.html#Xkitaev2003fault'>153</a>] which considers a 2d lattice defined on a
<span class='cmti-10x-x-109'>torus</span>, i.e. a donut. So whereas the surface code has an actual boundary
where the lattice ends, in the toric code the surface loops around to
create the surface of a donut. An in-depth study of correcting errors on
the surface code by identifying connecting lines, and doing universal
computation using transversal CNOT gates and magic state injection was done
in [<a href='main_htmlli3.html#Xdennis2002topological'>81</a>]. There they also found a first estimate of a treshold for the surface
code. Transversal CNOTs are of course not practical for surface codes.
In [<a href='main_htmlli3.html#XPhysRevLett.98.190504'>200</a>, <a href='main_htmlli3.html#Xraussendorf2007topological'>197</a>] they use the method of introducing <span class='cmti-10x-x-109'>punctures</span>, i.e. holes, into a
surface code in order to encode multiple qubits into a single surface.
The distance of the code is then the distance between two holes and the
boundary. We can then perform two-qubit gates by deforming the code
and ‘rotating the holes around each other’. They find that this way of
performing computations gives a threshold of 0.75% (later improved to
<!-- l. 1616 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>1</mn><mi>%</mi></mrow></math>
in [<a href='main_htmlli3.html#XPhysRevA.83.020302'>231</a>]). A more accessible description of these results is given in [<a href='main_htmlli3.html#XPhysRevA.80.052312'>100</a>], and an
extensive review of this topic in [<a href='main_htmlli3.html#XPhysRevA.86.032324'>99</a>] where they also give an estimate that
running Shor’s algorithm to factor a 2000-bit number would take about 200
million qubits and a full day of computation. The more compact, ‘rotated’
version of the surface code we use was first introduced in [<a href='main_htmlli3.html#Xhorsman2012latticesurgery'>130</a>, Section
7.1].
                                                                     

                                                                     
</p>
<!-- l. 1618 --><p class='noindent'><span class='paragraphHead' id='decoding-and-perfect-matching'><a id='x15-306000'></a><span class='cmbx-10x-x-109'>Decoding and perfect matching</span></span>
   Decoding classical linear codes is in general NP-hard [<a href='main_htmlli3.html#XBerlekamp1978Decoding'>28</a>], and even
approximating the minimal-weight decoding remains NP-hard [<a href='main_htmlli3.html#XARORA1997317'>18</a>]. This remains
the case for quantum (stabiliser) codes [<a href='main_htmlli3.html#Xhsieh2011np'>132</a>] (note that this not obviously
follows, since for stabiliser codes we only care about decoding up to stabilisers
and this kind of degeneracy is not present in the classical case, so that a priori
the problem might become easier). However, this hardness only holds for
arbitrary codes with non-local stabiliser generators. The minimum-weight perfect
matching problem can be efficiently solved using the <span class='cmti-10x-x-109'>blossom algorithm</span> [<a href='main_htmlli3.html#Xedmonds1965paths'>93</a>].
However, even though it is efficient in the asymptotic sense, for a practical
implementation it must be <span class='cmti-10x-x-109'>really </span>fast, and hence people have spent a lot of effort
to make refined algorithms that lose optimality, but can run very fast or only
using a local amount of data [<a href='main_htmlli3.html#X10.1145_3579371.3589037'>230</a>, <a href='main_htmlli3.html#XPhysRevX.13.031007'>128</a>, <a href='main_htmlli3.html#Xdelfosse2020hierarchical'>80</a>, <a href='main_htmlli3.html#XPhysRevA.108.022401'>134</a>, <a href='main_htmlli3.html#Xskoric2023parallel'>214</a>]. <span class='cmti-10x-x-109'>PyMatching </span>is an
open-source Python package that implements several methods for decoding
topological codes [<a href='main_htmlli3.html#X10.1145_3505637'>127</a>].
</p>
<!-- l. 1619 --><p class='noindent'><span class='paragraphHead' id='lattice-surgery1'><a id='x15-307000'></a><span class='cmbx-10x-x-109'>Lattice surgery</span></span>
   As might be clear from those latter numbers, performing CNOTs by rotating
qubits around each other tends to be expensive. The idea of merging and
splitting rectangular patches of surface codes by <span class='cmti-10x-x-109'>lattice surgery </span>was introduced
by [<a href='main_htmlli3.html#Xhorsman2012latticesurgery'>130</a>]. That this indeed seems to be much more efficient than braiding was
argued in [<a href='main_htmlli3.html#Xfowler2018low'>98</a>]. An experimental demonstration of lattice surgery on real
hardware was presented in [<a href='main_htmlli3.html#Xerhard2021entangling'>95</a>].
</p>
<!-- l. 1621 --><p class='noindent'><span class='paragraphHead' id='error-correcting-codes-and-zx'><a id='x15-308000'></a><span class='cmbx-10x-x-109'>Error correcting codes and ZX</span></span>
   The surface code was first presented in the ZX-calculus by [<a href='main_htmlli3.html#Xhorsman2011quantum'>129</a>], who also
found that the logical function of the merging and splitting operation is actually
just Z- and X-spiders [<a href='main_htmlli3.html#Xhorsman2017surgery'>77</a>]. [<a href='main_htmlli3.html#Xduncan2013verifying'>89</a>] was the first paper to use ZX-calculus to verify
the correctness of an error correcting code (the Steane code), which was followed
up by a verification of ‘the smallest interesting colour code’ [<a href='main_htmlli3.html#XEPTCS266.10'>101</a>], which we
gave in Example <a href='#x15-294008r16'>12.4.16<!-- tex4ht:ref: ex:smallest-interesting-cc  --></a>. In [<a href='main_htmlli3.html#Xchancellor2016coherent'>51</a>] they used a proto version of scalable
ZX notation to find a new class of quantum codes. The correspondence
between phase-free ZX-diagrams and CSS codes was established by [<a href='main_htmlli3.html#Xkissinger2022phasefree'>142</a>],
where he also proved the correctness of lattice surgery in ZX. The ZX
description of transversal non-Clifford gates in triorthogonal codes is
from [<a href='main_htmlli3.html#Xkissinger2024scalable'>149</a>].
</p>
<!-- l. 1622 --><p class='noindent'><span class='paragraphHead' id='magic-state-distillation1'><a id='x15-309000'></a><span class='cmbx-10x-x-109'>Magic state distillation</span></span>
   The concept of distilling a noisy non-Clifford state by encoding it in a code with
                                                                     

                                                                     
a transversal non-Clifford gate was introduced by [<a href='main_htmlli3.html#Xbravyi2005universal'>36</a>], where they found the
15-to-1 protocol. This was generalised to an entire family of protocols based on
triorthogonal codes in [<a href='main_htmlli3.html#XPhysRevA.86.052329'>35</a>]. A protocol based on using the transversal Hadamard in
the <!-- l. 1623 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>⟦</mi><mn>4</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mi>⟧</mi></mrow></math>
code was given in [<a href='main_htmlli3.html#X10.5555_2481602.2481604'>172</a>]. This works a bit differently, as we use the transversal
Hadamard to perform a logical Hadamard eigenbasis measurement,
which distills the Hadamard eigenstate, which is Clifford equivalent to
<!-- l. 1623 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. The CCZ distillation
used to implement <!-- l. 1623 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates via catalysis was introduced in [<a href='main_htmlli3.html#XGidney2019efficientmagicstate'>105</a>]. A comprehensive analysis of running
Shor’s algorithm to factor a 2048-bit number using surface code lattice surgery
with this improved catalysed CCZ distillation scheme was given in [<a href='main_htmlli3.html#XGidney2021howtofactorbit'>104</a>], where
they find you require 20 million qubits and 8 hours of computation time, a large
improvement over the older scheme using braiding and iterated 15-to-1
distillation.
</p>
<!-- l. 1624 --><p class='noindent'><span class='paragraphHead' id='even-further-reading'><a id='x15-310000'></a><span class='cmbx-10x-x-109'>Even further reading</span></span>
   An excellent overview of quantum error correction and fault-tolerance
can be found in the book of [<a href='main_htmlli3.html#Xgottesman2016surviving'>114</a>], which at the time of this writing was
available as a preprint freely online. A standard, comprehensive, and
approachable text on classical error correction is [<a href='main_htmlli3.html#Xsloanemacwilliams'>167</a>]. An accessible and quite
comprehensive fault-tolerant quantum computing scheme based on surface code
lattice surgery and magic state distillation is <span class='cmti-10x-x-109'>A Game of Surface Codes</span>
by [<a href='main_htmlli3.html#XLitinski2019gameofsurfacecodes'>164</a>].
                                                                     

                                                                     
</p>
   <!-- l. 1 --><div class='crosslinks'><p class='noindent'>[<a href='main_htmlli3.html'>next</a>] [<a href='main_htmlch11.html'>prev</a>] [<a href='main_htmlch11.html#tailmain_htmlch11.html'>prev-tail</a>] [<a href='main_htmlch12.html'>front</a>] [<a href='main_html.html#main_htmlch12.html'>up</a>] </p></div>
<!-- l. 1 --><p class='indent'>   <a id='tailmain_htmlch12.html'></a></p> 
<script type="text/javascript" src="proof_collapse.js"></script> 
<script type="text/javascript" src="navigation_menu.js"></script>
<script type="text/javascript" src="update_figure_margins.js"></script></body> 
</html>