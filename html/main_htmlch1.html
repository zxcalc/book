<!DOCTYPE html> 
<html lang='en-US' xml:lang='en-US'> 
<head><title>1 Introduction</title> 
<meta charset='utf-8' /> 
<meta content='TeX4ht (https://tug.org/tex4ht/)' name='generator' /> 
<meta content='width=device-width,initial-scale=1' name='viewport' /> 
<link href='main_html.css' rel='stylesheet' type='text/css' /> 
<meta content='main_html.tex' name='src' /> 
 <script async='async' id='MathJax-script' src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-chtml.js' type='text/javascript'></script>  
</head><body>
   <!-- l. 7 --><div class='crosslinks'><p class='noindent'>[<a href='main_htmlch2.html'>next</a>] [<a href='main_htmlli2.html'>prev</a>] [<a href='main_htmlli2.html#tailmain_htmlli2.html'>prev-tail</a>] [<a href='#tailmain_htmlch1.html'>tail</a>] [<a href='main_html.html#main_htmlch1.html'>up</a>] </p></div>
   <h2 class='chapterHead' id='introduction'><span class='titlemark'>Chapter 1</span><br /><a id='x4-30001'></a>Introduction</h2>
     <blockquote class='quote'>
     <!-- l. 10 --><p class='noindent'>“Maybe in order to understand Mankind, we should look at the
     word itself. Basically, it’s made up of two separate words ‘mank’
     and ‘ind’. What do these words mean? It’s a mystery. And that’s
     why so is mankind.”
     </p><!-- l. 10 --><p class='noindent'>    - <span class='cmti-10x-x-109'>Deep Thoughts by Jack Handy. Saturday Night Live 1993</span>
     </p></blockquote>
<!-- l. 11 --><p class='noindent'>Maybe in order to understand what this book is about, we should break it up
into its parts: “Picturing” and “Quantum Software”. Let’s talk about the
second part first. Broadly, quantum software refers to the “code” that
runs on a quantum computer. This can mean many different things and
many different levels: ranging from <span class='cmti-10x-x-109'>quantum algorithms</span>, i.e. high-level
descriptions of how to solve problems with a quantum computer, all the
way down to actual low-level code used to program specialised hardware
like microwave emitters that are actually responsible for making things
happen to quantum systems and reading out the results. This book is
largely focused on what lies between those two levels and also how we
can move from higher-level descriptions of a computation to lower-level
ones. In classical computing, passing from a high-level programming
language to low-level machine code is called <span class='cmti-10x-x-109'>compilation</span>. Compilers are
extremely important to making classical computers work, both because
high-level programming is crucial to representing something as complex
as an operating system or a web application and because a big reason
why modern computers are so fast is because advanced compilers do
huge amounts of optimisation to programs in order to squeeze as much
performance as possible out of your computer. As quantum computers are
starting to take shape, so is a new field of <span class='cmbx-10x-x-109'>quantum compilation</span>. Instead
of just directly focusing on the code that runs on quantum computers
(e.g. quantum circuits, which we’ll introduce in the next chapter), it is
becoming increasingly interesting to focus on the “code that makes that
code” or even the “code that makes that code better”. There are a lot of
interesting problems in this area, many of which we’ll touch on in this book.
The problem most analogous to classical compilation is the following:
given a high-level description of a quantum computation, can we build a
<span class='cmbx-10x-x-109'>quantum circuit </span>to perform that computation? Quantum circuits are a <span class='cmti-10x-x-109'>de
facto </span>assembly language for quantum computation, and form the most
important part in how a quantum computation is described using the
                                                                     

                                                                     
<span class='cmti-10x-x-109'>quantum circuit model</span>. The latter is a straightforward way to describe
quantum computations, which is <span class='cmti-10x-x-109'>computationally universal </span>(in the sense we
describe in Section <a href='main_htmlch2.html#approximate-universality'>2.3.5<!-- tex4ht:ref: sec:universal-gates  --></a>). Quantum circuits give a simple description
of a quantum process by means of a sequence of primitive operations,
called <span class='cmbx-10x-x-109'>gates</span>, which are applied on a register of quantum memory, e.g.
</p>
<div class='center'>
<!-- l. 15 --><p class='noindent'>
</p><!-- l. 16 --><p class='noindent'><object data="svgs/circ.svg" alt="diagram of circ" class="svg-diagram"></object> </p></div>
<!-- l. 18 --><p class='noindent'>Here, we have deliberately been a bit ambiguous about what a “high-level
description” means. This could be a program in a high level (quantum)
programming language. Such languages do exist (as we’ll survey briefly in the
references of Chapter <a href='main_htmlch2.html#the-quantum-circuit-model'>2<!-- tex4ht:ref: ch:circuit  --></a>), but are still in their infancy. At the time of this writing,
it is still not clear which “genuinely quantum” features are useful to have in a
quantum programming language, and the majority of what gets called “quantum
programming” these days amounts to using some specialised libraries in a
familiar classical programming language like Python to build (and sometimes
run) quantum circuits. In fact, you’ll get to experiment with many of the
techniques we discuss in this book using our Python library <span class='cmbx-10x-x-109'>PyZX</span>, but more on
that later. In addition to a program written in a high-level language, a
high-level description of a quantum computation could mean various other
things, depending on the application. For example, it could simply be a
big unitary matrix, which as we will review in Chapter <a href='main_htmlch2.html#the-quantum-circuit-model'>2<!-- tex4ht:ref: ch:circuit  --></a>, are the way
quantum processes are modelled mathematically. However, this method of
representing a computation grows exponentially in size with the number of
quantum bits, or <span class='cmbx-10x-x-109'>qubits</span>, involved in a computation, so it is not feasible for
concretely representing computations on more than a dozen qubits or so.
Also, we don’t know about you, but we don’t personally find staring at a
matrix full of numbers to be the most enlightening way to understand
what is actually going on. This brings us to the other part of the title:
“Picturing”. This book focuses heavily on representing quantum computations
using pictures. Unlike the kinds of pictures you might know, e.g. from a
physics textbook, where simple diagrams are used to aid our intuitions,
but all the “real math” happens in good old fashioned formulas, in this
book, the diagrams <span class='cmti-10x-x-109'>are </span>the real math. We will begin by introducing
<span class='cmbx-10x-x-109'>string diagram </span>notation in the next chapter. This notation, usually
attributed to Roger Penrose, gives a rigorous way to describe complex
linear operators using diagrams consisting of boxes and wires like this
one:
</p>
<div class='center'>
<!-- l. 22 --><p class='noindent'>
                                                                     

                                                                     
</p><!-- l. 23 --><p class='noindent'><object data="svgs/tensor-net.svg" alt="diagram of tensor-net" class="svg-diagram"></object> </p></div>
<!-- l. 26 --><p class='indent'>   Perhaps the most interesting thing about such diagrams is that we can
use them to directly calculate stuff by transforming one diagram into
another. In particular, suppose we knew that two different diagrams actually
describe the same linear map. Then we might write something like this:
</p><table class='equation'><tr><td>
<!-- l. 27 --><p class='indent'>
</p><!-- l. 27 --><object id='x4-3001r1' data="svgs/eq-diagram-eq.svg" alt="diagram of eq:diagram-eq" class="svg-diagram"></object></td><td class='eq-no'>(1.1)</td></tr></table>
<!-- l. 30 --><p class='indent'>   We’ll see how such diagrams actually correspond to linear maps in
Section <a href='main_htmlch2.html#tensor-networks-and-string-diagrams'>2.1.6<!-- tex4ht:ref: sec:string-diagrams  --></a>, but even before we know that, it is possible to explain how we
could <span class='cmti-10x-x-109'>use </span>a diagrammatic equation like (<a href='#x4-3001r1'>1.1<!-- tex4ht:ref: eq:diagram-eq  --></a>): if we see one side of this equation
in a bigger diagram, we can “chop it out” and replace it with the other side to
get a new diagram:
</p>
<div class='center'>
<!-- l. 32 --><p class='noindent'>
</p><!-- l. 33 --><p class='noindent'><object data="svgs/comp-example-pf.svg" alt="diagram of comp-example-pf" class="svg-diagram"></object> </p></div>
<!-- l. 36 --><p class='indent'>   Thus, from a small equation, we have derived a bigger one. This way of doing
calculations directly on diagrams is called <span class='cmbx-10x-x-109'>diagrammatic reasoning</span>. The
“spiritual predecessor” to this book, <span class='cmti-10x-x-109'>Picturing Quantum Processes</span>, described the
basic principles of quantum and classical processes and how they interact using
diagrammatic reasoning. Along the way, it introduced a particular set of
string-diagram equations called the <span class='cmti-10x-x-109'>ZX-calculus</span>, which turns out to be extremely
useful for doing just about anything you’d want to do with quantum
circuits and related structures. However, that book just gave the slightest
inkling of how one might apply ZX to solve concrete problems in quantum
software, and didn’t say much about how the ZX-calculus picture relates to
the whole myriad of techniques developed over the past few decades for
designing and reasoning about quantum software. In this book, we will dive
straight into using the language of ZX to work concretely with quantum
                                                                     

                                                                     
circuits. This turns out to be a very good language to explain many
concepts in quantum software that were not originally introduced using
diagrammatic methods, such as stabiliser theory, phase polynomials,
measurement-based quantum computation, and quantum error correcting codes.
Whether readers are familiar with these concepts or meeting them for the
first time, the ZX-calculus offers an intuitive look at the few (relatively
simple) structures at play, and how they come together to make quantum
computations behave the way they do. A simple, “Hello World” style
example is quantum teleportation, which we’ll go through in some detail in
Section <a href='main_htmlch3.html#teleportation'>3.3.2<!-- tex4ht:ref: sec:teleportation  --></a>. This is a simple quantum protocol where Alice and Bob can
use a shared entangled state and some classical communication to allow
Alice to send an arbitrary quantum state to Bob. In a typical quantum
computing textbook, you would probably see teleportation pictured like
this:
</p>
<div class='center'>
<!-- l. 41 --><p class='noindent'>
</p><!-- l. 42 --><p class='noindent'><object data="svgs/teleport-state.svg" alt="diagram of teleport-state" class="svg-diagram"></object> </p></div>
<!-- l. 45 --><p class='indent'>   followed by a fairly elaborate linear algebraic calculation to show that it
actually works. By the time we get to Chapter <a href='main_htmlch3.html#the-zxcalculus'>3<!-- tex4ht:ref: ch:zx  --></a>, we’ll see that the ZX-calculus
makes these kinds of calculations super easy. After translating the quantum
circuit diagram above into ZX language, we can calculate what it does using just
a few graphical rules: </p><table class='equation-star'><tr><td>
<!-- l. 46 --><object data="svgs/teleport-state-zx-nolabel.svg" alt="diagram of teleport-state-zx-nolabel" class="svg-diagram"></object></td></tr></table>
<!-- l. 49 --><p class='indent'>   In the end, we get just a wire passing from Alice to Bob, capturing that fact
that any quantum state Alice starts with will pop out on Bob’s side. We’ll see
over the following nine chapters that these techniques can be pushed a
lot further than toy examples to explain some of the most important
structures, concepts, and algorithms in the design and analysis of quantum
software.
                                                                     

                                                                     
</p>
   <h3 class='sectionHead' id='how-to-read-this-book'><span class='titlemark'>1.1   </span> <a id='x4-40001.1'></a>How to read this book</h3>
<!-- l. 52 --><p class='noindent'>We’re glad you made it here! Or, for those coming from <span class='cmti-10x-x-109'>Picturing Quantum
Processes</span>, we’re glad you made it back! This book caters to a variety of people
with a variety of different backgrounds. As such, you may want to read this book
differently depending on what you know already, and what you hope to get out of
it. This section is intended to give a roadmap for a few different kinds of
readers.
</p>
   <h4 class='subsectionHead' id='from-scratch'><span class='titlemark'>1.1.1   </span> <a id='x4-50001.1.1'></a>From scratch</h4>
<!-- l. 54 --><p class='noindent'>This book is designed to function well as a <span class='cmti-10x-x-109'>second </span>course in quantum
computing. However, this book is also designed to be pretty self-contained,
which means there is nothing to stop you from diving in with nothing
but a bit of linear algebra under your belt. Some basic topics are not
covered in as much depth as you’ll find in a first text, and also some
intuitions may be taken for granted. To adopt this strategy, we suggest you
start with the next chapter, then if you get confused, or want to know
something more in depth, pick up one of the following books to help you out:
</p>
     <ul class='itemize1'>
     <li class='itemize'>
     <!-- l. 56 --><p class='noindent'><span class='cmti-10x-x-109'>Picturing Quantum Processes: A First Course in Quantum Theory and
     Diagrammatic Reasoning</span>. [<a href='main_htmlli3.html#XCKbook'>62</a>]. Cambridge University Press.
          </p><blockquote class='quote'>
          <!-- l. 59 --><p class='noindent'>Picturing Quantum Processes (PQP) is, in some sense, the
          prequel to the current book. It introduces quantum theory
          from first principles using a fully diagrammatic language,
          and  uses  that  language  to  go  into  detail  on  quantum
          processes,  quantum  and  classical  interaction,  quantum
          entanglement,  quantum  communication  protocols,  and  a
          bit  of  quantum  computing.  We  do  not  explicitly  assume
          familiarity with PQP, but it can be read before or in parallel
          with this book to get a fuller picture. </p></blockquote>
     </li>
     <li class='itemize'>
     <!-- l. 61 --><p class='noindent'><span class='cmti-10x-x-109'>Quantum in Pictures</span>. [<a href='main_htmlli3.html#Xquantuminpictures'>60</a>]
                                                                     

                                                                     
          </p><blockquote class='quote'>
          <!-- l. 64 --><p class='noindent'>A (nearly) math-free introduction to quantum theory using
          pictures, including the ZX-calculus. This is also good for
          younger readers and non-scientists and can probably be read
          in an afternoon. </p></blockquote>
     </li>
     <li class='itemize'>
     <!-- l. 66 --><p class='noindent'><span class='cmti-10x-x-109'>Quantum Computation and Quantum Information</span>. [<a href='main_htmlli3.html#XNielsenChuang'>188</a>], (2000 first ed.).
     Cambridge University Press.
          </p><blockquote class='quote'>
          <!-- l. 69 --><p class='noindent'>This is the standard text on quantum computing. It is a
          comprehensive introduction to the topic; it has been called
          the  “bible  of  quantum  computing”.  However  due  to  the
          amount of material covered, it is relatively long and dense,
          especially for readers starting from scratch. </p></blockquote>
     </li>
     <li class='itemize'><span class='cmti-10x-x-109'>An Introduction to Quantum Computing</span>. [<a href='main_htmlli3.html#Xkaye2007introduction'>140</a>]. Oxford University
     Press.
     </li>
     <li class='itemize'>
     <!-- l. 72 --><p class='noindent'><span class='cmti-10x-x-109'>Quantum Computer Science: an introduction</span>. [<a href='main_htmlli3.html#Xmermin2007quantum'>174</a>]. Cambridge University
     Press.
          </p><blockquote class='quote'>
          <!-- l. 75 --><p class='noindent'>These  are  both  shorter,  gentler  introductory  texts  in
          quantum computing. We’d suggest picking one of these up to
          learn quantum computing for the first time, and eventually
          grabbing a copy of Nielsen &amp; Chuang for reference. </p></blockquote>
     </li>
     <li class='itemize'>
     <!-- l. 77 --><p class='noindent'><span class='cmti-10x-x-109'>Categories for Quantum Theory: An Introduction</span>. [<a href='main_htmlli3.html#Xheunen2019categories'>125</a>]. Oxford University
     Press.
                                                                     

                                                                     
          </p><blockquote class='quote'>
          <!-- l. 80 --><p class='noindent'>The  graphical  notation  we  use  in  this  book  traces  its
          origins back to <span class='cmti-10x-x-109'>categorical quantum mechanics</span>, a category
          theory-based approach to studying quantum theory. While
          category  theory  is  strictly  optional  to  learn  and  use
          ZX-calculus, this book is for readers who are interested in
          the deep mathematical and categorical structures underlying
          the  graphical  calculus,  such  as  Frobenius  algebras,  Hopf
          algebras, and 2-categories. </p></blockquote>
     </li></ul>
<!-- l. 83 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='coming-from-picturing-quantum-processes'><span class='titlemark'>1.1.2   </span> <a id='x4-60001.1.2'></a>Coming from <span class='cmti-10x-x-109'>Picturing Quantum Processes</span></h4>
<!-- l. 84 --><p class='noindent'>You will notice a few things if you’ve landed here straight from the ‘spiritual’
prequel to this book <span class='cmti-10x-x-109'>Picturing Quantum Processes: A First Course in Quantum
Theory and Diagrammatic Reasoning </span>(which we’ll call PQP in this section). The
first is we don’t mention <span class='cmti-10x-x-109'>process theories </span>at all in this book, even though they
were a big deal in PQP. Process theories give us a general way to talk about
processes and computation that includes quantum theory but also many other
theories, such as classical probability theory and even “super-quantum” theories
which allow processes which (we think) are not physically possible. While it is
fascinating, and foundationally important, to understand quantum theory as
just one example of many possible ways the world could have been, we
will forgo discussion of generic process theories in this book and assume
everything is quantum, right from the beginning! Well, that’s actually not
quite true. PQP introduced a process theory of <span class='cmbx-10x-x-109'>linear maps</span>, where
wires represent Hilbert spaces and boxes represent linear maps, then
obtained the theory of <span class='cmbx-10x-x-109'>quantum maps </span>by some diagrammatic trickery.
For simplicity, we will pretty much exclusively work in the theory of
<span class='cmbx-10x-x-109'>linear maps </span>in this book. As you might recall from PQP, linear maps
are pretty much the same thing as <span class='cmbx-10x-x-109'>pure quantum maps</span>, as long as
we (1) compute probabilities by taking the absolute value squared of
complex numbers, and (2) throw away global phases. It turns out, for
all of the concepts in this book, that’s good enough for us! This extra
simplicity comes at a price, in that we don’t give ourselves access to the
elegant graphical techniques for representing mixed quantum states and
processes as well as classical-quantum interaction. However, readers with a
good handle on these techniques from PQP will probably notice many
places they can be applied throughout this book, and we invite them to
explore and be creative when filling in these gaps. One final difference
                                                                     

                                                                     
to note, is that in PQP time in diagrams flowed from the bottom to
the top, while in this book every diagram should be read from left to
right.
</p>
   <h4 class='subsectionHead' id='coming-from-another-quantum-computing-background'><span class='titlemark'>1.1.3   </span> <a id='x4-70001.1.3'></a>Coming from another quantum computing background</h4>
<!-- l. 90 --><p class='noindent'>If you are already used to looking at <!-- l. 90 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mstyle class='text'><mtext class='textrm' mathvariant='normal'>this</mtext></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
<!-- l. 90 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mstyle class='text'><mtext class='textrm' mathvariant='normal'>kind</mtext></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
<!-- l. 90 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mstyle class='text'><mtext class='textrm' mathvariant='normal'>of</mtext></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
<!-- l. 90 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mstyle class='text'><mtext class='textrm' mathvariant='normal'>stuff</mtext></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, but
not necessarily <span class='cmti-10x-x-109'>pictures </span>of quantum processes, welcome! We have tried to
write this book such that readers with little prior experience with the
graphical notation for quantum maps will start to feel comfortable with
it in no time, and start using diagrams as a natural extension of the
quantum circuit notation you undoubtedly already know and love. You may
want to briefly look through Section <a href='main_htmlch2.html#preliminaries'>2.1<!-- tex4ht:ref: sec:prelims  --></a>, and in particular <a href='main_htmlch2.html#tensor-networks-and-string-diagrams'>2.1.6<!-- tex4ht:ref: sec:string-diagrams  --></a>, as we
introduce the graphical notation for linear maps along side the usual
bra-ket notation. In those sections, we explain the 3-fold correspondence
between bra-ket language, tensor networks, and string diagrams. We use
this correspondence throughout the book, in order to freely switch to
whichever tool is best for the job at hand (spoiler alert: it is usually string
diagrams!). After going through Section <a href='main_htmlch2.html#preliminaries'>2.1<!-- tex4ht:ref: sec:prelims  --></a>, you’ll probably not have much
problem skipping over the rest of Chapter <a href='main_htmlch2.html#the-quantum-circuit-model'>2<!-- tex4ht:ref: ch:circuit  --></a> and diving straight into the
ZX-calculus in Chapter <a href='main_htmlch3.html#the-zxcalculus'>3<!-- tex4ht:ref: ch:zx  --></a>. Note that even if you are already familiar
with some of the concepts we talk about in this book, you might find
that we approach it with quite a different perspective. So even for the
quantum computing expert there should be enough to discover in this
book!
</p>
   <h3 class='sectionHead' id='overview'><span class='titlemark'>1.2   </span> <a id='x4-80001.2'></a>Overview</h3>
<!-- l. 95 --><p class='noindent'>Throughout the book you will see certain remarks, sections and exercises with a
star*. We consider this to be ‘optional’ material. For the Remarks*, these usually
explain some technical details that we otherwise glossed over which are not
that important to understand the main points in the chapter, but are
necessary to have a fully correct mathematical picture. You can read these
if you want to know the technical nitty-gritty. The Sections* usually
cover additional material that is either more advanced, more technical, or
simply acts as a nice dessert to the chapter they are in, so feel free to only
read these if you are particularly interested in the topic. The starred
Exercises* are extra hard exercises that are (much) more time consuming than
                                                                     

                                                                     
the regular exercises, and might require you to make larger jumps on
logic or rely on a larger set of tools to solve it. We recommend you skip
solving these on a first read-through as there more than a hundred regular
exercises you can try first. This book can be split roughly into three
parts:
</p>
<div class='center'>
<!-- l. 100 --><p class='noindent'>
</p><!-- l. 101 --><p class='noindent'><object data="svgs/outline.svg" alt="diagram of outline" class="svg-diagram"></object> </p></div>
<!-- l. 104 --><p class='indent'>   In the first part of the book, Chapters 1–3, we introduce the basics
of quantum computation and the main tool we’ll be using throughout
the book: the ZX-calculus. After this introductory chapter, we move to
<span class='cmbx-10x-x-109'>Chapter 2: The Quantum Circuit Model</span>, which briefly reviews
the mathematical preliminaries you will need (namely linear algebra
over the complex numbers) and gives a short, pragmatic introduction to
quantum theory by explaining what we call the <span class='cmbx-10x-x-109'>SCUM postulates</span>.
</p>
     <ul class='itemize1'>
     <li class='itemize'><span class='cmbx-10x-x-109'>States </span>of a quantum system correspond to vectors in a Hilbert space.
     </li>
     <li class='itemize'><span class='cmbx-10x-x-109'>Compound systems </span>are represented by the tensor product.
     </li>
     <li class='itemize'><span class='cmbx-10x-x-109'>Unitary maps </span>evolve states in time.
     </li>
     <li class='itemize'><span class='cmbx-10x-x-109'>Measurements </span>are computed according to the Born rule. </li></ul>
<!-- l. 111 --><p class='noindent'>We then introduce some basic building blocks of quantum circuits, and explain some
of the most important facts about circuits, such as universality of gate sets,
which we will use throughout the book. What you will NOT find in this chapter
(as opposed to virtually any other introduction to quantum computing) is much
discussion about quantum algorithms. These of course are the reason one wants
to study quantum computation in the first place. However, since we will be
focusing on quantum compiling in this book, we will mostly abstract over specific
                                                                     

                                                                     
quantum algorithms and focus mainly on the sorts of circuit structures that arise
from “typical” algorithms and how to work with them effectively. To
get a deeper appreciation for how specific algorithms yield the kinds of
circuits we will study, we encourage readers to have a look at some of
the resources mentioned in Section <a href='#from-scratch'>1.1.1<!-- tex4ht:ref: sec:from-scratch  --></a> and also in the References and
Further Reading sections at the end of each chapter. <span class='cmbx-10x-x-109'>Chapter 3: The
ZX-Calculus </span>introduces ZX-diagrams, the main graphical representation we’ll
use for all the quantum computations we study in this book, as well as
the ZX-calculus, a simple set of rules for transforming and simplifying
ZX-diagrams. We also give some examples of “ZX in action”, where we show
how to perform simple computations using ZX. We focus mainly here
on manipulating ZX-diagrams by hand, leaving the more high-powered
theorems and automated techniques involving the ZX-calculus for later.
The next part of the book, Chapters 4–7, build up slowly from very
restricted families of circuits and ZX-diagrams to full-powered, <span class='cmti-10x-x-109'>universal</span>
quantum computation. In Chapters <a href='main_htmlch4.html#cnot-circuits-and-phasefree-zxdiagrams'>4<!-- tex4ht:ref: ch:phasefree  --></a> and <a href='main_htmlch5.html#clifford-circuits-and-diagrams'>5<!-- tex4ht:ref: ch:clifford  --></a>, we introduce particular,
non-universal gate sets, and corresponding <span class='cmbx-10x-x-109'>fragments </span>of the ZX-calculus,
whose unitary ZX-diagrams are precisely the circuits constructible in
those gate sets. A natural question is then: Why consider more limited
kinds of quantum computations and not just jump straight to maximum
power? This is because, like in many areas of science, there is a delicate
balancing act between how powerful a system is and how much we can say
about it. The paradigmatic example in classical computation is Turing
machines. These are super powerful, so powerful that if a computation is
even <span class='cmti-10x-x-109'>possible </span>to do on a computer (classical or quantum!), then it is
possible with a Turing machine. However, if we pluck a Turing machine out
of the air, we can say almost nothing about it. We don’t even know if
it will halt with an answer or just run forever. At the other extreme
are finite state machines. These are much, much weaker than Turing
machines, but we can compute (often efficiently) pretty much anything
we want to know about them. Does this machine ever answer Yes for
some input? How about infinitely many inputs? Do these two machines
actually do the same thing? These questions and many others are pretty
easy to answer for finite state machines, but extremely hard for Turing
machines. A similar thing can be said for quantum computations. The
more powerful the gate set, the closer we are to fully universal quantum
computation, and the more difficult it becomes to simulate, optimise, and answer
questions about, the quantum circuits we can build. Generally this should
be regarded as A Good Thing. Indeed if it were possible to efficiently
simulate universal quantum circuits, you wouldn’t be reading this book in
the first place. However, it is nevertheless an interesting and fruitful
question to ask what kinds of quantum computations <span class='cmti-10x-x-109'>can </span>be simulated on
a classical computer or otherwise efficiently reasoned about. It turns
out this goes much farther than one might initially expect. In <span class='cmbx-10x-x-109'>Chapter
                                                                     

                                                                     
4: CNOT Circuits and Phase-Free ZX-Diagrams</span>, we look just
at those circuits constructible using CNOT gates, and show these are
closely connected to the <span class='cmti-10x-x-109'>phase-free </span>ZX-calculus, i.e. the calculus involving
ZX-diagrams whose phase parameters are all restricted to zero. This
will give us some important insights into how this single entangling gate
interacts with itself, and how linear algebra over the two-element field
<!-- l. 120 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math> plays
an important role in the structure of quantum computations. We will also meet
the first automated simplification strategy for ZX diagrams, which always
efficiently terminates for phase-free diagrams in what we call a <span class='cmbx-10x-x-109'>normal form</span>.
These normal forms can tell us a lot about a computation, and also admit
strategies for “extracting” circuits back out. Furthermore, these normal forms
will come back with a vengeance when we discuss quantum error correcting codes
in Chapter <a href='main_htmlch12.html#quantum-error-correction'>12<!-- tex4ht:ref: ch:qec  --></a>. In <span class='cmbx-10x-x-109'>Chapter 5: Clifford Circuits and Diagrams</span>, we add the
H and S gates to CNOT circuits to obtain a much richer, much “more quantum”
family of circuits, the Clifford circuits, while still retaining lots of structure, and
importantly, efficient classical simulability. Clifford circuits, despite leaving
the realm of what we would normally call classical computation, are
efficiently classically simulable thanks to the <span class='cmti-10x-x-109'>Gottesman-Knill theorem</span>. We
will take an unconventional route to proving this famous theorem by
going via the corresponding fragment of the ZX-calculus: the <span class='cmti-10x-x-109'>Clifford</span>
ZX-calculus, whose phase parameters are restricted be integer multiples of
<!-- l. 122 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>. Like
in the phase-free case, we give an automated strategy for efficiently turning any
Clifford ZX-diagram into a compact normal form. In fact, we’ll look at two
different normal forms, which are closely related, and can be applied to solve
three important problems for Clifford circuits: efficient classical simulation,
equality testing, and circuit optimisation/resynthesis. In <span class='cmbx-10x-x-109'>Chapter 6: Stabiliser
Theory</span>, we introduce an equivalent, and more widespread, technique for
studying Clifford circuits, called stabiliser theory. Rather than restricting
the class of gates used to build Clifford circuits, we give a more global,
group-theoretic characterisation of the Cliffords in terms of certain subgroups of
the Pauli group called stabiliser groups. Such a group can always be represented
by listing a small number of generators, and this in turn enables us to perform
many tasks involving Clifford circuits efficiently by working not with the
(exponentially large) unitary matrix, but with this set of generators of the
stabiliser group. Using this formalism, we will see a more traditional
approach to proving the Gottesman-Knill theorem, and also how to get the
best of both worlds by converting back-and-forth between stabiliser and
ZX representations. Finally, in <span class='cmbx-10x-x-109'>Chapter 7: Universal Circuits</span>, we
meet full-powered quantum computation. We will see that it is useful to
treat universal circuits as Clifford circuits with a bit of “special sauce”
mixed in: namely arbitrary Z-phase gates. We first see what happens
when we mix arbitrary phase gates into CNOT circuits, and we find we
                                                                     

                                                                     
can reuse some of the tricks from Chapter <a href='main_htmlch5.html#clifford-circuits-and-diagrams'>5<!-- tex4ht:ref: ch:clifford  --></a> to efficiently represent the
resulting unitaries. A structure that emerges naturally is that of <span class='cmbx-10x-x-109'>phase
polynomials</span>, which have a graphical ZX representation using <span class='cmbx-10x-x-109'>phase
gadgets</span>. We will also show that there are two ways to extend phase
polynomials/gadgets to model universal circuits: using <span class='cmbx-10x-x-109'>path sums </span>and <span class='cmbx-10x-x-109'>Pauli
gadgets</span>, each with various benefits and applications. We will show how these
structures can be used to implement a simple circuit optimisation technique
called <span class='cmbx-10x-x-109'>phase folding</span>. We will find many other applications for these
structures in Chapters 9–11. The third part of the book extends the
structures developed in part 2 in various different directions. Until this
point, the dependency between chapters is essentially linear, but here it
splits. On one track is <span class='cmbx-10x-x-109'>Chapter 8: Measurement-based Quantum
Computing</span>, where we introduce an alternative model of quantum computation
called measurement-based quantum computation (MBQC), and show
how it is equivalent to the circuit model. In the process, we will learn
some new things about the structure of ZX diagrams, which turn out
to be closely related to certain kinds of measurement-based quantum
computations. Notably, we will see when it is possible to efficiently extract a
quantum circuit from a ZX-diagram (or MBQC computation) using a
graph-theoretic notion called <span class='cmbx-10x-x-109'>generalised flow</span>. While not strictly necessary to
understand the following chapters, the idea of using measurements and
corrections to deterministically implement quantum operations will be a
running theme in this part of the book. On the other track, we continue
to develop the structure of universal quantum circuits. In <span class='cmbx-10x-x-109'>Chapter 9:
Controlled Gates and Classical Oracles</span>, we see how the basic gates and
ZX-diagrams we have studied so far can be used to construct higher-level gates,
particularly to add control wires and to embed complex classical functions into
quantum computations. We will introduce a new spider-like generator
for ZX-diagrams called the <span class='cmbx-10x-x-109'>H-box </span>which is especially convenient for
dealing with these higher-level structures and explaining how phase gadgets
and H-boxes are related to each other by a type of “graphical Fourier
transform”. In <span class='cmbx-10x-x-109'>Chapter 10: Clifford+T</span>, we will specialise from the
exactly universal computations we have been studying so far to Clifford+T
circuits. Remarkably, if we add just one additional gate, called the T
gate, to Clifford circuits, we obtain an approximately universal family of
quantum circuits. The graphical analogue to such circuits are Clifford+T
ZX-diagrams, i.e. diagrams whose phase parameters are integer multiples of
<!-- l. 128 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>. It turns
out that when we restrict the angles in this way (and more generally to angles of the
form <!-- l. 128 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mfrac><mrow><mi>π</mi></mrow>
<mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>ℓ</mi></mrow></msup></mrow></mfrac></mrow></math>),
lots of interesting new structures start to emerge. We explore how these
structures can be used to efficiently approximate any unitary using Clifford+T
circuits, perform certain sophisticated circuit optimisations, and prove
completeness and universality results for increasingly large fragments of the
                                                                     

                                                                     
ZX/ZH calculus. Finally, in <span class='cmbx-10x-x-109'>Chapter 11: Quantum Error Correction</span>, we
introduce quantum error correction and fault-tolerant quantum computation.
This brings together almost all of the concepts that have come before. Notably,
we use the phase-free normal forms we met back in Chapter <a href='main_htmlch4.html#cnot-circuits-and-phasefree-zxdiagrams'>4<!-- tex4ht:ref: ch:phasefree  --></a> to construct a
graphical depiction of encoder maps, which enable error correction by embedding
a collection of logical qubits into a larger collection of physical qubits. We see
how to check for errors in this encoded quantum data using measurements
represented by the Pauli projections from Chapter <a href='main_htmlch6.html#stabiliser-theory'>6<!-- tex4ht:ref: ch:stabiliser  --></a>, and build toward a
universal set of fault-tolerant operations for implementing quantum computations
on encoded qubits. An important ingredient is something called <span class='cmbx-10x-x-109'>magic-state
distillation</span>, which we can derive using the structure of T gates developed in
Chapter <a href='main_htmlch11.html#cliffordt'>11<!-- tex4ht:ref: ch:clifford-t  --></a>. Once we distil magic states, we can inject them into our
computations using a technique we met way back in Chapter <a href='main_htmlch2.html#the-quantum-circuit-model'>2<!-- tex4ht:ref: ch:circuit  --></a>! Putting all of
these ingredients together, we obtain a way to implement universal quantum
computation in a way that can, in principle, be made arbitrarily robust to errors.
So that’s the plan. Let’s get started!    </p><!-- l. 7 --><div class='crosslinks'><p class='noindent'>[<a href='main_htmlch2.html'>next</a>] [<a href='main_htmlli2.html'>prev</a>] [<a href='main_htmlli2.html#tailmain_htmlli2.html'>prev-tail</a>] [<a href='main_htmlch1.html'>front</a>] [<a href='main_html.html#main_htmlch1.html'>up</a>]
</p></div>
<!-- l. 7 --><p class='indent'>   <a id='tailmain_htmlch1.html'></a></p> 
<script type="text/javascript" src="proof_collapse.js"></script> 
<script type="text/javascript" src="navigation_menu.js"></script>
<script type="text/javascript" src="update_figure_margins.js"></script></body> 
</html>